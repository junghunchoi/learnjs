(function (t) {
  const e = (t["ko"] = t["ko"] || {});
  e.dictionary = Object.assign(e.dictionary || {}, {
    "%0 of %1": "%0 / %1",
    Accept: "수락",
    Aquamarine: "연한 청록색",
    Big: "큰",
    Black: "검은색",
    Blue: "파랑색",
    Bold: "굵게",
    Cancel: "취소",
    Clear: "지우기",
    "Click to edit block": "클릭하여 블록 편집",
    Code: "코드",
    Default: "기본",
    "Dim grey": "진한 회색",
    "Document colors": "문서 색깔들",
    "Drag to move": "드래그하여 이동",
    "Dropdown toolbar": "드롭다운 툴바",
    "Edit block": "편집 영역",
    "Editor block content toolbar": "편집기 영역 내용 툴바",
    "Editor contextual toolbar": "편집기 문맥 툴바",
    "Editor editing area: %0": "편집기 편집 영역: %0",
    "Editor toolbar": "편집기 툴바",
    "Font Background Color": "글자 배경 색깔",
    "Font Color": "글자 색깔",
    "Font Family": "글꼴 집합",
    "Font Size": "글자 크기",
    Green: "초록색",
    Grey: "회색",
    HEX: "HEX",
    Huge: "매우 큰",
    "Insert paragraph after block": "블록 뒤에 단락 삽입",
    "Insert paragraph before block": "블록 앞에 단락 삽입",
    Italic: "기울임꼴",
    "Light blue": "연한 파랑색",
    "Light green": "연한 초록색",
    "Light grey": "밝은 회색",
    Next: "다음",
    "No results found": "결과 찾을 수 없음",
    "No searchable items": "검색 가능한 항목 없음",
    Orange: "주황색",
    "Press Enter to type after or press Shift + Enter to type before the widget":
      "엔터를 눌러서 위젯 뒤에 입력하거나 시프트 + 엔터를 눌러서 위젯 앞에 입력하세요",
    Previous: "이전",
    Purple: "보라색",
    Red: "빨간색",
    Redo: "다시 실행",
    "Remove color": "색깔 제거",
    "Rich Text Editor": "서식 있는 텍스트 편집기",
    "Select all": "전체 선택",
    "Show more items": "더보기",
    Small: "작은",
    Strikethrough: "취소선",
    Subscript: "아래 첨자",
    Superscript: "위 첨자",
    Tiny: "매우 작은",
    Turquoise: "청록색",
    Underline: "밑줄",
    Undo: "실행 취소",
    White: "흰색",
    "Widget toolbar": "위젯 툴바",
    Yellow: "노랑색",
  });
  e.getPluralForm = function (t) {
    return 0;
  };
})(window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {}));
/*!
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md.
 */ (function t(e, n) {
  if (typeof exports === "object" && typeof module === "object") module.exports = n();
  else if (typeof define === "function" && define.amd) define([], n);
  else if (typeof exports === "object") exports["ClassicEditor"] = n();
  else e["ClassicEditor"] = n();
})(self, () =>
  (() => {
    var t = {
      168: (t, e, n) => {
        const o = n(874);
        const i = {};
        for (const t of Object.keys(o)) {
          i[o[t]] = t;
        }
        const r = {
          rgb: { channels: 3, labels: "rgb" },
          hsl: { channels: 3, labels: "hsl" },
          hsv: { channels: 3, labels: "hsv" },
          hwb: { channels: 3, labels: "hwb" },
          cmyk: { channels: 4, labels: "cmyk" },
          xyz: { channels: 3, labels: "xyz" },
          lab: { channels: 3, labels: "lab" },
          lch: { channels: 3, labels: "lch" },
          hex: { channels: 1, labels: ["hex"] },
          keyword: { channels: 1, labels: ["keyword"] },
          ansi16: { channels: 1, labels: ["ansi16"] },
          ansi256: { channels: 1, labels: ["ansi256"] },
          hcg: { channels: 3, labels: ["h", "c", "g"] },
          apple: { channels: 3, labels: ["r16", "g16", "b16"] },
          gray: { channels: 1, labels: ["gray"] },
        };
        t.exports = r;
        for (const t of Object.keys(r)) {
          if (!("channels" in r[t])) {
            throw new Error("missing channels property: " + t);
          }
          if (!("labels" in r[t])) {
            throw new Error("missing channel labels property: " + t);
          }
          if (r[t].labels.length !== r[t].channels) {
            throw new Error("channel and label counts mismatch: " + t);
          }
          const { channels: e, labels: n } = r[t];
          delete r[t].channels;
          delete r[t].labels;
          Object.defineProperty(r[t], "channels", { value: e });
          Object.defineProperty(r[t], "labels", { value: n });
        }
        r.rgb.hsl = function (t) {
          const e = t[0] / 255;
          const n = t[1] / 255;
          const o = t[2] / 255;
          const i = Math.min(e, n, o);
          const r = Math.max(e, n, o);
          const s = r - i;
          let a;
          let c;
          if (r === i) {
            a = 0;
          } else if (e === r) {
            a = (n - o) / s;
          } else if (n === r) {
            a = 2 + (o - e) / s;
          } else if (o === r) {
            a = 4 + (e - n) / s;
          }
          a = Math.min(a * 60, 360);
          if (a < 0) {
            a += 360;
          }
          const l = (i + r) / 2;
          if (r === i) {
            c = 0;
          } else if (l <= 0.5) {
            c = s / (r + i);
          } else {
            c = s / (2 - r - i);
          }
          return [a, c * 100, l * 100];
        };
        r.rgb.hsv = function (t) {
          let e;
          let n;
          let o;
          let i;
          let r;
          const s = t[0] / 255;
          const a = t[1] / 255;
          const c = t[2] / 255;
          const l = Math.max(s, a, c);
          const d = l - Math.min(s, a, c);
          const h = function (t) {
            return (l - t) / 6 / d + 1 / 2;
          };
          if (d === 0) {
            i = 0;
            r = 0;
          } else {
            r = d / l;
            e = h(s);
            n = h(a);
            o = h(c);
            if (s === l) {
              i = o - n;
            } else if (a === l) {
              i = 1 / 3 + e - o;
            } else if (c === l) {
              i = 2 / 3 + n - e;
            }
            if (i < 0) {
              i += 1;
            } else if (i > 1) {
              i -= 1;
            }
          }
          return [i * 360, r * 100, l * 100];
        };
        r.rgb.hwb = function (t) {
          const e = t[0];
          const n = t[1];
          let o = t[2];
          const i = r.rgb.hsl(t)[0];
          const s = (1 / 255) * Math.min(e, Math.min(n, o));
          o = 1 - (1 / 255) * Math.max(e, Math.max(n, o));
          return [i, s * 100, o * 100];
        };
        r.rgb.cmyk = function (t) {
          const e = t[0] / 255;
          const n = t[1] / 255;
          const o = t[2] / 255;
          const i = Math.min(1 - e, 1 - n, 1 - o);
          const r = (1 - e - i) / (1 - i) || 0;
          const s = (1 - n - i) / (1 - i) || 0;
          const a = (1 - o - i) / (1 - i) || 0;
          return [r * 100, s * 100, a * 100, i * 100];
        };
        function s(t, e) {
          return (t[0] - e[0]) ** 2 + (t[1] - e[1]) ** 2 + (t[2] - e[2]) ** 2;
        }
        r.rgb.keyword = function (t) {
          const e = i[t];
          if (e) {
            return e;
          }
          let n = Infinity;
          let r;
          for (const e of Object.keys(o)) {
            const i = o[e];
            const a = s(t, i);
            if (a < n) {
              n = a;
              r = e;
            }
          }
          return r;
        };
        r.keyword.rgb = function (t) {
          return o[t];
        };
        r.rgb.xyz = function (t) {
          let e = t[0] / 255;
          let n = t[1] / 255;
          let o = t[2] / 255;
          e = e > 0.04045 ? ((e + 0.055) / 1.055) ** 2.4 : e / 12.92;
          n = n > 0.04045 ? ((n + 0.055) / 1.055) ** 2.4 : n / 12.92;
          o = o > 0.04045 ? ((o + 0.055) / 1.055) ** 2.4 : o / 12.92;
          const i = e * 0.4124 + n * 0.3576 + o * 0.1805;
          const r = e * 0.2126 + n * 0.7152 + o * 0.0722;
          const s = e * 0.0193 + n * 0.1192 + o * 0.9505;
          return [i * 100, r * 100, s * 100];
        };
        r.rgb.lab = function (t) {
          const e = r.rgb.xyz(t);
          let n = e[0];
          let o = e[1];
          let i = e[2];
          n /= 95.047;
          o /= 100;
          i /= 108.883;
          n = n > 0.008856 ? n ** (1 / 3) : 7.787 * n + 16 / 116;
          o = o > 0.008856 ? o ** (1 / 3) : 7.787 * o + 16 / 116;
          i = i > 0.008856 ? i ** (1 / 3) : 7.787 * i + 16 / 116;
          const s = 116 * o - 16;
          const a = 500 * (n - o);
          const c = 200 * (o - i);
          return [s, a, c];
        };
        r.hsl.rgb = function (t) {
          const e = t[0] / 360;
          const n = t[1] / 100;
          const o = t[2] / 100;
          let i;
          let r;
          let s;
          if (n === 0) {
            s = o * 255;
            return [s, s, s];
          }
          if (o < 0.5) {
            i = o * (1 + n);
          } else {
            i = o + n - o * n;
          }
          const a = 2 * o - i;
          const c = [0, 0, 0];
          for (let t = 0; t < 3; t++) {
            r = e + (1 / 3) * -(t - 1);
            if (r < 0) {
              r++;
            }
            if (r > 1) {
              r--;
            }
            if (6 * r < 1) {
              s = a + (i - a) * 6 * r;
            } else if (2 * r < 1) {
              s = i;
            } else if (3 * r < 2) {
              s = a + (i - a) * (2 / 3 - r) * 6;
            } else {
              s = a;
            }
            c[t] = s * 255;
          }
          return c;
        };
        r.hsl.hsv = function (t) {
          const e = t[0];
          let n = t[1] / 100;
          let o = t[2] / 100;
          let i = n;
          const r = Math.max(o, 0.01);
          o *= 2;
          n *= o <= 1 ? o : 2 - o;
          i *= r <= 1 ? r : 2 - r;
          const s = (o + n) / 2;
          const a = o === 0 ? (2 * i) / (r + i) : (2 * n) / (o + n);
          return [e, a * 100, s * 100];
        };
        r.hsv.rgb = function (t) {
          const e = t[0] / 60;
          const n = t[1] / 100;
          let o = t[2] / 100;
          const i = Math.floor(e) % 6;
          const r = e - Math.floor(e);
          const s = 255 * o * (1 - n);
          const a = 255 * o * (1 - n * r);
          const c = 255 * o * (1 - n * (1 - r));
          o *= 255;
          switch (i) {
            case 0:
              return [o, c, s];
            case 1:
              return [a, o, s];
            case 2:
              return [s, o, c];
            case 3:
              return [s, a, o];
            case 4:
              return [c, s, o];
            case 5:
              return [o, s, a];
          }
        };
        r.hsv.hsl = function (t) {
          const e = t[0];
          const n = t[1] / 100;
          const o = t[2] / 100;
          const i = Math.max(o, 0.01);
          let r;
          let s;
          s = (2 - n) * o;
          const a = (2 - n) * i;
          r = n * i;
          r /= a <= 1 ? a : 2 - a;
          r = r || 0;
          s /= 2;
          return [e, r * 100, s * 100];
        };
        r.hwb.rgb = function (t) {
          const e = t[0] / 360;
          let n = t[1] / 100;
          let o = t[2] / 100;
          const i = n + o;
          let r;
          if (i > 1) {
            n /= i;
            o /= i;
          }
          const s = Math.floor(6 * e);
          const a = 1 - o;
          r = 6 * e - s;
          if ((s & 1) !== 0) {
            r = 1 - r;
          }
          const c = n + r * (a - n);
          let l;
          let d;
          let h;
          switch (s) {
            default:
            case 6:
            case 0:
              l = a;
              d = c;
              h = n;
              break;
            case 1:
              l = c;
              d = a;
              h = n;
              break;
            case 2:
              l = n;
              d = a;
              h = c;
              break;
            case 3:
              l = n;
              d = c;
              h = a;
              break;
            case 4:
              l = c;
              d = n;
              h = a;
              break;
            case 5:
              l = a;
              d = n;
              h = c;
              break;
          }
          return [l * 255, d * 255, h * 255];
        };
        r.cmyk.rgb = function (t) {
          const e = t[0] / 100;
          const n = t[1] / 100;
          const o = t[2] / 100;
          const i = t[3] / 100;
          const r = 1 - Math.min(1, e * (1 - i) + i);
          const s = 1 - Math.min(1, n * (1 - i) + i);
          const a = 1 - Math.min(1, o * (1 - i) + i);
          return [r * 255, s * 255, a * 255];
        };
        r.xyz.rgb = function (t) {
          const e = t[0] / 100;
          const n = t[1] / 100;
          const o = t[2] / 100;
          let i;
          let r;
          let s;
          i = e * 3.2406 + n * -1.5372 + o * -0.4986;
          r = e * -0.9689 + n * 1.8758 + o * 0.0415;
          s = e * 0.0557 + n * -0.204 + o * 1.057;
          i = i > 0.0031308 ? 1.055 * i ** (1 / 2.4) - 0.055 : i * 12.92;
          r = r > 0.0031308 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
          s = s > 0.0031308 ? 1.055 * s ** (1 / 2.4) - 0.055 : s * 12.92;
          i = Math.min(Math.max(0, i), 1);
          r = Math.min(Math.max(0, r), 1);
          s = Math.min(Math.max(0, s), 1);
          return [i * 255, r * 255, s * 255];
        };
        r.xyz.lab = function (t) {
          let e = t[0];
          let n = t[1];
          let o = t[2];
          e /= 95.047;
          n /= 100;
          o /= 108.883;
          e = e > 0.008856 ? e ** (1 / 3) : 7.787 * e + 16 / 116;
          n = n > 0.008856 ? n ** (1 / 3) : 7.787 * n + 16 / 116;
          o = o > 0.008856 ? o ** (1 / 3) : 7.787 * o + 16 / 116;
          const i = 116 * n - 16;
          const r = 500 * (e - n);
          const s = 200 * (n - o);
          return [i, r, s];
        };
        r.lab.xyz = function (t) {
          const e = t[0];
          const n = t[1];
          const o = t[2];
          let i;
          let r;
          let s;
          r = (e + 16) / 116;
          i = n / 500 + r;
          s = r - o / 200;
          const a = r ** 3;
          const c = i ** 3;
          const l = s ** 3;
          r = a > 0.008856 ? a : (r - 16 / 116) / 7.787;
          i = c > 0.008856 ? c : (i - 16 / 116) / 7.787;
          s = l > 0.008856 ? l : (s - 16 / 116) / 7.787;
          i *= 95.047;
          r *= 100;
          s *= 108.883;
          return [i, r, s];
        };
        r.lab.lch = function (t) {
          const e = t[0];
          const n = t[1];
          const o = t[2];
          let i;
          const r = Math.atan2(o, n);
          i = (r * 360) / 2 / Math.PI;
          if (i < 0) {
            i += 360;
          }
          const s = Math.sqrt(n * n + o * o);
          return [e, s, i];
        };
        r.lch.lab = function (t) {
          const e = t[0];
          const n = t[1];
          const o = t[2];
          const i = (o / 360) * 2 * Math.PI;
          const r = n * Math.cos(i);
          const s = n * Math.sin(i);
          return [e, r, s];
        };
        r.rgb.ansi16 = function (t, e = null) {
          const [n, o, i] = t;
          let s = e === null ? r.rgb.hsv(t)[2] : e;
          s = Math.round(s / 50);
          if (s === 0) {
            return 30;
          }
          let a =
            30 + ((Math.round(i / 255) << 2) | (Math.round(o / 255) << 1) | Math.round(n / 255));
          if (s === 2) {
            a += 60;
          }
          return a;
        };
        r.hsv.ansi16 = function (t) {
          return r.rgb.ansi16(r.hsv.rgb(t), t[2]);
        };
        r.rgb.ansi256 = function (t) {
          const e = t[0];
          const n = t[1];
          const o = t[2];
          if (e === n && n === o) {
            if (e < 8) {
              return 16;
            }
            if (e > 248) {
              return 231;
            }
            return Math.round(((e - 8) / 247) * 24) + 232;
          }
          const i =
            16 +
            36 * Math.round((e / 255) * 5) +
            6 * Math.round((n / 255) * 5) +
            Math.round((o / 255) * 5);
          return i;
        };
        r.ansi16.rgb = function (t) {
          let e = t % 10;
          if (e === 0 || e === 7) {
            if (t > 50) {
              e += 3.5;
            }
            e = (e / 10.5) * 255;
            return [e, e, e];
          }
          const n = (~~(t > 50) + 1) * 0.5;
          const o = (e & 1) * n * 255;
          const i = ((e >> 1) & 1) * n * 255;
          const r = ((e >> 2) & 1) * n * 255;
          return [o, i, r];
        };
        r.ansi256.rgb = function (t) {
          if (t >= 232) {
            const e = (t - 232) * 10 + 8;
            return [e, e, e];
          }
          t -= 16;
          let e;
          const n = (Math.floor(t / 36) / 5) * 255;
          const o = (Math.floor((e = t % 36) / 6) / 5) * 255;
          const i = ((e % 6) / 5) * 255;
          return [n, o, i];
        };
        r.rgb.hex = function (t) {
          const e =
            ((Math.round(t[0]) & 255) << 16) +
            ((Math.round(t[1]) & 255) << 8) +
            (Math.round(t[2]) & 255);
          const n = e.toString(16).toUpperCase();
          return "000000".substring(n.length) + n;
        };
        r.hex.rgb = function (t) {
          const e = t.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
          if (!e) {
            return [0, 0, 0];
          }
          let n = e[0];
          if (e[0].length === 3) {
            n = n
              .split("")
              .map((t) => t + t)
              .join("");
          }
          const o = parseInt(n, 16);
          const i = (o >> 16) & 255;
          const r = (o >> 8) & 255;
          const s = o & 255;
          return [i, r, s];
        };
        r.rgb.hcg = function (t) {
          const e = t[0] / 255;
          const n = t[1] / 255;
          const o = t[2] / 255;
          const i = Math.max(Math.max(e, n), o);
          const r = Math.min(Math.min(e, n), o);
          const s = i - r;
          let a;
          let c;
          if (s < 1) {
            a = r / (1 - s);
          } else {
            a = 0;
          }
          if (s <= 0) {
            c = 0;
          } else if (i === e) {
            c = ((n - o) / s) % 6;
          } else if (i === n) {
            c = 2 + (o - e) / s;
          } else {
            c = 4 + (e - n) / s;
          }
          c /= 6;
          c %= 1;
          return [c * 360, s * 100, a * 100];
        };
        r.hsl.hcg = function (t) {
          const e = t[1] / 100;
          const n = t[2] / 100;
          const o = n < 0.5 ? 2 * e * n : 2 * e * (1 - n);
          let i = 0;
          if (o < 1) {
            i = (n - 0.5 * o) / (1 - o);
          }
          return [t[0], o * 100, i * 100];
        };
        r.hsv.hcg = function (t) {
          const e = t[1] / 100;
          const n = t[2] / 100;
          const o = e * n;
          let i = 0;
          if (o < 1) {
            i = (n - o) / (1 - o);
          }
          return [t[0], o * 100, i * 100];
        };
        r.hcg.rgb = function (t) {
          const e = t[0] / 360;
          const n = t[1] / 100;
          const o = t[2] / 100;
          if (n === 0) {
            return [o * 255, o * 255, o * 255];
          }
          const i = [0, 0, 0];
          const r = (e % 1) * 6;
          const s = r % 1;
          const a = 1 - s;
          let c = 0;
          switch (Math.floor(r)) {
            case 0:
              i[0] = 1;
              i[1] = s;
              i[2] = 0;
              break;
            case 1:
              i[0] = a;
              i[1] = 1;
              i[2] = 0;
              break;
            case 2:
              i[0] = 0;
              i[1] = 1;
              i[2] = s;
              break;
            case 3:
              i[0] = 0;
              i[1] = a;
              i[2] = 1;
              break;
            case 4:
              i[0] = s;
              i[1] = 0;
              i[2] = 1;
              break;
            default:
              i[0] = 1;
              i[1] = 0;
              i[2] = a;
          }
          c = (1 - n) * o;
          return [(n * i[0] + c) * 255, (n * i[1] + c) * 255, (n * i[2] + c) * 255];
        };
        r.hcg.hsv = function (t) {
          const e = t[1] / 100;
          const n = t[2] / 100;
          const o = e + n * (1 - e);
          let i = 0;
          if (o > 0) {
            i = e / o;
          }
          return [t[0], i * 100, o * 100];
        };
        r.hcg.hsl = function (t) {
          const e = t[1] / 100;
          const n = t[2] / 100;
          const o = n * (1 - e) + 0.5 * e;
          let i = 0;
          if (o > 0 && o < 0.5) {
            i = e / (2 * o);
          } else if (o >= 0.5 && o < 1) {
            i = e / (2 * (1 - o));
          }
          return [t[0], i * 100, o * 100];
        };
        r.hcg.hwb = function (t) {
          const e = t[1] / 100;
          const n = t[2] / 100;
          const o = e + n * (1 - e);
          return [t[0], (o - e) * 100, (1 - o) * 100];
        };
        r.hwb.hcg = function (t) {
          const e = t[1] / 100;
          const n = t[2] / 100;
          const o = 1 - n;
          const i = o - e;
          let r = 0;
          if (i < 1) {
            r = (o - i) / (1 - i);
          }
          return [t[0], i * 100, r * 100];
        };
        r.apple.rgb = function (t) {
          return [(t[0] / 65535) * 255, (t[1] / 65535) * 255, (t[2] / 65535) * 255];
        };
        r.rgb.apple = function (t) {
          return [(t[0] / 255) * 65535, (t[1] / 255) * 65535, (t[2] / 255) * 65535];
        };
        r.gray.rgb = function (t) {
          return [(t[0] / 100) * 255, (t[0] / 100) * 255, (t[0] / 100) * 255];
        };
        r.gray.hsl = function (t) {
          return [0, 0, t[0]];
        };
        r.gray.hsv = r.gray.hsl;
        r.gray.hwb = function (t) {
          return [0, 100, t[0]];
        };
        r.gray.cmyk = function (t) {
          return [0, 0, 0, t[0]];
        };
        r.gray.lab = function (t) {
          return [t[0], 0, 0];
        };
        r.gray.hex = function (t) {
          const e = Math.round((t[0] / 100) * 255) & 255;
          const n = (e << 16) + (e << 8) + e;
          const o = n.toString(16).toUpperCase();
          return "000000".substring(o.length) + o;
        };
        r.rgb.gray = function (t) {
          const e = (t[0] + t[1] + t[2]) / 3;
          return [(e / 255) * 100];
        };
      },
      85: (t, e, n) => {
        const o = n(168);
        const i = n(111);
        const r = {};
        const s = Object.keys(o);
        function a(t) {
          const e = function (...e) {
            const n = e[0];
            if (n === undefined || n === null) {
              return n;
            }
            if (n.length > 1) {
              e = n;
            }
            return t(e);
          };
          if ("conversion" in t) {
            e.conversion = t.conversion;
          }
          return e;
        }
        function c(t) {
          const e = function (...e) {
            const n = e[0];
            if (n === undefined || n === null) {
              return n;
            }
            if (n.length > 1) {
              e = n;
            }
            const o = t(e);
            if (typeof o === "object") {
              for (let t = o.length, e = 0; e < t; e++) {
                o[e] = Math.round(o[e]);
              }
            }
            return o;
          };
          if ("conversion" in t) {
            e.conversion = t.conversion;
          }
          return e;
        }
        s.forEach((t) => {
          r[t] = {};
          Object.defineProperty(r[t], "channels", { value: o[t].channels });
          Object.defineProperty(r[t], "labels", { value: o[t].labels });
          const e = i(t);
          const n = Object.keys(e);
          n.forEach((n) => {
            const o = e[n];
            r[t][n] = c(o);
            r[t][n].raw = a(o);
          });
        });
        t.exports = r;
      },
      111: (t, e, n) => {
        const o = n(168);
        function i() {
          const t = {};
          const e = Object.keys(o);
          for (let n = e.length, o = 0; o < n; o++) {
            t[e[o]] = { distance: -1, parent: null };
          }
          return t;
        }
        function r(t) {
          const e = i();
          const n = [t];
          e[t].distance = 0;
          while (n.length) {
            const t = n.pop();
            const i = Object.keys(o[t]);
            for (let o = i.length, r = 0; r < o; r++) {
              const o = i[r];
              const s = e[o];
              if (s.distance === -1) {
                s.distance = e[t].distance + 1;
                s.parent = t;
                n.unshift(o);
              }
            }
          }
          return e;
        }
        function s(t, e) {
          return function (n) {
            return e(t(n));
          };
        }
        function a(t, e) {
          const n = [e[t].parent, t];
          let i = o[e[t].parent][t];
          let r = e[t].parent;
          while (e[r].parent) {
            n.unshift(e[r].parent);
            i = s(o[e[r].parent][r], i);
            r = e[r].parent;
          }
          i.conversion = n;
          return i;
        }
        t.exports = function (t) {
          const e = r(t);
          const n = {};
          const o = Object.keys(e);
          for (let t = o.length, i = 0; i < t; i++) {
            const t = o[i];
            const r = e[t];
            if (r.parent === null) {
              continue;
            }
            n[t] = a(t, e);
          }
          return n;
        };
      },
      874: (t) => {
        "use strict";
        t.exports = {
          aliceblue: [240, 248, 255],
          antiquewhite: [250, 235, 215],
          aqua: [0, 255, 255],
          aquamarine: [127, 255, 212],
          azure: [240, 255, 255],
          beige: [245, 245, 220],
          bisque: [255, 228, 196],
          black: [0, 0, 0],
          blanchedalmond: [255, 235, 205],
          blue: [0, 0, 255],
          blueviolet: [138, 43, 226],
          brown: [165, 42, 42],
          burlywood: [222, 184, 135],
          cadetblue: [95, 158, 160],
          chartreuse: [127, 255, 0],
          chocolate: [210, 105, 30],
          coral: [255, 127, 80],
          cornflowerblue: [100, 149, 237],
          cornsilk: [255, 248, 220],
          crimson: [220, 20, 60],
          cyan: [0, 255, 255],
          darkblue: [0, 0, 139],
          darkcyan: [0, 139, 139],
          darkgoldenrod: [184, 134, 11],
          darkgray: [169, 169, 169],
          darkgreen: [0, 100, 0],
          darkgrey: [169, 169, 169],
          darkkhaki: [189, 183, 107],
          darkmagenta: [139, 0, 139],
          darkolivegreen: [85, 107, 47],
          darkorange: [255, 140, 0],
          darkorchid: [153, 50, 204],
          darkred: [139, 0, 0],
          darksalmon: [233, 150, 122],
          darkseagreen: [143, 188, 143],
          darkslateblue: [72, 61, 139],
          darkslategray: [47, 79, 79],
          darkslategrey: [47, 79, 79],
          darkturquoise: [0, 206, 209],
          darkviolet: [148, 0, 211],
          deeppink: [255, 20, 147],
          deepskyblue: [0, 191, 255],
          dimgray: [105, 105, 105],
          dimgrey: [105, 105, 105],
          dodgerblue: [30, 144, 255],
          firebrick: [178, 34, 34],
          floralwhite: [255, 250, 240],
          forestgreen: [34, 139, 34],
          fuchsia: [255, 0, 255],
          gainsboro: [220, 220, 220],
          ghostwhite: [248, 248, 255],
          gold: [255, 215, 0],
          goldenrod: [218, 165, 32],
          gray: [128, 128, 128],
          green: [0, 128, 0],
          greenyellow: [173, 255, 47],
          grey: [128, 128, 128],
          honeydew: [240, 255, 240],
          hotpink: [255, 105, 180],
          indianred: [205, 92, 92],
          indigo: [75, 0, 130],
          ivory: [255, 255, 240],
          khaki: [240, 230, 140],
          lavender: [230, 230, 250],
          lavenderblush: [255, 240, 245],
          lawngreen: [124, 252, 0],
          lemonchiffon: [255, 250, 205],
          lightblue: [173, 216, 230],
          lightcoral: [240, 128, 128],
          lightcyan: [224, 255, 255],
          lightgoldenrodyellow: [250, 250, 210],
          lightgray: [211, 211, 211],
          lightgreen: [144, 238, 144],
          lightgrey: [211, 211, 211],
          lightpink: [255, 182, 193],
          lightsalmon: [255, 160, 122],
          lightseagreen: [32, 178, 170],
          lightskyblue: [135, 206, 250],
          lightslategray: [119, 136, 153],
          lightslategrey: [119, 136, 153],
          lightsteelblue: [176, 196, 222],
          lightyellow: [255, 255, 224],
          lime: [0, 255, 0],
          limegreen: [50, 205, 50],
          linen: [250, 240, 230],
          magenta: [255, 0, 255],
          maroon: [128, 0, 0],
          mediumaquamarine: [102, 205, 170],
          mediumblue: [0, 0, 205],
          mediumorchid: [186, 85, 211],
          mediumpurple: [147, 112, 219],
          mediumseagreen: [60, 179, 113],
          mediumslateblue: [123, 104, 238],
          mediumspringgreen: [0, 250, 154],
          mediumturquoise: [72, 209, 204],
          mediumvioletred: [199, 21, 133],
          midnightblue: [25, 25, 112],
          mintcream: [245, 255, 250],
          mistyrose: [255, 228, 225],
          moccasin: [255, 228, 181],
          navajowhite: [255, 222, 173],
          navy: [0, 0, 128],
          oldlace: [253, 245, 230],
          olive: [128, 128, 0],
          olivedrab: [107, 142, 35],
          orange: [255, 165, 0],
          orangered: [255, 69, 0],
          orchid: [218, 112, 214],
          palegoldenrod: [238, 232, 170],
          palegreen: [152, 251, 152],
          paleturquoise: [175, 238, 238],
          palevioletred: [219, 112, 147],
          papayawhip: [255, 239, 213],
          peachpuff: [255, 218, 185],
          peru: [205, 133, 63],
          pink: [255, 192, 203],
          plum: [221, 160, 221],
          powderblue: [176, 224, 230],
          purple: [128, 0, 128],
          rebeccapurple: [102, 51, 153],
          red: [255, 0, 0],
          rosybrown: [188, 143, 143],
          royalblue: [65, 105, 225],
          saddlebrown: [139, 69, 19],
          salmon: [250, 128, 114],
          sandybrown: [244, 164, 96],
          seagreen: [46, 139, 87],
          seashell: [255, 245, 238],
          sienna: [160, 82, 45],
          silver: [192, 192, 192],
          skyblue: [135, 206, 235],
          slateblue: [106, 90, 205],
          slategray: [112, 128, 144],
          slategrey: [112, 128, 144],
          snow: [255, 250, 250],
          springgreen: [0, 255, 127],
          steelblue: [70, 130, 180],
          tan: [210, 180, 140],
          teal: [0, 128, 128],
          thistle: [216, 191, 216],
          tomato: [255, 99, 71],
          turquoise: [64, 224, 208],
          violet: [238, 130, 238],
          wheat: [245, 222, 179],
          white: [255, 255, 255],
          whitesmoke: [245, 245, 245],
          yellow: [255, 255, 0],
          yellowgreen: [154, 205, 50],
        };
      },
      363: (t, e, n) => {
        "use strict";
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ".ck-content code{background-color:hsla(0,0%,78%,.3);border-radius:2px;padding:.15em}.ck.ck-editor__editable .ck-code_selected{background-color:hsla(0,0%,78%,.5)}",
          "",
          {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-basic-styles/theme/code.css"],
            names: [],
            mappings: "AAKA,iBACC,kCAAuC,CAEvC,iBAAkB,CADlB,aAED,CAEA,0CACC,kCACD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content code {\n\tbackground-color: hsla(0, 0%, 78%, 0.3);\n\tpadding: .15em;\n\tborder-radius: 2px;\n}\n\n.ck.ck-editor__editable .ck-code_selected  {\n\tbackground-color: hsla(0, 0%, 78%, 0.5);\n}\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      799: (t, e, n) => {
        "use strict";
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          '.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position{display:inline;pointer-events:none;position:relative}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{position:absolute;width:0}.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__selection-handle,.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__type-around{display:none}.ck.ck-clipboard-drop-target-line{pointer-events:none;position:absolute}:root{--ck-clipboard-drop-target-dot-width:12px;--ck-clipboard-drop-target-dot-height:8px;--ck-clipboard-drop-target-color:var(--ck-color-focus-border)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{background:var(--ck-clipboard-drop-target-color);border:1px solid var(--ck-clipboard-drop-target-color);bottom:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);margin-left:-1px;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span:after{border-color:var(--ck-clipboard-drop-target-color) transparent transparent transparent;border-style:solid;border-width:calc(var(--ck-clipboard-drop-target-dot-height)) calc(var(--ck-clipboard-drop-target-dot-width)*.5) 0 calc(var(--ck-clipboard-drop-target-dot-width)*.5);content:"";display:block;height:0;left:50%;position:absolute;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);transform:translateX(-50%);width:0}.ck.ck-editor__editable .ck-widget.ck-clipboard-drop-target-range{outline:var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color)!important}.ck.ck-editor__editable .ck-widget:-webkit-drag{zoom:.6;outline:none!important}.ck.ck-clipboard-drop-target-line{background:var(--ck-clipboard-drop-target-color);border:1px solid var(--ck-clipboard-drop-target-color);height:0;margin-top:-1px}.ck.ck-clipboard-drop-target-line:before{border-style:solid;content:"";height:0;position:absolute;top:calc(var(--ck-clipboard-drop-target-dot-width)*-.5);width:0}[dir=ltr] .ck.ck-clipboard-drop-target-line:before{border-color:transparent transparent transparent var(--ck-clipboard-drop-target-color);border-width:calc(var(--ck-clipboard-drop-target-dot-width)*.5) 0 calc(var(--ck-clipboard-drop-target-dot-width)*.5) var(--ck-clipboard-drop-target-dot-height);left:-1px}[dir=rtl] .ck.ck-clipboard-drop-target-line:before{border-color:transparent var(--ck-clipboard-drop-target-color) transparent transparent;border-width:calc(var(--ck-clipboard-drop-target-dot-width)*.5) var(--ck-clipboard-drop-target-dot-height) calc(var(--ck-clipboard-drop-target-dot-width)*.5) 0;right:-1px}',
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-clipboard/theme/clipboard.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-clipboard/clipboard.css",
            ],
            names: [],
            mappings:
              "AASC,8DACC,cAAe,CAEf,mBAAoB,CADpB,iBAOD,CAJC,mEACC,iBAAkB,CAClB,OACD,CAWA,qJACC,YACD,CAIF,kCAEC,mBAAoB,CADpB,iBAED,CC9BA,MACC,yCAA0C,CAC1C,yCAA0C,CAC1C,6DACD,CAOE,mEAIC,gDAAiD,CADjD,sDAAuD,CAFvD,2DAA8D,CAI9D,gBAAiB,CAHjB,wDAqBD,CAfC,yEAWC,sFAAuF,CAEvF,kBAAmB,CADnB,qKAA0K,CAX1K,UAAW,CAIX,aAAc,CAFd,QAAS,CAIT,QAAS,CADT,iBAAkB,CAElB,wDAA2D,CAE3D,0BAA2B,CAR3B,OAYD,CAOF,kEACC,gGACD,CAKA,gDACC,OAAS,CACT,sBACD,CAGD,kCAGC,gDAAiD,CADjD,sDAAuD,CADvD,QAAS,CAGT,eAwBD,CAtBC,yCAMC,kBAAmB,CALnB,UAAW,CAIX,QAAS,CAHT,iBAAkB,CAClB,uDAA0D,CAC1D,OAiBD,CArBA,mDAYE,sFAAuF,CADvF,+JAAoK,CAFpK,SAYF,CArBA,mDAmBE,sFAAuF,CADvF,+JAAmK,CAFnK,UAKF",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n\t/*\n\t * Vertical drop target (in text).\n\t */\n\t& .ck.ck-clipboard-drop-target-position {\n\t\tdisplay: inline;\n\t\tposition: relative;\n\t\tpointer-events: none;\n\n\t\t& span {\n\t\t\tposition: absolute;\n\t\t\twidth: 0;\n\t\t}\n\t}\n\n\t/*\n\t * Styles of the widget being dragged (its preview).\n\t */\n\t& .ck-widget:-webkit-drag {\n\t\t& > .ck-widget__selection-handle {\n\t\t\tdisplay: none;\n\t\t}\n\n\t\t& > .ck-widget__type-around {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n\n.ck.ck-clipboard-drop-target-line {\n\tposition: absolute;\n\tpointer-events: none;\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import \"@ckeditor/ckeditor5-ui/theme/mixins/_dir.css\";\n\n:root {\n\t--ck-clipboard-drop-target-dot-width: 12px;\n\t--ck-clipboard-drop-target-dot-height: 8px;\n\t--ck-clipboard-drop-target-color: var(--ck-color-focus-border);\n}\n\n.ck.ck-editor__editable {\n\t/*\n\t * Vertical drop target (in text).\n\t */\n\t& .ck.ck-clipboard-drop-target-position {\n\t\t& span {\n\t\t\tbottom: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));\n\t\t\ttop: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));\n\t\t\tborder: 1px solid var(--ck-clipboard-drop-target-color);\n\t\t\tbackground: var(--ck-clipboard-drop-target-color);\n\t\t\tmargin-left: -1px;\n\n\t\t\t/* The triangle above the marker */\n\t\t\t&::after {\n\t\t\t\tcontent: '';\n\t\t\t\twidth: 0;\n\t\t\t\theight: 0;\n\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tleft: 50%;\n\t\t\t\ttop: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));\n\n\t\t\t\ttransform: translateX(-50%);\n\t\t\t\tborder-color: var(--ck-clipboard-drop-target-color) transparent transparent transparent;\n\t\t\t\tborder-width: calc(var(--ck-clipboard-drop-target-dot-height)) calc(.5 * var(--ck-clipboard-drop-target-dot-width)) 0 calc(.5 * var(--ck-clipboard-drop-target-dot-width));\n\t\t\t\tborder-style: solid;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Styles of the widget that it a drop target.\n\t */\n\t& .ck-widget.ck-clipboard-drop-target-range {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color) !important;\n\t}\n\n\t/*\n\t * Styles of the widget being dragged (its preview).\n\t */\n\t& .ck-widget:-webkit-drag {\n\t\tzoom: 0.6;\n\t\toutline: none !important;\n\t}\n}\n\n.ck.ck-clipboard-drop-target-line {\n\theight: 0;\n\tborder: 1px solid var(--ck-clipboard-drop-target-color);\n\tbackground: var(--ck-clipboard-drop-target-color);\n\tmargin-top: -1px;\n\n\t&::before {\n\t\tcontent: '';\n\t\tposition: absolute;\n\t\ttop: calc(-.5 * var(--ck-clipboard-drop-target-dot-width));\n\t\twidth: 0;\n\t\theight: 0;\n\t\tborder-style: solid;\n\n\t\t@mixin ck-dir ltr {\n\t\t\tleft: -1px;\n\n\t\t\tborder-width: calc(.5 * var(--ck-clipboard-drop-target-dot-width)) 0 calc(.5 * var(--ck-clipboard-drop-target-dot-width)) var(--ck-clipboard-drop-target-dot-height);\n\t\t\tborder-color: transparent transparent transparent var(--ck-clipboard-drop-target-color);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tright: -1px;\n\n\t\t\tborder-width:calc(.5 * var(--ck-clipboard-drop-target-dot-width)) var(--ck-clipboard-drop-target-dot-height) calc(.5 * var(--ck-clipboard-drop-target-dot-width)) 0;\n\t\t\tborder-color: transparent var(--ck-clipboard-drop-target-color) transparent transparent;\n\t\t}\n\t}\n}\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      624: (t, e, n) => {
        "use strict";
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ".ck.ck-editor{position:relative}.ck.ck-editor .ck-editor__top .ck-sticky-panel .ck-toolbar{z-index:var(--ck-z-modal)}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-bottom-width:0}.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar{border-bottom-width:1px;border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:0}.ck.ck-editor__main>.ck-editor__editable{background:var(--ck-color-base-background);border-radius:0}.ck-rounded-corners .ck.ck-editor__main>.ck-editor__editable,.ck.ck-editor__main>.ck-editor__editable.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}.ck.ck-editor__main>.ck-editor__editable:not(.ck-focused){border-color:var(--ck-color-base-border)}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-editor-classic/theme/classiceditor.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-editor-classic/classiceditor.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
            ],
            names: [],
            mappings:
              "AAKA,cAIC,iBAMD,CAJC,2DAEC,yBACD,CCLC,gDCED,eDKC,CAPA,uICMA,qCAAsC,CDJpC,2BAA4B,CAC5B,4BAIF,CAPA,gDAMC,qBACD,CAEA,iFACC,uBAAwB,CCR1B,eDaC,CANA,yMCHA,qCAAsC,CDOpC,eAEF,CAKF,yCAEC,0CAA2C,CCpB3C,eD8BD,CAZA,yHCdE,qCAAsC,CDmBtC,wBAAyB,CACzB,yBAMF,CAHC,0DACC,wCACD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor {\n\t/* All the elements within `.ck-editor` are positioned relatively to it.\n\t If any element needs to be positioned with respect to the <body>, etc.,\n\t it must land outside of the `.ck-editor` in DOM. */\n\tposition: relative;\n\n\t& .ck-editor__top .ck-sticky-panel .ck-toolbar {\n\t\t/* https://github.com/ckeditor/ckeditor5-editor-classic/issues/62 */\n\t\tz-index: var(--ck-z-modal);\n\t}\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_rounded.css";\n\n.ck.ck-editor__top {\n\t& .ck-sticky-panel {\n\t\t& .ck-toolbar {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\n\t\t\tborder-bottom-width: 0;\n\t\t}\n\n\t\t& .ck-sticky-panel__content_sticky .ck-toolbar {\n\t\t\tborder-bottom-width: 1px;\n\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* Note: Use ck-editor__main to make sure these styles don\'t apply to other editor types */\n.ck.ck-editor__main > .ck-editor__editable {\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/113 */\n\tbackground: var(--ck-color-base-background);\n\n\t@mixin ck-rounded-corners {\n\t\tborder-top-left-radius: 0;\n\t\tborder-top-right-radius: 0;\n\t}\n\n\t&:not(.ck-focused) {\n\t\tborder-color: var(--ck-color-base-border);\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      372: (t, e, n) => {
        "use strict";
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ".ck .ck-placeholder,.ck.ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{content:attr(data-placeholder);left:0;pointer-events:none;position:absolute;right:0}.ck.ck-read-only .ck-placeholder:before{display:none}.ck.ck-reset_all .ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{color:var(--ck-color-engine-placeholder-text);cursor:text}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-engine/theme/placeholder.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-engine/placeholder.css",
            ],
            names: [],
            mappings:
              "AAMA,uCAEC,iBAWD,CATC,qDAIC,8BAA+B,CAF/B,MAAO,CAKP,mBAAoB,CANpB,iBAAkB,CAElB,OAKD,CAKA,wCACC,YACD,CAQD,iCACC,iBACD,CC5BC,qDAEC,6CAA8C,CAD9C,WAED",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder,\n.ck .ck-placeholder {\n\tposition: relative;\n\n\t&::before {\n\t\tposition: absolute;\n\t\tleft: 0;\n\t\tright: 0;\n\t\tcontent: attr(data-placeholder);\n\n\t\t/* See ckeditor/ckeditor5#469. */\n\t\tpointer-events: none;\n\t}\n}\n\n/* See ckeditor/ckeditor5#1987. */\n.ck.ck-read-only .ck-placeholder {\n\t&::before {\n\t\tdisplay: none;\n\t}\n}\n\n/*\n * Rules for the `ck-placeholder` are loaded before the rules for `ck-reset_all` in the base CKEditor 5 DLL build.\n * This fix overwrites the incorrectly set `position: static` from `ck-reset_all`.\n * See https://github.com/ckeditor/ckeditor5/issues/11418.\n */\n.ck.ck-reset_all .ck-placeholder {\n\tposition: relative;\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder, .ck .ck-placeholder {\n\t&::before {\n\t\tcursor: text;\n\t\tcolor: var(--ck-color-engine-placeholder-text);\n\t}\n}\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      37: (t, e, n) => {
        "use strict";
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ".ck.ck-editor__editable span[data-ck-unsafe-element]{display:none}",
          "",
          {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-engine/theme/renderer.css"],
            names: [],
            mappings: "AAMA,qDACC,YACD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Elements marked by the Renderer as hidden should be invisible in the editor. */\n.ck.ck-editor__editable span[data-ck-unsafe-element] {\n\tdisplay: none;\n}\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      991: (t, e, n) => {
        "use strict";
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ".ck-content .text-tiny{font-size:.7em}.ck-content .text-small{font-size:.85em}.ck-content .text-big{font-size:1.4em}.ck-content .text-huge{font-size:1.8em}",
          "",
          {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-font/theme/fontsize.css"],
            names: [],
            mappings: "AAUC,uBACC,cACD,CAEA,wBACC,eACD,CAEA,sBACC,eACD,CAEA,uBACC,eACD",
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* The values should be synchronized with the "FONT_SIZE_PRESET_UNITS" object in the "/src/fontsize/utils.js" file. */\n\n/* Styles should be prefixed with the `.ck-content` class.\nSee https://github.com/ckeditor/ckeditor5/issues/6636 */\n.ck-content {\n\t& .text-tiny {\n\t\tfont-size: .7em;\n\t}\n\n\t& .text-small {\n\t\tfont-size: .85em;\n\t}\n\n\t& .text-big {\n\t\tfont-size: 1.4em;\n\t}\n\n\t& .text-huge {\n\t\tfont-size: 1.8em;\n\t}\n}\n',
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      29: (t, e, n) => {
        "use strict";
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ".ck.ck-autocomplete{position:relative}.ck.ck-autocomplete>.ck-search__results{position:absolute;z-index:var(--ck-z-modal)}.ck.ck-autocomplete>.ck-search__results.ck-search__results_n{bottom:100%}.ck.ck-autocomplete>.ck-search__results.ck-search__results_s{bottom:auto;top:100%}.ck.ck-autocomplete>.ck-search__results{border-radius:0}.ck-rounded-corners .ck.ck-autocomplete>.ck-search__results,.ck.ck-autocomplete>.ck-search__results.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-autocomplete>.ck-search__results{background:var(--ck-color-base-background);border:1px solid var(--ck-color-dropdown-panel-border);box-shadow:var(--ck-drop-shadow),0 0;max-height:200px;min-width:auto;overflow-y:auto}.ck.ck-autocomplete>.ck-search__results.ck-search__results_n{border-bottom-left-radius:0;border-bottom-right-radius:0;margin-bottom:-1px}.ck.ck-autocomplete>.ck-search__results.ck-search__results_s{border-top-left-radius:0;border-top-right-radius:0;margin-top:-1px}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/autocomplete/autocomplete.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/autocomplete/autocomplete.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
            ],
            names: [],
            mappings:
              "AAKA,oBACC,iBAeD,CAbC,wCACC,iBAAkB,CAClB,yBAUD,CARC,6DACC,WACD,CAEA,6DAEC,WAAY,CADZ,QAED,CCVD,wCCEA,eDuBA,CAzBA,uHCMC,qCDmBD,CAzBA,wCAMC,0CAA2C,CAC3C,sDAAuD,CEPxD,oCAA8B,CFI7B,gBAAiB,CAIjB,cAAe,CAHf,eAoBD,CAfC,6DACC,2BAA4B,CAC5B,4BAA6B,CAG7B,kBACD,CAEA,6DACC,wBAAyB,CACzB,yBAA0B,CAG1B,eACD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-autocomplete {\n\tposition: relative;\n\n\t& > .ck-search__results {\n\t\tposition: absolute;\n\t\tz-index: var(--ck-z-modal);\n\n\t\t&.ck-search__results_n {\n\t\t\tbottom: 100%;\n\t\t}\n\n\t\t&.ck-search__results_s {\n\t\t\ttop: 100%;\n\t\t\tbottom: auto;\n\t\t}\n\t}\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css";\n@import "@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css";\n\n.ck.ck-autocomplete {\n\t& > .ck-search__results {\n\t\t@mixin ck-rounded-corners;\n\t\t@mixin ck-drop-shadow;\n\n\t\tmax-height: 200px;\n\t\toverflow-y: auto;\n\t\tbackground: var(--ck-color-base-background);\n\t\tborder: 1px solid var(--ck-color-dropdown-panel-border);\n\t\tmin-width: auto;\n\n\t\t&.ck-search__results_n {\n\t\t\tborder-bottom-left-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\n\t\t\t/* Prevent duplicated borders between the input and the results pane. */\n\t\t\tmargin-bottom: -1px;\n\t\t}\n\n\t\t&.ck-search__results_s {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-top-right-radius: 0;\n\n\t\t\t/* Prevent duplicated borders between the input and the results pane. */\n\t\t\tmargin-top: -1px;\n\t\t}\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      971: (t, e, n) => {
        "use strict";
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ".ck.ck-button,a.ck.ck-button{align-items:center;display:inline-flex;justify-content:left;position:relative;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{display:none}.ck.ck-button.ck-button_with-text .ck-button__label,a.ck.ck-button.ck-button_with-text .ck-button__label{display:inline-block}.ck.ck-button:not(.ck-button_with-text),a.ck.ck-button:not(.ck-button_with-text){justify-content:center}.ck.ck-button,a.ck.ck-button{background:var(--ck-color-button-default-background)}.ck.ck-button:not(.ck-disabled):hover,a.ck.ck-button:not(.ck-disabled):hover{background:var(--ck-color-button-default-hover-background)}.ck.ck-button:not(.ck-disabled):active,a.ck.ck-button:not(.ck-disabled):active{background:var(--ck-color-button-default-active-background)}.ck.ck-button.ck-disabled,a.ck.ck-button.ck-disabled{background:var(--ck-color-button-default-disabled-background)}.ck.ck-button,a.ck.ck-button{border-radius:0}.ck-rounded-corners .ck.ck-button,.ck-rounded-corners a.ck.ck-button,.ck.ck-button.ck-rounded-corners,a.ck.ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-button,a.ck.ck-button{-webkit-appearance:none;border:1px solid transparent;cursor:default;font-size:inherit;line-height:1;min-height:var(--ck-ui-component-min-height);min-width:var(--ck-ui-component-min-height);padding:var(--ck-spacing-tiny);text-align:center;transition:box-shadow .2s ease-in-out,border .2s ease-in-out;vertical-align:middle;white-space:nowrap}.ck.ck-button:active,.ck.ck-button:focus,a.ck.ck-button:active,a.ck.ck-button:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-button .ck-button__icon use,.ck.ck-button .ck-button__icon use *,a.ck.ck-button .ck-button__icon use,a.ck.ck-button .ck-button__icon use *{color:inherit}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{color:inherit;cursor:inherit;font-size:inherit;font-weight:inherit;vertical-align:middle}[dir=ltr] .ck.ck-button .ck-button__label,[dir=ltr] a.ck.ck-button .ck-button__label{text-align:left}[dir=rtl] .ck.ck-button .ck-button__label,[dir=rtl] a.ck.ck-button .ck-button__label{text-align:right}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{color:inherit}[dir=ltr] .ck.ck-button .ck-button__keystroke,[dir=ltr] a.ck.ck-button .ck-button__keystroke{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-button .ck-button__keystroke,[dir=rtl] a.ck.ck-button .ck-button__keystroke{margin-right:var(--ck-spacing-large)}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{font-weight:700;opacity:.7}.ck.ck-button.ck-disabled:active,.ck.ck-button.ck-disabled:focus,a.ck.ck-button.ck-disabled:active,a.ck.ck-button.ck-disabled:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-button.ck-disabled .ck-button__icon,.ck.ck-button.ck-disabled .ck-button__label,a.ck.ck-button.ck-disabled .ck-button__icon,a.ck.ck-button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__keystroke,a.ck.ck-button.ck-disabled .ck-button__keystroke{opacity:.3}.ck.ck-button.ck-button_with-text,a.ck.ck-button.ck-button_with-text{padding:var(--ck-spacing-tiny) var(--ck-spacing-standard)}[dir=ltr] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=ltr] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:calc(var(--ck-spacing-small)*-1);margin-right:var(--ck-spacing-small)}[dir=rtl] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=rtl] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:var(--ck-spacing-small);margin-right:calc(var(--ck-spacing-small)*-1)}.ck.ck-button.ck-button_with-keystroke .ck-button__label,a.ck.ck-button.ck-button_with-keystroke .ck-button__label{flex-grow:1}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{background:var(--ck-color-button-on-background)}.ck.ck-button.ck-on:not(.ck-disabled):hover,a.ck.ck-button.ck-on:not(.ck-disabled):hover{background:var(--ck-color-button-on-hover-background)}.ck.ck-button.ck-on:not(.ck-disabled):active,a.ck.ck-button.ck-on:not(.ck-disabled):active{background:var(--ck-color-button-on-active-background)}.ck.ck-button.ck-on.ck-disabled,a.ck.ck-button.ck-on.ck-disabled{background:var(--ck-color-button-on-disabled-background)}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{color:var(--ck-color-button-on-color)}.ck.ck-button.ck-button-save,a.ck.ck-button.ck-button-save{color:var(--ck-color-button-save)}.ck.ck-button.ck-button-cancel,a.ck.ck-button.ck-button-cancel{color:var(--ck-color-button-cancel)}.ck.ck-button-action,a.ck.ck-button-action{background:var(--ck-color-button-action-background)}.ck.ck-button-action:not(.ck-disabled):hover,a.ck.ck-button-action:not(.ck-disabled):hover{background:var(--ck-color-button-action-hover-background)}.ck.ck-button-action:not(.ck-disabled):active,a.ck.ck-button-action:not(.ck-disabled):active{background:var(--ck-color-button-action-active-background)}.ck.ck-button-action.ck-disabled,a.ck.ck-button-action.ck-disabled{background:var(--ck-color-button-action-disabled-background)}.ck.ck-button-action,a.ck.ck-button-action{color:var(--ck-color-button-action-text)}.ck.ck-button-bold,a.ck.ck-button-bold{font-weight:700}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/button/button.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/button.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/mixins/_button.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css",
            ],
            names: [],
            mappings:
              "AAOA,6BAMC,kBAAmB,CADnB,mBAAoB,CAEpB,oBAAqB,CAHrB,iBAAkB,CCFlB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBDkBD,CAdC,iEACC,YACD,CAGC,yGACC,oBACD,CAID,iFACC,sBACD,CEjBD,6BCAC,oDD4ID,CCzIE,6EACC,0DACD,CAEA,+EACC,2DACD,CAID,qDACC,6DACD,CDfD,6BEDC,eF6ID,CA5IA,wIEGE,qCFyIF,CA5IA,6BA6BC,uBAAwB,CANxB,4BAA6B,CAjB7B,cAAe,CAcf,iBAAkB,CAHlB,aAAc,CAJd,4CAA6C,CAD7C,2CAA4C,CAJ5C,8BAA+B,CAC/B,iBAAkB,CAiBlB,4DAA8D,CAnB9D,qBAAsB,CAFtB,kBAuID,CA7GC,oFGhCA,2BAA2B,CCF3B,2CAA8B,CDC9B,YHqCA,CAIC,kJAEC,aACD,CAGD,iEAIC,aAAc,CACd,cAAe,CAHf,iBAAkB,CAClB,mBAAoB,CAMpB,qBASD,CAlBA,qFAYE,eAMF,CAlBA,qFAgBE,gBAEF,CAEA,yEACC,aAYD,CAbA,6FAIE,mCASF,CAbA,6FAQE,oCAKF,CAbA,yEAWC,eAAiB,CACjB,UACD,CAIC,oIIrFD,oDJyFC,CAOA,gLKhGD,kCLkGC,CAEA,iGACC,UACD,CAGD,qEACC,yDAcD,CAXC,2HAEE,4CAA+C,CAC/C,oCAOF,CAVA,2HAQE,mCAAoC,CADpC,6CAGF,CAKA,mHACC,WACD,CAID,yCC/HA,+CDmIA,CChIC,yFACC,qDACD,CAEA,2FACC,sDACD,CAID,iEACC,wDACD,CDgHA,yCAGC,qCACD,CAEA,2DACC,iCACD,CAEA,+DACC,mCACD,CAID,2CC/IC,mDDoJD,CCjJE,2FACC,yDACD,CAEA,6FACC,0DACD,CAID,mEACC,4DACD,CDgID,2CAIC,wCACD,CAEA,uCAEC,eACD",
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-button,\na.ck.ck-button {\n\t@mixin ck-unselectable;\n\n\tposition: relative;\n\tdisplay: inline-flex;\n\talign-items: center;\n\tjustify-content: left;\n\n\t& .ck-button__label {\n\t\tdisplay: none;\n\t}\n\n\t&.ck-button_with-text {\n\t\t& .ck-button__label {\n\t\t\tdisplay: inline-block;\n\t\t}\n\t}\n\n\t/* Center the icon horizontally in a button without text. */\n\t&:not(.ck-button_with-text)  {\n\t\tjustify-content: center;\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_focus.css";\n@import "../../../mixins/_shadow.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_rounded.css";\n@import "../../mixins/_button.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-button,\na.ck.ck-button {\n\t@mixin ck-button-colors --ck-color-button-default;\n\t@mixin ck-rounded-corners;\n\n\twhite-space: nowrap;\n\tcursor: default;\n\tvertical-align: middle;\n\tpadding: var(--ck-spacing-tiny);\n\ttext-align: center;\n\n\t/* A very important piece of styling. Go to variable declaration to learn more. */\n\tmin-width: var(--ck-ui-component-min-height);\n\tmin-height: var(--ck-ui-component-min-height);\n\n\t/* Normalize the height of the line. Removing this will break consistent height\n\tamong text and text-less buttons (with icons). */\n\tline-height: 1;\n\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t/* Avoid flickering when the foucs border shows up. */\n\tborder: 1px solid transparent;\n\n\t/* Apply some smooth transition to the box-shadow and border. */\n\ttransition: box-shadow .2s ease-in-out, border .2s ease-in-out;\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/189 */\n\t-webkit-appearance: none;\n\n\t&:active,\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t}\n\n\t/* Allow icon coloring using the text "color" property. */\n\t& .ck-button__icon {\n\t\t& use,\n\t\t& use * {\n\t\t\tcolor: inherit;\n\t\t}\n\t}\n\n\t& .ck-button__label {\n\t\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\t\tfont-size: inherit;\n\t\tfont-weight: inherit;\n\t\tcolor: inherit;\n\t\tcursor: inherit;\n\n\t\t/* Must be consistent with .ck-icon\'s vertical align. Otherwise, buttons with and\n\t\twithout labels (but with icons) have different sizes in Chrome */\n\t\tvertical-align: middle;\n\n\t\t@mixin ck-dir ltr {\n\t\t\ttext-align: left;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\ttext-align: right;\n\t\t}\n\t}\n\n\t& .ck-button__keystroke {\n\t\tcolor: inherit;\n\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-left: var(--ck-spacing-large);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-right: var(--ck-spacing-large);\n\t\t}\n\n\t\tfont-weight: bold;\n\t\topacity: .7;\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */\n\t&.ck-disabled {\n\t\t&:active,\n\t\t&:focus {\n\t\t\t/* The disabled button should have a slightly less visible shadow when focused. */\n\t\t\t@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);\n\t\t}\n\n\t\t& .ck-button__icon {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\n\t\t& .ck-button__label {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t& .ck-button__keystroke {\n\t\t\topacity: .3;\n\t\t}\n\t}\n\n\t&.ck-button_with-text {\n\t\tpadding: var(--ck-spacing-tiny) var(--ck-spacing-standard);\n\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-button__icon {\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: calc(-1 * var(--ck-spacing-small));\n\t\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-right: calc(-1 * var(--ck-spacing-small));\n\t\t\t\tmargin-left: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\t}\n\n\t&.ck-button_with-keystroke {\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-button__label {\n\t\t\tflex-grow: 1;\n\t\t}\n\t}\n\n\t/* A style of the button which is currently on, e.g. its feature is active. */\n\t&.ck-on {\n\t\t@mixin ck-button-colors --ck-color-button-on;\n\n\t\tcolor: var(--ck-color-button-on-color);\n\t}\n\n\t&.ck-button-save {\n\t\tcolor: var(--ck-color-button-save);\n\t}\n\n\t&.ck-button-cancel {\n\t\tcolor: var(--ck-color-button-cancel);\n\t}\n}\n\n/* A style of the button which handles the primary action. */\n.ck.ck-button-action,\na.ck.ck-button-action {\n\t@mixin ck-button-colors --ck-color-button-action;\n\n\tcolor: var(--ck-color-button-action-text);\n}\n\n.ck.ck-button-bold,\na.ck.ck-button-bold {\n\tfont-weight: bold;\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements a button of given background color.\n *\n * @param {String} $background - Background color of the button.\n * @param {String} $border - Border color of the button.\n */\n@define-mixin ck-button-colors $prefix {\n\tbackground: var($(prefix)-background);\n\n\t&:not(.ck-disabled) {\n\t\t&:hover {\n\t\t\tbackground: var($(prefix)-hover-background);\n\t\t}\n\n\t\t&:active {\n\t\t\tbackground: var($(prefix)-active-background);\n\t\t}\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\n\t&.ck-disabled {\n\t\tbackground: var($(prefix)-disabled-background);\n\t}\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      258: (t, e, n) => {
        "use strict";
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ".ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{display:block}:root{--ck-switch-button-toggle-width:2.6153846154em;--ck-switch-button-toggle-inner-size:calc(1.07692em + 1px);--ck-switch-button-translation:calc(var(--ck-switch-button-toggle-width) - var(--ck-switch-button-toggle-inner-size) - 2px);--ck-switch-button-inner-hover-shadow:0 0 0 5px var(--ck-color-switch-button-inner-shadow)}.ck.ck-button.ck-switchbutton,.ck.ck-button.ck-switchbutton.ck-on:active,.ck.ck-button.ck-switchbutton.ck-on:focus,.ck.ck-button.ck-switchbutton.ck-on:hover,.ck.ck-button.ck-switchbutton:active,.ck.ck-button.ck-switchbutton:focus,.ck.ck-button.ck-switchbutton:hover{background:transparent;color:inherit}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__label{margin-right:calc(var(--ck-spacing-large)*2)}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__label{margin-left:calc(var(--ck-spacing-large)*2)}.ck.ck-button.ck-switchbutton .ck-button__toggle{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle.ck-rounded-corners{border-radius:var(--ck-border-radius)}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-left:auto}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-right:auto}.ck.ck-button.ck-switchbutton .ck-button__toggle{background:var(--ck-color-switch-button-off-background);border:1px solid transparent;transition:background .4s ease,box-shadow .2s ease-in-out,outline .2s ease-in-out;width:var(--ck-switch-button-toggle-width)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:calc(var(--ck-border-radius)*.5)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{background:var(--ck-color-switch-button-inner-background);height:var(--ck-switch-button-toggle-inner-size);transition:all .3s ease;width:var(--ck-switch-button-toggle-inner-size)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover{background:var(--ck-color-switch-button-off-hover-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover .ck-button__toggle__inner{box-shadow:var(--ck-switch-button-inner-hover-shadow)}.ck.ck-button.ck-switchbutton.ck-disabled .ck-button__toggle{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-switchbutton:focus{border-color:transparent;box-shadow:none;outline:none}.ck.ck-button.ck-switchbutton:focus .ck-button__toggle{box-shadow:0 0 0 1px var(--ck-color-base-background),0 0 0 5px var(--ck-color-focus-outer-shadow);outline:var(--ck-focus-ring);outline-offset:1px}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle{background:var(--ck-color-switch-button-on-background)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle:hover{background:var(--ck-color-switch-button-on-hover-background)}[dir=ltr] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(var( --ck-switch-button-translation ))}[dir=rtl] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(calc(var( --ck-switch-button-translation )*-1))}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/button/switchbutton.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/switchbutton.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css",
            ],
            names: [],
            mappings:
              "AASE,4HACC,aACD,CCCF,MAEC,8CAA+C,CAE/C,0DAAgE,CAChE,2HAIC,CACD,0FACD,CAOC,0QAEC,sBAAuB,CADvB,aAED,CAEA,0DAGE,4CAOF,CAVA,0DAQE,2CAEF,CAEA,iDCpCA,eD4EA,CAxCA,yIChCC,qCDwED,CAxCA,2DAKE,gBAmCF,CAxCA,2DAUE,iBA8BF,CAxCA,iDAkBC,uDAAwD,CAFxD,4BAA6B,CAD7B,iFAAsF,CAEtF,0CAuBD,CApBC,2ECxDD,eDmEC,CAXA,6LCpDA,qCAAsC,CDsDpC,8CASF,CAXA,2EAOC,yDAA0D,CAD1D,gDAAiD,CAIjD,uBAA0B,CAL1B,+CAMD,CAEA,uDACC,6DAKD,CAHC,iFACC,qDACD,CAIF,6DEhFA,kCFkFA,CAGA,oCACC,wBAAyB,CAEzB,eAAgB,CADhB,YAQD,CALC,uDACC,iGAAmG,CAEnG,4BAA6B,CAD7B,kBAED,CAKA,uDACC,sDAkBD,CAhBC,6DACC,4DACD,CAEA,2FAKE,2DAMF,CAXA,2FASE,oEAEF",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-button.ck-switchbutton {\n\t& .ck-button__toggle {\n\t\tdisplay: block;\n\n\t\t& .ck-button__toggle__inner {\n\t\t\tdisplay: block;\n\t\t}\n\t}\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n/* Note: To avoid rendering issues (aliasing) but to preserve the responsive nature\nof the component, floating–point numbers have been used which, for the default font size\n(see: --ck-font-size-base), will generate simple integers. */\n:root {\n\t/* 34px at 13px font-size */\n\t--ck-switch-button-toggle-width: 2.6153846154em;\n\t/* 14px at 13px font-size */\n\t--ck-switch-button-toggle-inner-size: calc(1.0769230769em + 1px);\n\t--ck-switch-button-translation: calc(\n\t\tvar(--ck-switch-button-toggle-width) -\n\t\tvar(--ck-switch-button-toggle-inner-size) -\n\t\t2px /* Border */\n\t);\n\t--ck-switch-button-inner-hover-shadow: 0 0 0 5px var(--ck-color-switch-button-inner-shadow);\n}\n\n.ck.ck-button.ck-switchbutton {\n\t/* Unlike a regular button, the switch button text color and background should never change.\n\t * Changing toggle switch (background, outline) is enough to carry the information about the\n\t * state of the entire component (https://github.com/ckeditor/ckeditor5/issues/12519)\n\t */\n\t&, &:hover, &:focus, &:active, &.ck-on:hover, &.ck-on:focus, &.ck-on:active {\n\t\tcolor: inherit;\n\t\tbackground: transparent;\n\t}\n\n\t& .ck-button__label {\n\t\t@mixin ck-dir ltr {\n\t\t\t/* Separate the label from the switch */\n\t\t\tmargin-right: calc(2 * var(--ck-spacing-large));\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t/* Separate the label from the switch */\n\t\t\tmargin-left: calc(2 * var(--ck-spacing-large));\n\t\t}\n\t}\n\n\t& .ck-button__toggle {\n\t\t@mixin ck-rounded-corners;\n\n\t\t@mixin ck-dir ltr {\n\t\t\t/* Make sure the toggle is always to the right as far as possible. */\n\t\t\tmargin-left: auto;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t/* Make sure the toggle is always to the left as far as possible. */\n\t\t\tmargin-right: auto;\n\t\t}\n\n\t\t/* Apply some smooth transition to the box-shadow and border. */\n\t\t/* Gently animate the background color of the toggle switch */\n\t\ttransition: background 400ms ease, box-shadow .2s ease-in-out, outline .2s ease-in-out;\n\t\tborder: 1px solid transparent;\n\t\twidth: var(--ck-switch-button-toggle-width);\n\t\tbackground: var(--ck-color-switch-button-off-background);\n\n\t\t& .ck-button__toggle__inner {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-radius: calc(.5 * var(--ck-border-radius));\n\t\t\t}\n\n\t\t\twidth: var(--ck-switch-button-toggle-inner-size);\n\t\t\theight: var(--ck-switch-button-toggle-inner-size);\n\t\t\tbackground: var(--ck-color-switch-button-inner-background);\n\n\t\t\t/* Gently animate the inner part of the toggle switch */\n\t\t\ttransition: all 300ms ease;\n\t\t}\n\n\t\t&:hover {\n\t\t\tbackground: var(--ck-color-switch-button-off-hover-background);\n\n\t\t\t& .ck-button__toggle__inner {\n\t\t\t\tbox-shadow: var(--ck-switch-button-inner-hover-shadow);\n\t\t\t}\n\t\t}\n\t}\n\n\t&.ck-disabled .ck-button__toggle {\n\t\t@mixin ck-disabled;\n\t}\n\n\t/* Overriding default .ck-button:focus styles + an outline around the toogle */\n\t&:focus {\n\t\tborder-color: transparent;\n\t\toutline: none;\n\t\tbox-shadow: none;\n\n\t\t& .ck-button__toggle {\n\t\t\tbox-shadow: 0 0 0 1px var(--ck-color-base-background), 0 0 0 5px var(--ck-color-focus-outer-shadow);\n\t\t\toutline-offset: 1px;\n\t\t\toutline: var(--ck-focus-ring);\n\t\t}\n\t}\n\n\t/* stylelint-disable-next-line no-descending-specificity */\n\t&.ck-on {\n\t\t& .ck-button__toggle {\n\t\t\tbackground: var(--ck-color-switch-button-on-background);\n\n\t\t\t&:hover {\n\t\t\t\tbackground: var(--ck-color-switch-button-on-hover-background);\n\t\t\t}\n\n\t\t\t& .ck-button__toggle__inner {\n\t\t\t\t/*\n\t\t\t\t* Move the toggle switch to the right. It will be animated.\n\t\t\t\t*/\n\t\t\t\t@mixin ck-dir ltr {\n\t\t\t\t\ttransform: translateX( var( --ck-switch-button-translation ) );\n\t\t\t\t}\n\n\t\t\t\t@mixin ck-dir rtl {\n\t\t\t\t\ttransform: translateX( calc( -1 * var( --ck-switch-button-translation ) ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      923: (t, e, n) => {
        "use strict";
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ".ck.ck-color-grid{display:grid}:root{--ck-color-grid-tile-size:24px;--ck-color-color-grid-check-icon:#166fd4}.ck.ck-color-grid{grid-gap:5px;padding:8px}.ck.ck-color-grid__tile{border:0;height:var(--ck-color-grid-tile-size);min-height:var(--ck-color-grid-tile-size);min-width:var(--ck-color-grid-tile-size);padding:0;transition:box-shadow .2s ease;width:var(--ck-color-grid-tile-size)}.ck.ck-color-grid__tile.ck-disabled{cursor:unset;transition:unset}.ck.ck-color-grid__tile.ck-color-selector__color-tile_bordered{box-shadow:0 0 0 1px var(--ck-color-base-border)}.ck.ck-color-grid__tile .ck.ck-icon{color:var(--ck-color-color-grid-check-icon);display:none}.ck.ck-color-grid__tile.ck-on{box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-base-text)}.ck.ck-color-grid__tile.ck-on .ck.ck-icon{display:block}.ck.ck-color-grid__tile.ck-on,.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){border:0}.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}.ck.ck-color-grid__label{padding:0 var(--ck-spacing-standard)}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/colorgrid/colorgrid.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/colorgrid/colorgrid.css",
            ],
            names: [],
            mappings:
              "AAKA,kBACC,YACD,CCAA,MACC,8BAA+B,CAK/B,wCACD,CAEA,kBACC,YAAa,CACb,WACD,CAEA,wBAOC,QAAS,CALT,qCAAsC,CAEtC,yCAA0C,CAD1C,wCAAyC,CAEzC,SAAU,CACV,8BAA+B,CAL/B,oCAyCD,CAjCC,oCACC,YAAa,CACb,gBACD,CAEA,+DACC,gDACD,CAEA,oCAEC,2CAA4C,CAD5C,YAED,CAEA,8BACC,8FAKD,CAHC,0CACC,aACD,CAGD,8HAIC,QACD,CAEA,gGAEC,iGACD,CAGD,yBACC,oCACD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-color-grid {\n\tdisplay: grid;\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-color-grid-tile-size: 24px;\n\n\t/* Not using global colors here because these may change but some colors in a pallette\n\t * require special treatment. For instance, this ensures no matter what the UI text color is,\n\t * the check icon will look good on the black color tile. */\n\t--ck-color-color-grid-check-icon: hsl(212, 81%, 46%);\n}\n\n.ck.ck-color-grid {\n\tgrid-gap: 5px;\n\tpadding: 8px;\n}\n\n.ck.ck-color-grid__tile {\n\twidth: var(--ck-color-grid-tile-size);\n\theight: var(--ck-color-grid-tile-size);\n\tmin-width: var(--ck-color-grid-tile-size);\n\tmin-height: var(--ck-color-grid-tile-size);\n\tpadding: 0;\n\ttransition: .2s ease box-shadow;\n\tborder: 0;\n\n\t&.ck-disabled {\n\t\tcursor: unset;\n\t\ttransition: unset;\n\t}\n\n\t&.ck-color-selector__color-tile_bordered {\n\t\tbox-shadow: 0 0 0 1px var(--ck-color-base-border);\n\t}\n\n\t& .ck.ck-icon {\n\t\tdisplay: none;\n\t\tcolor: var(--ck-color-color-grid-check-icon);\n\t}\n\n\t&.ck-on {\n\t\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-base-text);\n\n\t\t& .ck.ck-icon {\n\t\t\tdisplay: block;\n\t\t}\n\t}\n\n\t&.ck-on,\n\t&:focus:not( .ck-disabled ),\n\t&:hover:not( .ck-disabled ) {\n\t\t/* Disable the default .ck-button\'s border ring. */\n\t\tborder: 0;\n\t}\n\n\t&:focus:not( .ck-disabled ),\n\t&:hover:not( .ck-disabled ) {\n\t\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-focus-border);\n\t}\n}\n\n.ck.ck-color-grid__label {\n\tpadding: 0 var(--ck-spacing-standard);\n}\n',
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      257: (t, e, n) => {
        "use strict";
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ".color-picker-hex-input{width:max-content}.color-picker-hex-input .ck.ck-input{min-width:unset}.ck.ck-color-picker__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between;margin:var(--ck-spacing-large) 0 0;width:unset}.ck.ck-color-picker__row .ck.ck-labeled-field-view{padding-top:unset}.ck.ck-color-picker__row .ck.ck-input-text{width:unset}.ck.ck-color-picker__row .ck-color-picker__hash-view{padding-right:var(--ck-spacing-medium);padding-top:var(--ck-spacing-tiny)}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/colorpicker/colorpicker.css",
            ],
            names: [],
            mappings:
              "AAKA,wBACC,iBAKD,CAHC,qCACC,eACD,CAGD,yBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,6BAA8B,CAC9B,kCAAmC,CACnC,WAcD,CAZC,mDACC,iBACD,CAEA,2CACC,WACD,CAEA,qDAEC,sCAAuC,CADvC,kCAED",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.color-picker-hex-input {\n\twidth: max-content;\n\n\t& .ck.ck-input {\n\t\tmin-width: unset;\n\t}\n}\n\n.ck.ck-color-picker__row {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\tjustify-content: space-between;\n\tmargin: var(--ck-spacing-large) 0 0;\n\twidth: unset;\n\n\t& .ck.ck-labeled-field-view {\n\t\tpadding-top: unset;\n\t}\n\n\t& .ck.ck-input-text {\n\t\twidth: unset;\n\t}\n\n\t& .ck-color-picker__hash-view {\n\t\tpadding-top: var(--ck-spacing-tiny);\n\t\tpadding-right: var(--ck-spacing-medium);\n\t}\n}\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      306: (t, e, n) => {
        "use strict";
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ".ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker,.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__remove-color{align-items:center;display:flex}[dir=rtl] .ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker,[dir=rtl] .ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__remove-color{justify-content:flex-start}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-selector_action-bar{display:flex;flex-direction:row;justify-content:space-around}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-selector_action-bar .ck-button-cancel,.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-selector_action-bar .ck-button-save{flex:1}.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker,.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__remove-color{width:100%}.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker{border-bottom-left-radius:0;border-bottom-right-radius:0;padding:calc(var(--ck-spacing-standard)/2) var(--ck-spacing-standard)}.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker:not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker .ck.ck-icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker .ck.ck-icon{margin-left:var(--ck-spacing-standard)}.ck.ck-color-selector .ck-color-grids-fragment label.ck.ck-color-grid__label{font-weight:unset}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker{padding:8px}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker{height:100px;min-width:180px}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker::part(saturation){border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker::part(hue){border-radius:0 0 var(--ck-border-radius) var(--ck-border-radius)}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker::part(hue-pointer),.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker::part(saturation-pointer){height:15px;width:15px}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-selector_action-bar{padding:0 8px 8px}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/colorselector/colorselector.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/colorselector/colorselector.css",
            ],
            names: [],
            mappings:
              "AAUE,oLAGC,kBAAmB,CADnB,YAMD,CARA,wMAME,0BAEF,CAKA,iFACC,YAAa,CACb,kBAAmB,CACnB,4BAMD,CAJC,oMAEC,MACD,CCrBD,oLAEC,UACD,CAEA,0FAEC,2BAA4B,CAC5B,4BAA6B,CAF7B,qEAiBD,CAbC,sGACC,gDACD,CAEA,gHAEE,uCAMF,CARA,gHAME,sCAEF,CAGD,6EACC,iBACD,CAKA,oEACC,WAoBD,CAlBC,sFACC,YAAa,CACb,eAeD,CAbC,wGACC,iEACD,CAEA,iGACC,iEACD,CAEA,yNAGC,WAAY,CADZ,UAED,CAIF,iFACC,iBACD",
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-color-selector {\n\t/* View fragment with color grids. */\n\t& .ck-color-grids-fragment {\n\t\t& .ck-button.ck-color-selector__remove-color,\n\t\t& .ck-button.ck-color-selector__color-picker {\n\t\t\tdisplay: flex;\n\t\t\talign-items: center;\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tjustify-content: flex-start;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* View fragment with a color picker. */\n\t& .ck-color-picker-fragment {\n\t\t& .ck.ck-color-selector_action-bar {\n\t\t\tdisplay: flex;\n\t\t\tflex-direction: row;\n\t\t\tjustify-content: space-around;\n\n\t\t\t& .ck-button-save,\n\t\t\t& .ck-button-cancel {\n\t\t\t\tflex: 1\n\t\t\t}\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-color-selector {\n\t/* View fragment with color grids. */\n\t& .ck-color-grids-fragment {\n\t\t& .ck-button.ck-color-selector__remove-color,\n\t\t& .ck-button.ck-color-selector__color-picker {\n\t\t\twidth: 100%;\n\t\t}\n\n\t\t& .ck-button.ck-color-selector__color-picker {\n\t\t\tpadding: calc(var(--ck-spacing-standard) / 2) var(--ck-spacing-standard);\n\t\t\tborder-bottom-left-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\n\t\t\t&:not(:focus) {\n\t\t\t\tborder-top: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\n\t\t\t& .ck.ck-icon {\n\t\t\t\t@mixin ck-dir ltr {\n\t\t\t\t\tmargin-right: var(--ck-spacing-standard);\n\t\t\t\t}\n\n\t\t\t\t@mixin ck-dir rtl {\n\t\t\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t& label.ck.ck-color-grid__label {\n\t\t\tfont-weight: unset;\n\t\t}\n\t}\n\n\t/* View fragment with a color picker. */\n\t& .ck-color-picker-fragment {\n\t\t& .ck.ck-color-picker {\n\t\t\tpadding: 8px;\n\n\t\t\t& .hex-color-picker {\n\t\t\t\theight: 100px;\n\t\t\t\tmin-width: 180px;\n\n\t\t\t\t&::part(saturation) {\n\t\t\t\t\tborder-radius: var(--ck-border-radius) var(--ck-border-radius) 0 0;\n\t\t\t\t}\n\n\t\t\t\t&::part(hue) {\n\t\t\t\t\tborder-radius: 0 0 var(--ck-border-radius) var(--ck-border-radius);\n\t\t\t\t}\n\n\t\t\t\t&::part(saturation-pointer),\n\t\t\t\t&::part(hue-pointer) {\n\t\t\t\t\twidth: 15px;\n\t\t\t\t\theight: 15px;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t& .ck.ck-color-selector_action-bar {\n\t\t\tpadding: 0 8px 8px;\n\t\t}\n\t}\n}\n',
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      62: (t, e, n) => {
        "use strict";
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ":root{--ck-dropdown-max-width:75vw}.ck.ck-dropdown{display:inline-block;position:relative}.ck.ck-dropdown .ck-dropdown__arrow{pointer-events:none;z-index:var(--ck-z-default)}.ck.ck-dropdown .ck-button.ck-dropdown__button{width:100%}.ck.ck-dropdown .ck-dropdown__panel{display:none;max-width:var(--ck-dropdown-max-width);position:absolute;z-index:var(--ck-z-modal)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel-visible{display:inline-block}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw{bottom:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{bottom:auto;top:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se{left:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{right:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s{left:50%;transform:translateX(-50%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw{left:75%;transform:translateX(-75%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme{left:25%;transform:translateX(-25%)}.ck.ck-toolbar .ck-dropdown__panel{z-index:calc(var(--ck-z-modal) + 1)}:root{--ck-dropdown-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-dropdown{font-size:inherit}.ck.ck-dropdown .ck-dropdown__arrow{width:var(--ck-dropdown-arrow-size)}[dir=ltr] .ck.ck-dropdown .ck-dropdown__arrow{margin-left:var(--ck-spacing-standard);right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-dropdown .ck-dropdown__arrow{left:var(--ck-spacing-standard);margin-right:var(--ck-spacing-small)}.ck.ck-dropdown.ck-disabled .ck-dropdown__arrow{opacity:var(--ck-disabled-opacity)}[dir=ltr] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-left:var(--ck-spacing-small)}[dir=rtl] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-right:var(--ck-spacing-small)}.ck.ck-dropdown .ck-button.ck-dropdown__button .ck-button__label{overflow:hidden;text-overflow:ellipsis;width:7em}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on{border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-dropdown__button_label-width_auto .ck-button__label{width:auto}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active{box-shadow:none}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active:focus,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active:focus{box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-dropdown__panel{border-radius:0}.ck-rounded-corners .ck.ck-dropdown__panel,.ck.ck-dropdown__panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-dropdown__panel{background:var(--ck-color-dropdown-panel-background);border:1px solid var(--ck-color-dropdown-panel-border);bottom:0;box-shadow:var(--ck-drop-shadow),0 0;min-width:100%}.ck.ck-dropdown__panel.ck-dropdown__panel_se{border-top-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_sw{border-top-right-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_ne{border-bottom-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_nw{border-bottom-right-radius:0}.ck.ck-dropdown__panel:focus{outline:none}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/dropdown.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/dropdown.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
            ],
            names: [],
            mappings:
              "AAKA,MACC,4BACD,CAEA,gBACC,oBAAqB,CACrB,iBA2ED,CAzEC,oCACC,mBAAoB,CACpB,2BACD,CAGA,+CACC,UACD,CAEA,oCACC,YAAa,CAEb,sCAAuC,CAEvC,iBAAkB,CAHlB,yBA4DD,CAvDC,+DACC,oBACD,CAEA,mSAKC,WACD,CAEA,mSAUC,WAAY,CADZ,QAED,CAEA,oHAEC,MACD,CAEA,oHAEC,OACD,CAEA,kHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAQF,mCACC,mCACD,CCpFA,MACC,sDACD,CAEA,gBAEC,iBA2ED,CAzEC,oCACC,mCACD,CAGC,8CAIC,sCAAuC,CAHvC,gCAID,CAIA,8CACC,+BAAgC,CAGhC,oCACD,CAGD,gDC/BA,kCDiCA,CAIE,mFAEC,oCACD,CAIA,mFAEC,qCACD,CAID,iEAEC,eAAgB,CAChB,sBAAuB,CAFvB,SAGD,CAGA,6EC1DD,kCD4DC,CAGA,qDACC,2BAA4B,CAC5B,4BACD,CAEA,sGACC,UACD,CAGA,yHAEC,eAKD,CAHC,qIE7EF,2CF+EE,CAKH,uBGlFC,eHkHD,CAhCA,qFG9EE,qCH8GF,CAhCA,uBAIC,oDAAqD,CACrD,sDAAuD,CACvD,QAAS,CE1FT,oCAA8B,CF6F9B,cAuBD,CAnBC,6CACC,wBACD,CAEA,6CACC,yBACD,CAEA,6CACC,2BACD,CAEA,6CACC,4BACD,CAEA,6BACC,YACD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-dropdown-max-width: 75vw;\n}\n\n.ck.ck-dropdown {\n\tdisplay: inline-block;\n\tposition: relative;\n\n\t& .ck-dropdown__arrow {\n\t\tpointer-events: none;\n\t\tz-index: var(--ck-z-default);\n\t}\n\n\t/* Dropdown button should span horizontally, e.g. in vertical toolbars */\n\t& .ck-button.ck-dropdown__button {\n\t\twidth: 100%;\n\t}\n\n\t& .ck-dropdown__panel {\n\t\tdisplay: none;\n\t\tz-index: var(--ck-z-modal);\n\t\tmax-width: var(--ck-dropdown-max-width);\n\n\t\tposition: absolute;\n\n\t\t&.ck-dropdown__panel-visible {\n\t\t\tdisplay: inline-block;\n\t\t}\n\n\t\t&.ck-dropdown__panel_ne,\n\t\t&.ck-dropdown__panel_nw,\n\t\t&.ck-dropdown__panel_n,\n\t\t&.ck-dropdown__panel_nmw,\n\t\t&.ck-dropdown__panel_nme {\n\t\t\tbottom: 100%;\n\t\t}\n\n\t\t&.ck-dropdown__panel_se,\n\t\t&.ck-dropdown__panel_sw,\n\t\t&.ck-dropdown__panel_smw,\n\t\t&.ck-dropdown__panel_sme,\n\t\t&.ck-dropdown__panel_s {\n\t\t\t/*\n\t\t\t * Using transform: translate3d( 0, 100%, 0 ) causes blurry dropdown on Chrome 67-78+ on non-retina displays.\n\t\t\t * See https://github.com/ckeditor/ckeditor5/issues/1053.\n\t\t\t */\n\t\t\ttop: 100%;\n\t\t\tbottom: auto;\n\t\t}\n\n\t\t&.ck-dropdown__panel_ne,\n\t\t&.ck-dropdown__panel_se {\n\t\t\tleft: 0px;\n\t\t}\n\n\t\t&.ck-dropdown__panel_nw,\n\t\t&.ck-dropdown__panel_sw {\n\t\t\tright: 0px;\n\t\t}\n\n\t\t&.ck-dropdown__panel_s,\n\t\t&.ck-dropdown__panel_n {\n\t\t\t/* Positioning panels relative to the center of the button */\n\t\t\tleft: 50%;\n\t\t\ttransform: translateX(-50%);\n\t\t}\n\n\t\t&.ck-dropdown__panel_nmw,\n\t\t&.ck-dropdown__panel_smw {\n\t\t\t/* Positioning panels relative to the middle-west of the button */\n\t\t\tleft: 75%;\n\t\t\ttransform: translateX(-75%);\n\t\t}\n\n\t\t&.ck-dropdown__panel_nme,\n\t\t&.ck-dropdown__panel_sme {\n\t\t\t/* Positioning panels relative to the middle-east of the button */\n\t\t\tleft: 25%;\n\t\t\ttransform: translateX(-25%);\n\t\t}\n\t}\n}\n\n/*\n * Toolbar dropdown panels should be always above the UI (eg. other dropdown panels) from the editor's content.\n * See https://github.com/ckeditor/ckeditor5/issues/7874\n */\n.ck.ck-toolbar .ck-dropdown__panel {\n\tz-index: calc( var(--ck-z-modal) + 1 );\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_shadow.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n:root {\n\t--ck-dropdown-arrow-size: calc(0.5 * var(--ck-icon-size));\n}\n\n.ck.ck-dropdown {\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t& .ck-dropdown__arrow {\n\t\twidth: var(--ck-dropdown-arrow-size);\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& .ck-dropdown__arrow {\n\t\t\tright: var(--ck-spacing-standard);\n\n\t\t\t/* A space to accommodate the triangle. */\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& .ck-dropdown__arrow {\n\t\t\tleft: var(--ck-spacing-standard);\n\n\t\t\t/* A space to accommodate the triangle. */\n\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t}\n\t}\n\n\t&.ck-disabled .ck-dropdown__arrow {\n\t\t@mixin ck-disabled;\n\t}\n\n\t& .ck-button.ck-dropdown__button {\n\t\t@mixin ck-dir ltr {\n\t\t\t&:not(.ck-button_with-text) {\n\t\t\t\t/* Make sure dropdowns with just an icon have the right inner spacing */\n\t\t\t\tpadding-left: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t&:not(.ck-button_with-text) {\n\t\t\t\t/* Make sure dropdowns with just an icon have the right inner spacing */\n\t\t\t\tpadding-right: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\n\t\t/* #23 */\n\t\t& .ck-button__label {\n\t\t\twidth: 7em;\n\t\t\toverflow: hidden;\n\t\t\ttext-overflow: ellipsis;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */\n\t\t&.ck-disabled .ck-button__label {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/816 */\n\t\t&.ck-on {\n\t\t\tborder-bottom-left-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t&.ck-dropdown__button_label-width_auto .ck-button__label {\n\t\t\twidth: auto;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/8699 */\n\t\t&.ck-off:active,\n\t\t&.ck-on:active {\n\t\t\tbox-shadow: none;\n\n\t\t\t&:focus {\n\t\t\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-dropdown__panel {\n\t@mixin ck-rounded-corners;\n\t@mixin ck-drop-shadow;\n\n\tbackground: var(--ck-color-dropdown-panel-background);\n\tborder: 1px solid var(--ck-color-dropdown-panel-border);\n\tbottom: 0;\n\n\t/* Make sure the panel is at least as wide as the drop-down\'s button. */\n\tmin-width: 100%;\n\n\t/* Disabled corner border radius to be consistent with the .dropdown__button\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t&.ck-dropdown__panel_se {\n\t\tborder-top-left-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_sw {\n\t\tborder-top-right-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_ne {\n\t\tborder-bottom-left-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_nw {\n\t\tborder-bottom-right-radius: 0;\n\t}\n\n\t&:focus {\n\t\toutline: none;\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      883: (t, e, n) => {
        "use strict";
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ".ck.ck-dropdown .ck-dropdown__panel .ck-list{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list,.ck.ck-dropdown .ck-dropdown__panel .ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0;border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/listdropdown.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
            ],
            names: [],
            mappings:
              "AAOA,6CCIC,eDqBD,CAzBA,iICQE,qCAAsC,CDJtC,wBAqBF,CAfE,mFCND,eDYC,CANA,6MCFA,qCAAsC,CDKpC,2BAA4B,CAC5B,4BAA6B,CAF7B,wBAIF,CAEA,kFCdD,eDmBC,CALA,2MCVA,qCAAsC,CDYpC,wBAAyB,CACzB,yBAEF",
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n.ck.ck-dropdown .ck-dropdown__panel .ck-list {\n\t/* Disabled radius of top-left border to be consistent with .dropdown__button\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t@mixin ck-rounded-corners {\n\t\tborder-top-left-radius: 0;\n\t}\n\n\t/* Make sure the button belonging to the first/last child of the list goes well with the\n\tborder radius of the entire panel. */\n\t& .ck-list__item {\n\t\t&:first-child .ck-button {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\t\t}\n\n\t\t&:last-child .ck-button {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-top-right-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      791: (t, e, n) => {
        "use strict";
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          '.ck.ck-splitbutton{font-size:inherit}.ck.ck-splitbutton .ck-splitbutton__action:focus{z-index:calc(var(--ck-z-default) + 1)}:root{--ck-color-split-button-hover-background:#ebebeb;--ck-color-split-button-hover-border:#b3b3b3}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-right-radius:unset;border-top-right-radius:unset}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-left-radius:unset;border-top-left-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow{min-width:unset}[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-left-radius:unset;border-top-left-radius:unset}[dir=rtl] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-right-radius:unset;border-top-right-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow svg{width:var(--ck-dropdown-arrow-size)}.ck.ck-splitbutton>.ck-splitbutton__arrow:not(:focus){border-bottom-width:0;border-top-width:0}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover),.ck.ck-splitbutton:hover>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover){background:var(--ck-color-split-button-hover-background)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{background-color:var(--ck-color-split-button-hover-border);content:"";height:100%;position:absolute;width:1px}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:focus:after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:focus:after{--ck-color-split-button-hover-border:var(--ck-color-focus-border)}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{left:-1px}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{right:-1px}.ck.ck-splitbutton.ck-splitbutton_open{border-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__action{border-bottom-left-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__arrow{border-bottom-right-radius:0}',
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/splitbutton.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/splitbutton.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
            ],
            names: [],
            mappings:
              "AAKA,mBAEC,iBAKD,CAHC,iDACC,qCACD,CCJD,MACC,gDAAyD,CACzD,4CACD,CAMC,oIAKE,gCAAiC,CADjC,6BASF,CAbA,oIAWE,+BAAgC,CADhC,4BAGF,CAEA,0CAGC,eAiBD,CApBA,oDAQE,+BAAgC,CADhC,4BAaF,CApBA,oDAcE,gCAAiC,CADjC,6BAOF,CAHC,8CACC,mCACD,CAKD,sDAEC,qBAAwB,CADxB,kBAED,CAQC,0KACC,wDACD,CAIA,8JAKC,0DAA2D,CAJ3D,UAAW,CAGX,WAAY,CAFZ,iBAAkB,CAClB,SAGD,CAGA,sIACC,iEACD,CAGC,kLACC,SACD,CAIA,kLACC,UACD,CAMF,uCCzFA,eDmGA,CAVA,qHCrFC,qCD+FD,CARE,qKACC,2BACD,CAEA,mKACC,4BACD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-splitbutton {\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t& .ck-splitbutton__action:focus {\n\t\tz-index: calc(var(--ck-z-default) + 1);\n\t}\n}\n\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-color-split-button-hover-background: hsl(0, 0%, 92%);\n\t--ck-color-split-button-hover-border: hsl(0, 0%, 70%);\n}\n\n.ck.ck-splitbutton {\n\t/*\n\t * Note: ck-rounded and ck-dir mixins don\'t go together (because they both use @nest).\n\t */\n\t&:hover > .ck-splitbutton__action,\n\t&.ck-splitbutton_open > .ck-splitbutton__action {\n\t\t@nest [dir="ltr"] & {\n\t\t\t/* Don\'t round the action button on the right side */\n\t\t\tborder-top-right-radius: unset;\n\t\t\tborder-bottom-right-radius: unset;\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t/* Don\'t round the action button on the left side */\n\t\t\tborder-top-left-radius: unset;\n\t\t\tborder-bottom-left-radius: unset;\n\t\t}\n\t}\n\n\t& > .ck-splitbutton__arrow {\n\t\t/* It\'s a text-less button and since the icon is positioned absolutely in such situation,\n\t\tit must get some arbitrary min-width. */\n\t\tmin-width: unset;\n\n\t\t@nest [dir="ltr"] & {\n\t\t\t/* Don\'t round the arrow button on the left side */\n\t\t\tborder-top-left-radius: unset;\n\t\t\tborder-bottom-left-radius: unset;\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t/* Don\'t round the arrow button on the right side */\n\t\t\tborder-top-right-radius: unset;\n\t\t\tborder-bottom-right-radius: unset;\n\t\t}\n\n\t\t& svg {\n\t\t\twidth: var(--ck-dropdown-arrow-size);\n\t\t}\n\t}\n\n\t/* Make sure the divider stretches 100% height of the button\n\thttps://github.com/ckeditor/ckeditor5/issues/10936 */\n\t& > .ck-splitbutton__arrow:not(:focus) {\n\t\tborder-top-width: 0px;\n\t\tborder-bottom-width: 0px;\n\t}\n\n\t/* When the split button is "open" (the arrow is on) or being hovered, it should get some styling\n\tas a whole. The background of both buttons should stand out and there should be a visual\n\tseparation between both buttons. */\n\t&.ck-splitbutton_open,\n\t&:hover {\n\t\t/* When the split button hovered as a whole, not as individual buttons. */\n\t\t& > .ck-button:not(.ck-on):not(.ck-disabled):not(:hover) {\n\t\t\tbackground: var(--ck-color-split-button-hover-background);\n\t\t}\n\n\t\t/* Splitbutton separator needs to be set with the ::after pseudoselector\n\t\tto display properly the borders on focus */\n\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\tcontent: \'\';\n\t\t\tposition: absolute;\n\t\t\twidth: 1px;\n\t\t\theight: 100%;\n\t\t\tbackground-color: var(--ck-color-split-button-hover-border);\n\t\t}\n\n\t\t/* Make sure the divider between the buttons looks fine when the button is focused */\n\t\t& > .ck-splitbutton__arrow:focus::after {\n\t\t\t--ck-color-split-button-hover-border: var(--ck-color-focus-border);\n\t\t}\n\n\t\t@nest [dir="ltr"] & {\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\t\tleft: -1px;\n\t\t\t}\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\t\tright: -1px;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Don\'t round the bottom left and right corners of the buttons when "open"\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t&.ck-splitbutton_open {\n\t\t@mixin ck-rounded-corners {\n\t\t\t& > .ck-splitbutton__action {\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t}\n\n\t\t\t& > .ck-splitbutton__arrow {\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      704: (t, e, n) => {
        "use strict";
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ":root{--ck-toolbar-dropdown-max-width:60vw}.ck.ck-toolbar-dropdown>.ck-dropdown__panel{max-width:var(--ck-toolbar-dropdown-max-width);width:max-content}.ck.ck-toolbar-dropdown>.ck-dropdown__panel .ck-button:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-toolbar-dropdown .ck-toolbar{border:0}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/toolbardropdown.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/toolbardropdown.css",
            ],
            names: [],
            mappings:
              "AAKA,MACC,oCACD,CAEA,4CAGC,8CAA+C,CAD/C,iBAQD,CAJE,6DACC,qCACD,CCZF,oCACC,QACD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-toolbar-dropdown-max-width: 60vw;\n}\n\n.ck.ck-toolbar-dropdown > .ck-dropdown__panel {\n\t/* https://github.com/ckeditor/ckeditor5/issues/5586 */\n\twidth: max-content;\n\tmax-width: var(--ck-toolbar-dropdown-max-width);\n\n\t& .ck-button {\n\t\t&:focus {\n\t\t\tz-index: calc(var(--ck-z-default) + 1);\n\t\t}\n\t}\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-toolbar-dropdown .ck-toolbar {\n\tborder: 0;\n}\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      847: (t, e, n) => {
        "use strict";
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ":root{--ck-color-editable-blur-selection:#d9d9d9}.ck.ck-editor__editable:not(.ck-editor__nested-editable){border-radius:0}.ck-rounded-corners .ck.ck-editor__editable:not(.ck-editor__nested-editable),.ck.ck-editor__editable.ck-rounded-corners:not(.ck-editor__nested-editable){border-radius:var(--ck-border-radius)}.ck.ck-editor__editable.ck-focused:not(.ck-editor__nested-editable){border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck.ck-editor__editable_inline{border:1px solid transparent;overflow:auto;padding:0 var(--ck-spacing-standard)}.ck.ck-editor__editable_inline[dir=ltr]{text-align:left}.ck.ck-editor__editable_inline[dir=rtl]{text-align:right}.ck.ck-editor__editable_inline>:first-child{margin-top:var(--ck-spacing-large)}.ck.ck-editor__editable_inline>:last-child{margin-bottom:var(--ck-spacing-large)}.ck.ck-editor__editable_inline.ck-blurred ::selection{background:var(--ck-color-editable-blur-selection)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_n]:after{border-bottom-color:var(--ck-color-panel-background)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_s]:after{border-top-color:var(--ck-color-panel-background)}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/editorui/editorui.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
            ],
            names: [],
            mappings:
              "AAWA,MACC,0CACD,CAEA,yDCJC,eDWD,CAPA,yJCAE,qCDOF,CAJC,oEEPA,2BAA2B,CCF3B,qCAA8B,CDC9B,YFWA,CAGD,+BAGC,4BAA6B,CAF7B,aAAc,CACd,oCA6BD,CA1BC,wCACC,eACD,CAEA,wCACC,gBACD,CAGA,4CACC,kCACD,CAGA,2CAKC,qCACD,CAGA,sDACC,kDACD,CAKA,gEACC,oDACD,CAIA,gEACC,iDACD",
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_shadow.css";\n@import "../../../mixins/_focus.css";\n@import "../../mixins/_button.css";\n\n:root {\n\t--ck-color-editable-blur-selection: hsl(0, 0%, 85%);\n}\n\n.ck.ck-editor__editable:not(.ck-editor__nested-editable) {\n\t@mixin ck-rounded-corners;\n\n\t&.ck-focused {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-inner-shadow);\n\t}\n}\n\n.ck.ck-editor__editable_inline {\n\toverflow: auto;\n\tpadding: 0 var(--ck-spacing-standard);\n\tborder: 1px solid transparent;\n\n\t&[dir="ltr"] {\n\t\ttext-align: left;\n\t}\n\n\t&[dir="rtl"] {\n\t\ttext-align: right;\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/116 */\n\t& > *:first-child {\n\t\tmargin-top: var(--ck-spacing-large);\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5/issues/847 */\n\t& > *:last-child {\n\t\t/*\n\t\t * This value should match with the default margins of the block elements (like .media or .image)\n\t\t * to avoid a content jumping when the fake selection container shows up (See https://github.com/ckeditor/ckeditor5/issues/9825).\n\t\t */\n\t\tmargin-bottom: var(--ck-spacing-large);\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5/issues/6517 */\n\t&.ck-blurred ::selection {\n\t\tbackground: var(--ck-color-editable-blur-selection);\n\t}\n}\n\n/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/111 */\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_n"] {\n\t&::after {\n\t\tborder-bottom-color: var(--ck-color-panel-background);\n\t}\n}\n\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_s"] {\n\t&::after {\n\t\tborder-top-color: var(--ck-color-panel-background);\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      668: (t, e, n) => {
        "use strict";
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ".ck.ck-form__header{align-items:center;display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-form__header .ck-icon{margin-right:var(--ck-spacing-medium)}.ck.ck-form__header h2.ck-form__header__label{flex-grow:1}:root{--ck-form-header-height:38px}.ck.ck-form__header{border-bottom:1px solid var(--ck-color-base-border);height:var(--ck-form-header-height);line-height:var(--ck-form-header-height);padding:var(--ck-spacing-small) var(--ck-spacing-large)}.ck.ck-form__header .ck-form__header__label{font-weight:700}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/formheader/formheader.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/formheader/formheader.css",
            ],
            names: [],
            mappings:
              "AAKA,oBAIC,kBAAmB,CAHnB,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CAEjB,6BASD,CAPC,6BACC,qCACD,CAEA,8CACC,WACD,CCbD,MACC,4BACD,CAEA,oBAIC,mDAAoD,CAFpD,mCAAoC,CACpC,wCAAyC,CAFzC,uDAQD,CAHC,4CACC,eACD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-form__header {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\talign-items: center;\n\tjustify-content: space-between;\n\n\t& .ck-icon {\n\t\tmargin-right: var(--ck-spacing-medium);\n\t}\n\n\t& h2.ck-form__header__label {\n\t\tflex-grow: 1;\n\t}\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-form-header-height: 38px;\n}\n\n.ck.ck-form__header {\n\tpadding: var(--ck-spacing-small) var(--ck-spacing-large);\n\theight: var(--ck-form-header-height);\n\tline-height: var(--ck-form-header-height);\n\tborder-bottom: 1px solid var(--ck-color-base-border);\n\n\t& .ck-form__header__label {\n\t\tfont-weight: bold;\n\t}\n}\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      746: (t, e, n) => {
        "use strict";
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ".ck.ck-highlighted-text mark{background:var(--ck-color-highlight-background);font-size:inherit;font-weight:inherit;line-height:inherit;vertical-align:initial}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/highlightedtext/highlightedtext.css",
            ],
            names: [],
            mappings: "AAKA,6BACC,+CAAgD,CAIhD,iBAAkB,CAFlB,mBAAoB,CACpB,mBAAoB,CAFpB,sBAID",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-highlighted-text mark {\n\tbackground: var(--ck-color-highlight-background);\n\tvertical-align: initial;\n\tfont-weight: inherit;\n\tline-height: inherit;\n\tfont-size: inherit;\n}\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      977: (t, e, n) => {
        "use strict";
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ".ck.ck-icon{vertical-align:middle}:root{--ck-icon-size:calc(var(--ck-line-height-base)*var(--ck-font-size-normal))}.ck.ck-icon{font-size:.8333350694em;height:var(--ck-icon-size);width:var(--ck-icon-size);will-change:transform}.ck.ck-icon,.ck.ck-icon *{cursor:inherit}.ck.ck-icon.ck-icon_inherit-color,.ck.ck-icon.ck-icon_inherit-color *{color:inherit}.ck.ck-icon.ck-icon_inherit-color :not([fill]){fill:currentColor}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/icon/icon.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/icon/icon.css",
            ],
            names: [],
            mappings:
              "AAKA,YACC,qBACD,CCFA,MACC,0EACD,CAEA,YAKC,uBAAwB,CAHxB,0BAA2B,CAD3B,yBAA0B,CAU1B,qBAoBD,CAlBC,0BALA,cAQA,CAMC,sEACC,aAMD,CAJC,+CAEC,iBACD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-icon {\n\tvertical-align: middle;\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-icon-size: calc(var(--ck-line-height-base) * var(--ck-font-size-normal));\n}\n\n.ck.ck-icon {\n\twidth: var(--ck-icon-size);\n\theight: var(--ck-icon-size);\n\n\t/* Multiplied by the height of the line in "px" should give SVG "viewport" dimensions */\n\tfont-size: .8333350694em;\n\n\t/* Inherit cursor style (#5). */\n\tcursor: inherit;\n\n\t/* This will prevent blurry icons on Firefox. See #340. */\n\twill-change: transform;\n\n\t& * {\n\t\t/* Inherit cursor style (#5). */\n\t\tcursor: inherit;\n\t}\n\n\t/* Allows dynamic coloring of an icon by inheriting its color from the parent. */\n\t&.ck-icon_inherit-color {\n\t\tcolor: inherit;\n\n\t\t& * {\n\t\t\tcolor: inherit;\n\n\t\t\t&:not([fill]) {\n\t\t\t\t/* Needed by FF. */\n\t\t\t\tfill: currentColor;\n\t\t\t}\n\t\t}\n\t}\n}\n',
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      470: (t, e, n) => {
        "use strict";
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ":root{--ck-input-width:18em;--ck-input-text-width:var(--ck-input-width)}.ck.ck-input{border-radius:0}.ck-rounded-corners .ck.ck-input,.ck.ck-input.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input{background:var(--ck-color-input-background);border:1px solid var(--ck-color-input-border);min-height:var(--ck-ui-component-min-height);min-width:var(--ck-input-width);padding:var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);transition:box-shadow .1s ease-in-out,border .1s ease-in-out}.ck.ck-input:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-input[readonly]{background:var(--ck-color-input-disabled-background);border:1px solid var(--ck-color-input-disabled-border);color:var(--ck-color-input-disabled-text)}.ck.ck-input[readonly]:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-input.ck-error{animation:ck-input-shake .3s ease both;border-color:var(--ck-color-input-error-border)}.ck.ck-input.ck-error:focus{box-shadow:var(--ck-focus-error-outer-shadow),0 0}@keyframes ck-input-shake{20%{transform:translateX(-2px)}40%{transform:translateX(2px)}60%{transform:translateX(-1px)}80%{transform:translateX(1px)}}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/input/input.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
            ],
            names: [],
            mappings:
              "AASA,MACC,qBAAsB,CAGtB,2CACD,CAEA,aCLC,eD2CD,CAtCA,iECDE,qCDuCF,CAtCA,aAGC,2CAA4C,CAC5C,6CAA8C,CAK9C,4CAA6C,CAH7C,+BAAgC,CADhC,6DAA8D,CAO9D,4DA0BD,CAxBC,mBEnBA,2BAA2B,CCF3B,2CAA8B,CDC9B,YFuBA,CAEA,uBAEC,oDAAqD,CADrD,sDAAuD,CAEvD,yCAMD,CAJC,6BG/BD,oDHkCC,CAGD,sBAEC,sCAAuC,CADvC,+CAMD,CAHC,4BGzCD,iDH2CC,CAIF,0BACC,IACC,0BACD,CAEA,IACC,yBACD,CAEA,IACC,0BACD,CAEA,IACC,yBACD,CACD",
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_focus.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-input-width: 18em;\n\n\t/* Backward compatibility. */\n\t--ck-input-text-width: var(--ck-input-width);\n}\n\n.ck.ck-input {\n\t@mixin ck-rounded-corners;\n\n\tbackground: var(--ck-color-input-background);\n\tborder: 1px solid var(--ck-color-input-border);\n\tpadding: var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);\n\tmin-width: var(--ck-input-width);\n\n\t/* This is important to stay of the same height as surrounding buttons */\n\tmin-height: var(--ck-ui-component-min-height);\n\n\t/* Apply some smooth transition to the box-shadow and border. */\n\ttransition: box-shadow .1s ease-in-out, border .1s ease-in-out;\n\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t}\n\n\t&[readonly] {\n\t\tborder: 1px solid var(--ck-color-input-disabled-border);\n\t\tbackground: var(--ck-color-input-disabled-background);\n\t\tcolor: var(--ck-color-input-disabled-text);\n\n\t\t&:focus {\n\t\t\t/* The read-only input should have a slightly less visible shadow when focused. */\n\t\t\t@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);\n\t\t}\n\t}\n\n\t&.ck-error {\n\t\tborder-color: var(--ck-color-input-error-border);\n\t\tanimation: ck-input-shake .3s ease both;\n\n\t\t&:focus {\n\t\t\t@mixin ck-box-shadow var(--ck-focus-error-outer-shadow);\n\t\t}\n\t}\n}\n\n@keyframes ck-input-shake {\n\t20% {\n\t\ttransform: translateX(-2px);\n\t}\n\n\t40% {\n\t\ttransform: translateX(2px);\n\t}\n\n\t60% {\n\t\ttransform: translateX(-1px);\n\t}\n\n\t80% {\n\t\ttransform: translateX(1px);\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      525: (t, e, n) => {
        "use strict";
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ".ck.ck-label{display:block}.ck.ck-voice-label{display:none}.ck.ck-label{font-weight:700}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/label/label.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/label/label.css",
            ],
            names: [],
            mappings: "AAKA,aACC,aACD,CAEA,mBACC,YACD,CCNA,aACC,eACD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n\tdisplay: block;\n}\n\n.ck.ck-voice-label {\n\tdisplay: none;\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n\tfont-weight: bold;\n}\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      933: (t, e, n) => {
        "use strict";
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ".ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{display:flex;position:relative}.ck.ck-labeled-field-view .ck.ck-label{display:block;position:absolute}:root{--ck-labeled-field-view-transition:.1s cubic-bezier(0,0,0.24,0.95);--ck-labeled-field-empty-unfocused-max-width:100% - 2 * var(--ck-spacing-medium);--ck-labeled-field-label-default-position-x:var(--ck-spacing-medium);--ck-labeled-field-label-default-position-y:calc(var(--ck-font-size-base)*0.6);--ck-color-labeled-field-label-background:var(--ck-color-base-background)}.ck.ck-labeled-field-view{border-radius:0}.ck-rounded-corners .ck.ck-labeled-field-view,.ck.ck-labeled-field-view.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{width:100%}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{top:0}[dir=ltr] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{left:0}[dir=rtl] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{right:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:var(--ck-color-labeled-field-label-background);font-weight:400;line-height:normal;max-width:100%;overflow:hidden;padding:0 calc(var(--ck-font-size-tiny)*.5);pointer-events:none;text-overflow:ellipsis;transform:translate(var(--ck-spacing-medium),-6px) scale(.75);transform-origin:0 0;transition:transform var(--ck-labeled-field-view-transition),padding var(--ck-labeled-field-view-transition),background var(--ck-labeled-field-view-transition)}.ck.ck-labeled-field-view.ck-error .ck-input:not([readonly])+.ck.ck-label,.ck.ck-labeled-field-view.ck-error>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view .ck-labeled-field-view__status{font-size:var(--ck-font-size-small);margin-top:var(--ck-spacing-small);white-space:normal}.ck.ck-labeled-field-view .ck-labeled-field-view__status.ck-labeled-field-view__status_error{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view.ck-disabled>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-input-disabled-text)}[dir=ltr] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=ltr] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(var(--ck-labeled-field-label-default-position-x),var(--ck-labeled-field-label-default-position-y)) scale(1)}[dir=rtl] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=rtl] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(calc(var(--ck-labeled-field-label-default-position-x)*-1),var(--ck-labeled-field-label-default-position-y)) scale(1)}.ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:transparent;max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width));padding:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck.ck-button{background:transparent}.ck.ck-labeled-field-view.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck-button>.ck-button__label{opacity:0}.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown+.ck-label{max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard))}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/labeledfield/labeledfieldview.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/labeledfield/labeledfieldview.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
            ],
            names: [],
            mappings:
              "AAMC,mEACC,YAAa,CACb,iBACD,CAEA,uCACC,aAAc,CACd,iBACD,CCND,MACC,kEAAsE,CACtE,gFAAiF,CACjF,oEAAqE,CACrE,8EAAiF,CACjF,yEACD,CAEA,0BCLC,eD8GD,CAzGA,2FCDE,qCD0GF,CAtGC,mEACC,UAmCD,CAjCC,gFACC,KA+BD,CAhCA,0FAIE,MA4BF,CAhCA,0FAQE,OAwBF,CAhCA,gFAiBC,yDAA0D,CAG1D,eAAmB,CADnB,kBAAoB,CAOpB,cAAe,CAFf,eAAgB,CANhB,2CAA8C,CAP9C,mBAAoB,CAYpB,sBAAuB,CARvB,6DAA+D,CAH/D,oBAAqB,CAgBrB,+JAID,CAQA,mKACC,gCACD,CAGD,yDACC,mCAAoC,CACpC,kCAAmC,CAInC,kBAKD,CAHC,6FACC,gCACD,CAID,4OAEC,yCACD,CAIA,oUAGE,+HAYF,CAfA,oUAOE,wIAQF,CAfA,gTAaC,sBAAuB,CAFvB,iEAAkE,CAGlE,SACD,CAKA,8FACC,sBACD,CAGA,yIACC,SACD,CAGA,kMACC,8HACD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-labeled-field-view {\n\t& > .ck.ck-labeled-field-view__input-wrapper {\n\t\tdisplay: flex;\n\t\tposition: relative;\n\t}\n\n\t& .ck.ck-label {\n\t\tdisplay: block;\n\t\tposition: absolute;\n\t}\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-labeled-field-view-transition: .1s cubic-bezier(0, 0, 0.24, 0.95);\n\t--ck-labeled-field-empty-unfocused-max-width: 100% - 2 * var(--ck-spacing-medium);\n\t--ck-labeled-field-label-default-position-x: var(--ck-spacing-medium);\n\t--ck-labeled-field-label-default-position-y: calc(0.6 * var(--ck-font-size-base));\n\t--ck-color-labeled-field-label-background: var(--ck-color-base-background);\n}\n\n.ck.ck-labeled-field-view {\n\t@mixin ck-rounded-corners;\n\n\t& > .ck.ck-labeled-field-view__input-wrapper {\n\t\twidth: 100%;\n\n\t\t& > .ck.ck-label {\n\t\t\ttop: 0px;\n\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tleft: 0px;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tright: 0px;\n\t\t\t}\n\n\t\t\tpointer-events: none;\n\t\t\ttransform-origin: 0 0;\n\n\t\t\t/* By default, display the label scaled down above the field. */\n\t\t\ttransform: translate(var(--ck-spacing-medium), -6px) scale(.75);\n\n\t\t\tbackground: var(--ck-color-labeled-field-label-background);\n\t\t\tpadding: 0 calc(.5 * var(--ck-font-size-tiny));\n\t\t\tline-height: initial;\n\t\t\tfont-weight: normal;\n\n\t\t\t/* Prevent overflow when the label is longer than the input */\n\t\t\ttext-overflow: ellipsis;\n\t\t\toverflow: hidden;\n\n\t\t\tmax-width: 100%;\n\n\t\t\ttransition:\n\t\t\t\ttransform var(--ck-labeled-field-view-transition),\n\t\t\t\tpadding var(--ck-labeled-field-view-transition),\n\t\t\t\tbackground var(--ck-labeled-field-view-transition);\n\t\t}\n\t}\n\n\t&.ck-error {\n\t\t& > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\n\t\t& .ck-input:not([readonly]) + .ck.ck-label {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\t}\n\n\t& .ck-labeled-field-view__status {\n\t\tfont-size: var(--ck-font-size-small);\n\t\tmargin-top: var(--ck-spacing-small);\n\n\t\t/* Let the info wrap to the next line to avoid stretching the layout horizontally.\n\t\tThe status could be very long. */\n\t\twhite-space: normal;\n\n\t\t&.ck-labeled-field-view__status_error {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\t}\n\n\t/* Disabled fields and fields that have no focus should fade out. */\n\t&.ck-disabled > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\tcolor: var(--ck-color-input-disabled-text);\n\t}\n\n\t/* Fields that are disabled or not focused and without a placeholder should have full-sized labels. */\n\t/* stylelint-disable-next-line no-descending-specificity */\n\t&.ck-disabled.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\t@mixin ck-dir ltr {\n\t\t\ttransform: translate(var(--ck-labeled-field-label-default-position-x), var(--ck-labeled-field-label-default-position-y)) scale(1);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\ttransform: translate(calc(-1 * var(--ck-labeled-field-label-default-position-x)), var(--ck-labeled-field-label-default-position-y)) scale(1);\n\t\t}\n\n\t\t/* Compensate for the default translate position. */\n\t\tmax-width: calc(var(--ck-labeled-field-empty-unfocused-max-width));\n\n\t\tbackground: transparent;\n\t\tpadding: 0;\n\t}\n\n\t/*------ DropdownView integration ----------------------------------------------------------------------------------- */\n\n\t/* Make sure dropdown\' background color in any of dropdown\'s state does not collide with labeled field. */\n\t& > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck.ck-button {\n\t\tbackground: transparent;\n\t}\n\n\t/* When the dropdown is "empty", the labeled field label replaces its label. */\n\t&.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck-button > .ck-button__label {\n\t\topacity: 0;\n\t}\n\n\t/* Make sure the label of the empty, unfocused input does not cover the dropdown arrow. */\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown + .ck-label {\n\t\tmax-width: calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard));\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      179: (t, e, n) => {
        "use strict";
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ".ck.ck-list{display:flex;flex-direction:column;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-list .ck-list__item,.ck.ck-list .ck-list__separator{display:block}.ck.ck-list .ck-list__item>:focus{position:relative;z-index:var(--ck-z-default)}.ck.ck-list{border-radius:0}.ck-rounded-corners .ck.ck-list,.ck.ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-list{background:var(--ck-color-list-background);list-style-type:none}.ck.ck-list__item{cursor:default;min-width:12em}.ck.ck-list__item .ck-button{border-radius:0;min-height:unset;padding:calc(var(--ck-line-height-base)*.2*var(--ck-font-size-base)) calc(var(--ck-line-height-base)*.4*var(--ck-font-size-base));text-align:left;width:100%}.ck.ck-list__item .ck-button .ck-button__label{line-height:calc(var(--ck-line-height-base)*1.2*var(--ck-font-size-base))}.ck.ck-list__item .ck-button:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on{background:var(--ck-color-list-button-on-background);color:var(--ck-color-list-button-on-text)}.ck.ck-list__item .ck-button.ck-on:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-on-background-focus)}.ck.ck-list__item .ck-button.ck-on:focus:not(.ck-switchbutton):not(.ck-disabled){border-color:var(--ck-color-base-background)}.ck.ck-list__item .ck-button:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background)}.ck.ck-list__item .ck-switchbutton.ck-on{background:var(--ck-color-list-background);color:inherit}.ck.ck-list__item .ck-switchbutton.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background);color:inherit}.ck-list .ck-list__group{padding-top:var(--ck-spacing-medium);:not(.ck-hidden)~&{border-top:1px solid var(--ck-color-base-border)}}.ck-list .ck-list__group>span{font-size:11px;font-weight:700;padding:var(--ck-spacing-medium)}.ck.ck-list__separator{background:var(--ck-color-base-border);height:1px;width:100%}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/list/list.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/list/list.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
            ],
            names: [],
            mappings:
              "AAOA,YAGC,YAAa,CACb,qBAAsB,CCFtB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBDaD,CAZC,2DAEC,aACD,CAKA,kCACC,iBAAkB,CAClB,2BACD,CEfD,YCEC,eDGD,CALA,+DCME,qCDDF,CALA,YAIC,0CAA2C,CAD3C,oBAED,CAEA,kBACC,cAAe,CACf,cA2DD,CAzDC,6BAIC,eAAgB,CAHhB,gBAAiB,CAQjB,iIAEiE,CARjE,eAAgB,CADhB,UAwCD,CA7BC,+CAEC,yEACD,CAEA,oCACC,eACD,CAEA,mCACC,oDAAqD,CACrD,yCAaD,CAXC,0CACC,eACD,CAEA,2DACC,0DACD,CAEA,iFACC,4CACD,CAGD,qDACC,uDACD,CAMA,yCACC,0CAA2C,CAC3C,aAMD,CAJC,iEACC,uDAAwD,CACxD,aACD,CAKH,yBACC,oCAAqC,CAGrC,mBACC,gDACD,CAOD,CALC,8BACC,cAAe,CACf,eAAiB,CACjB,gCACD,CAGD,uBAGC,sCAAuC,CAFvC,UAAW,CACX,UAED",
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-list {\n\t@mixin ck-unselectable;\n\n\tdisplay: flex;\n\tflex-direction: column;\n\n\t& .ck-list__item,\n\t& .ck-list__separator {\n\t\tdisplay: block;\n\t}\n\n\t/* Make sure that whatever child of the list item gets focus, it remains on the\n\ttop. Thanks to that, styles like box-shadow, outline, etc. are not masked by\n\tadjacent list items. */\n\t& .ck-list__item > *:focus {\n\t\tposition: relative;\n\t\tz-index: var(--ck-z-default);\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_shadow.css";\n\n.ck.ck-list {\n\t@mixin ck-rounded-corners;\n\n\tlist-style-type: none;\n\tbackground: var(--ck-color-list-background);\n}\n\n.ck.ck-list__item {\n\tcursor: default;\n\tmin-width: 12em;\n\n\t& .ck-button {\n\t\tmin-height: unset;\n\t\twidth: 100%;\n\t\ttext-align: left;\n\t\tborder-radius: 0;\n\n\t\t/* List items should have the same height. Use absolute units to make sure it is so\n\t\t   because e.g. different heading styles may have different height\n\t\t   https://github.com/ckeditor/ckeditor5-heading/issues/63 */\n\t\tpadding:\n\t\t\tcalc(.2 * var(--ck-line-height-base) * var(--ck-font-size-base))\n\t\t\tcalc(.4 * var(--ck-line-height-base) * var(--ck-font-size-base));\n\n\t\t& .ck-button__label {\n\t\t\t/* https://github.com/ckeditor/ckeditor5-heading/issues/63 */\n\t\t\tline-height: calc(1.2 * var(--ck-line-height-base) * var(--ck-font-size-base));\n\t\t}\n\n\t\t&:active {\n\t\t\tbox-shadow: none;\n\t\t}\n\n\t\t&.ck-on {\n\t\t\tbackground: var(--ck-color-list-button-on-background);\n\t\t\tcolor: var(--ck-color-list-button-on-text);\n\n\t\t\t&:active {\n\t\t\t\tbox-shadow: none;\n\t\t\t}\n\n\t\t\t&:hover:not(.ck-disabled) {\n\t\t\t\tbackground: var(--ck-color-list-button-on-background-focus);\n\t\t\t}\n\n\t\t\t&:focus:not(.ck-switchbutton):not(.ck-disabled) {\n\t\t\t\tborder-color: var(--ck-color-base-background);\n\t\t\t}\n\t\t}\n\n\t\t&:hover:not(.ck-disabled) {\n\t\t\tbackground: var(--ck-color-list-button-hover-background);\n\t\t}\n\t}\n\n\t/* It\'s unnecessary to change the background/text of a switch toggle; it has different ways\n\tof conveying its state (like the switcher) */\n\t& .ck-switchbutton {\n\t\t&.ck-on {\n\t\t\tbackground: var(--ck-color-list-background);\n\t\t\tcolor: inherit;\n\n\t\t\t&:hover:not(.ck-disabled) {\n\t\t\t\tbackground: var(--ck-color-list-button-hover-background);\n\t\t\t\tcolor: inherit;\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck-list .ck-list__group {\n\tpadding-top: var(--ck-spacing-medium);\n\n\t/* The group should have a border when it\'s not the first item. */\n\t*:not(.ck-hidden) ~ & {\n\t\tborder-top: 1px solid var(--ck-color-base-border);\n\t}\n\n\t& > span {\n\t\tfont-size: 11px;\n\t\tfont-weight: bold;\n\t\tpadding: var(--ck-spacing-medium);\n\t}\n}\n\n.ck.ck-list__separator {\n\theight: 1px;\n\twidth: 100%;\n\tbackground: var(--ck-color-base-border);\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      460: (t, e, n) => {
        "use strict";
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ':root{--ck-balloon-panel-arrow-z-index:calc(var(--ck-z-default) - 3)}.ck.ck-balloon-panel{display:none;position:absolute;z-index:var(--ck-z-modal)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{content:"";position:absolute}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_n]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_n]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_s]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_s]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel.ck-balloon-panel_visible{display:block}:root{--ck-balloon-border-width:1px;--ck-balloon-arrow-offset:2px;--ck-balloon-arrow-height:10px;--ck-balloon-arrow-half-width:8px;--ck-balloon-arrow-drop-shadow:0 2px 2px var(--ck-color-shadow-drop)}.ck.ck-balloon-panel{border-radius:0}.ck-rounded-corners .ck.ck-balloon-panel,.ck.ck-balloon-panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-balloon-panel{background:var(--ck-color-panel-background);border:var(--ck-balloon-border-width) solid var(--ck-color-panel-border);box-shadow:var(--ck-drop-shadow),0 0;min-height:15px}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{border-style:solid;height:0;width:0}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-width:0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_n]:before{border-color:transparent transparent var(--ck-color-panel-border) transparent;margin-top:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_n]:after{border-color:transparent transparent var(--ck-color-panel-background) transparent;margin-top:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-width:var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_s]:before{border-color:var(--ck-color-panel-border) transparent transparent;filter:drop-shadow(var(--ck-balloon-arrow-drop-shadow));margin-bottom:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_s]:after{border-color:var(--ck-color-panel-background) transparent transparent transparent;margin-bottom:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_e]:after,.ck.ck-balloon-panel[class*=arrow_e]:before{border-width:var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height)}.ck.ck-balloon-panel[class*=arrow_e]:before{border-color:transparent transparent transparent var(--ck-color-panel-border);margin-right:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_e]:after{border-color:transparent transparent transparent var(--ck-color-panel-background);margin-right:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_w]:after,.ck.ck-balloon-panel[class*=arrow_w]:before{border-width:var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0}.ck.ck-balloon-panel[class*=arrow_w]:before{border-color:transparent var(--ck-color-panel-border) transparent transparent;margin-left:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_w]:after{border-color:transparent var(--ck-color-panel-background) transparent transparent;margin-left:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:before{left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:before{right:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);right:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:before{margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%;top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:before{left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:before{margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);right:calc(var(--ck-balloon-arrow-height)*-1);top:50%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:before{left:calc(var(--ck-balloon-arrow-height)*-1);margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);top:50%}',
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonpanel.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonpanel.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
            ],
            names: [],
            mappings:
              "AAKA,MAEC,8DACD,CAEA,qBACC,YAAa,CACb,iBAAkB,CAElB,yBAyCD,CAtCE,+GAEC,UAAW,CACX,iBACD,CAEA,wDACC,6CACD,CAEA,uDACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAGD,8CACC,aACD,CC9CD,MACC,6BAA8B,CAC9B,6BAA8B,CAC9B,8BAA+B,CAC/B,iCAAkC,CAClC,oEACD,CAEA,qBCLC,eDmMD,CA9LA,iFCDE,qCD+LF,CA9LA,qBAMC,2CAA4C,CAC5C,wEAAyE,CEdzE,oCAA8B,CFW9B,eA0LD,CApLE,+GAIC,kBAAmB,CADnB,QAAS,CADT,OAGD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,kDACD,CAEA,2CACC,iFAAkF,CAClF,gFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,iEAAkE,CAClE,uDAAwD,CACxD,qDACD,CAEA,2CACC,iFAAkF,CAClF,mFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,oDACD,CAEA,2CACC,iFAAkF,CAClF,kFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,mDACD,CAEA,2CACC,iFAAkF,CAClF,iFACD,CAIA,yGAEC,QAAS,CACT,uDAA0D,CAC1D,2CACD,CAIA,2GAEC,+CAAkD,CAClD,2CACD,CAIA,2GAEC,gDAAmD,CACnD,2CACD,CAIA,yGAIC,8CAAiD,CAFjD,QAAS,CACT,uDAED,CAIA,2GAGC,8CAAiD,CADjD,+CAED,CAIA,2GAGC,8CAAiD,CADjD,gDAED,CAIA,6GAIC,8CAAiD,CADjD,uDAA0D,CAD1D,SAGD,CAIA,6GAIC,8CAAiD,CAFjD,QAAS,CACT,sDAED,CAIA,6GAGC,uDAA0D,CAD1D,SAAU,CAEV,2CACD,CAIA,6GAEC,QAAS,CACT,sDAAyD,CACzD,2CACD,CAIA,yGAGC,sDAAyD,CADzD,6CAAgD,CAEhD,OACD,CAIA,yGAEC,4CAA+C,CAC/C,sDAAyD,CACzD,OACD",
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/* Make sure the balloon arrow does not float over its children. */\n\t--ck-balloon-panel-arrow-z-index: calc(var(--ck-z-default) - 3);\n}\n\n.ck.ck-balloon-panel {\n\tdisplay: none;\n\tposition: absolute;\n\n\tz-index: var(--ck-z-modal);\n\n\t&.ck-balloon-panel_with-arrow {\n\t\t&::before,\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\tposition: absolute;\n\t\t}\n\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&[class*="arrow_n"] {\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&[class*="arrow_s"] {\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_visible {\n\t\tdisplay: block;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-balloon-border-width: 1px;\n\t--ck-balloon-arrow-offset: 2px;\n\t--ck-balloon-arrow-height: 10px;\n\t--ck-balloon-arrow-half-width: 8px;\n\t--ck-balloon-arrow-drop-shadow: 0 2px 2px var(--ck-color-shadow-drop);\n}\n\n.ck.ck-balloon-panel {\n\t@mixin ck-rounded-corners;\n\t@mixin ck-drop-shadow;\n\n\tmin-height: 15px;\n\n\tbackground: var(--ck-color-panel-background);\n\tborder: var(--ck-balloon-border-width) solid var(--ck-color-panel-border);\n\n\t&.ck-balloon-panel_with-arrow {\n\t\t&::before,\n\t\t&::after {\n\t\t\twidth: 0;\n\t\t\theight: 0;\n\t\t\tborder-style: solid;\n\t\t}\n\t}\n\n\t&[class*="arrow_n"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent transparent var(--ck-color-panel-border) transparent;\n\t\t\tmargin-top: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent transparent var(--ck-color-panel-background) transparent;\n\t\t\tmargin-top: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&[class*="arrow_s"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: var(--ck-color-panel-border) transparent transparent;\n\t\t\tfilter: drop-shadow(var(--ck-balloon-arrow-drop-shadow));\n\t\t\tmargin-bottom: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: var(--ck-color-panel-background) transparent transparent transparent;\n\t\t\tmargin-bottom: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&[class*="arrow_e"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent transparent transparent var(--ck-color-panel-border);\n\t\t\tmargin-right: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent transparent transparent var(--ck-color-panel-background);\n\t\t\tmargin-right: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&[class*="arrow_w"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0;\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent var(--ck-color-panel-border) transparent transparent;\n\t\t\tmargin-left: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent var(--ck-color-panel-background) transparent transparent;\n\t\t\tmargin-left: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_n {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 50%;\n\t\t\tmargin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_ne {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_s {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 50%;\n\t\t\tmargin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_sw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_se {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_sme {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: 25%;\n\t\t\tmargin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_smw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 25%;\n\t\t\tmargin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nme {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: 25%;\n\t\t\tmargin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nmw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 25%;\n\t\t\tmargin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_e {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t\tmargin-top: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: 50%;\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_w {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t\tmargin-top: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: 50%;\n\t\t}\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      592: (t, e, n) => {
        "use strict";
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ".ck .ck-balloon-rotator__navigation{align-items:center;display:flex;justify-content:center}.ck .ck-balloon-rotator__content .ck-toolbar{justify-content:center}.ck .ck-balloon-rotator__navigation{background:var(--ck-color-toolbar-background);border-bottom:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation>*{margin-bottom:var(--ck-spacing-small);margin-right:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation .ck-balloon-rotator__counter{margin-left:var(--ck-spacing-small);margin-right:var(--ck-spacing-standard)}.ck .ck-balloon-rotator__content .ck.ck-annotation-wrapper{box-shadow:none}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonrotator.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonrotator.css",
            ],
            names: [],
            mappings:
              "AAKA,oCAEC,kBAAmB,CADnB,YAAa,CAEb,sBACD,CAKA,6CACC,sBACD,CCXA,oCACC,6CAA8C,CAC9C,sDAAuD,CACvD,iCAgBD,CAbC,sCAGC,qCAAsC,CAFtC,oCAAqC,CACrC,kCAED,CAGA,iEAIC,mCAAoC,CAHpC,uCAID,CAMA,2DACC,eACD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n}\n\n/* Buttons inside a toolbar should be centered when rotator bar is wider.\n * See: https://github.com/ckeditor/ckeditor5-ui/issues/495\n */\n.ck .ck-balloon-rotator__content .ck-toolbar {\n\tjustify-content: center;\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n\tbackground: var(--ck-color-toolbar-background);\n\tborder-bottom: 1px solid var(--ck-color-toolbar-border);\n\tpadding: 0 var(--ck-spacing-small);\n\n\t/* Let's keep similar appearance to `ck-toolbar`. */\n\t& > * {\n\t\tmargin-right: var(--ck-spacing-small);\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t/* Gives counter more breath than buttons. */\n\t& .ck-balloon-rotator__counter {\n\t\tmargin-right: var(--ck-spacing-standard);\n\n\t\t/* We need to use smaller margin because of previous button's right margin. */\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n}\n\n.ck .ck-balloon-rotator__content {\n\n\t/* Disable default annotation shadow inside rotator with fake panels. */\n\t& .ck.ck-annotation-wrapper {\n\t\tbox-shadow: none;\n\t}\n}\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      356: (t, e, n) => {
        "use strict";
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ".ck .ck-fake-panel{position:absolute;z-index:calc(var(--ck-z-modal) - 1)}.ck .ck-fake-panel div{position:absolute}.ck .ck-fake-panel div:first-child{z-index:2}.ck .ck-fake-panel div:nth-child(2){z-index:1}:root{--ck-balloon-fake-panel-offset-horizontal:6px;--ck-balloon-fake-panel-offset-vertical:6px}.ck .ck-fake-panel div{background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border);border-radius:var(--ck-border-radius);box-shadow:var(--ck-drop-shadow),0 0;height:100%;min-height:15px;width:100%}.ck .ck-fake-panel div:first-child{margin-left:var(--ck-balloon-fake-panel-offset-horizontal);margin-top:var(--ck-balloon-fake-panel-offset-vertical)}.ck .ck-fake-panel div:nth-child(2){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*2);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*2)}.ck .ck-fake-panel div:nth-child(3){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*3);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*3)}.ck .ck-balloon-panel_arrow_s+.ck-fake-panel,.ck .ck-balloon-panel_arrow_se+.ck-fake-panel,.ck .ck-balloon-panel_arrow_sw+.ck-fake-panel{--ck-balloon-fake-panel-offset-vertical:-6px}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/fakepanel.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/fakepanel.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
            ],
            names: [],
            mappings:
              "AAKA,mBACC,iBAAkB,CAGlB,mCACD,CAEA,uBACC,iBACD,CAEA,mCACC,SACD,CAEA,oCACC,SACD,CCfA,MACC,6CAA8C,CAC9C,2CACD,CAGA,uBAKC,2CAA4C,CAC5C,6CAA8C,CAC9C,qCAAsC,CCXtC,oCAA8B,CDc9B,WAAY,CAPZ,eAAgB,CAMhB,UAED,CAEA,mCACC,0DAA2D,CAC3D,uDACD,CAEA,oCACC,kEAAqE,CACrE,+DACD,CACA,oCACC,kEAAqE,CACrE,+DACD,CAGA,yIAGC,4CACD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-fake-panel {\n\tposition: absolute;\n\n\t/* Fake panels should be placed under main balloon content. */\n\tz-index: calc(var(--ck-z-modal) - 1);\n}\n\n.ck .ck-fake-panel div {\n\tposition: absolute;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n\tz-index: 2;\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n\tz-index: 1;\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-balloon-fake-panel-offset-horizontal: 6px;\n\t--ck-balloon-fake-panel-offset-vertical: 6px;\n}\n\n/* Let\'s use `.ck-balloon-panel` appearance. See: balloonpanel.css. */\n.ck .ck-fake-panel div {\n\t@mixin ck-drop-shadow;\n\n\tmin-height: 15px;\n\n\tbackground: var(--ck-color-panel-background);\n\tborder: 1px solid var(--ck-color-panel-border);\n\tborder-radius: var(--ck-border-radius);\n\n\twidth: 100%;\n\theight: 100%;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n\tmargin-left: var(--ck-balloon-fake-panel-offset-horizontal);\n\tmargin-top: var(--ck-balloon-fake-panel-offset-vertical);\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n\tmargin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 2);\n\tmargin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 2);\n}\n.ck .ck-fake-panel div:nth-child( 3 ) {\n\tmargin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 3);\n\tmargin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 3);\n}\n\n/* If balloon is positioned above element, we need to move fake panel to the top. */\n.ck .ck-balloon-panel_arrow_s + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_se + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_sw + .ck-fake-panel {\n\t--ck-balloon-fake-panel-offset-vertical: -6px;\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      707: (t, e, n) => {
        "use strict";
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ".ck.ck-sticky-panel .ck-sticky-panel__content_sticky{position:fixed;top:0;z-index:var(--ck-z-modal)}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky_bottom-limit{position:absolute;top:auto}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky{border-top-left-radius:0;border-top-right-radius:0;border-width:0 1px 1px;box-shadow:var(--ck-drop-shadow),0 0}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/stickypanel.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/stickypanel.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
            ],
            names: [],
            mappings:
              "AAMC,qDAEC,cAAe,CACf,KAAM,CAFN,yBAGD,CAEA,kEAEC,iBAAkB,CADlB,QAED,CCPA,qDAIC,wBAAyB,CACzB,yBAA0B,CAF1B,sBAAuB,CCFxB,oCDKA",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-sticky-panel {\n\t& .ck-sticky-panel__content_sticky {\n\t\tz-index: var(--ck-z-modal); /* #315 */\n\t\tposition: fixed;\n\t\ttop: 0;\n\t}\n\n\t& .ck-sticky-panel__content_sticky_bottom-limit {\n\t\ttop: auto;\n\t\tposition: absolute;\n\t}\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n.ck.ck-sticky-panel {\n\t& .ck-sticky-panel__content_sticky {\n\t\t@mixin ck-drop-shadow;\n\n\t\tborder-width: 0 1px 1px;\n\t\tborder-top-left-radius: 0;\n\t\tborder-top-right-radius: 0;\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      332: (t, e, n) => {
        "use strict";
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ".ck.ck-search>.ck-labeled-field-view>.ck-labeled-field-view__input-wrapper>.ck-icon{position:absolute;top:50%;transform:translateY(-50%)}[dir=ltr] .ck.ck-search>.ck-labeled-field-view>.ck-labeled-field-view__input-wrapper>.ck-icon{left:var(--ck-spacing-medium)}[dir=rtl] .ck.ck-search>.ck-labeled-field-view>.ck-labeled-field-view__input-wrapper>.ck-icon{right:var(--ck-spacing-medium)}.ck.ck-search>.ck-labeled-field-view .ck-search__reset{position:absolute;top:50%;transform:translateY(-50%)}.ck.ck-search>.ck-search__results>.ck-search__info>span:first-child{display:block}.ck.ck-search>.ck-search__results>.ck-search__info:not(.ck-hidden)~*{display:none}:root{--ck-search-field-view-horizontal-spacing:calc(var(--ck-icon-size) + var(--ck-spacing-medium))}.ck.ck-search>.ck-labeled-field-view .ck-input{width:100%}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-icon{--ck-labeled-field-label-default-position-x:var(--ck-search-field-view-horizontal-spacing)}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-icon>.ck-labeled-field-view__input-wrapper>.ck-icon{opacity:.5;pointer-events:none}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-icon .ck-input{width:100%}[dir=ltr] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-icon .ck-input,[dir=rtl] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-icon .ck-input:not(.ck-input-text_empty){padding-left:var(--ck-search-field-view-horizontal-spacing)}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset{--ck-labeled-field-empty-unfocused-max-width:100% - 2 * var(--ck-search-field-view-horizontal-spacing)}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset.ck-labeled-field-view_empty{--ck-labeled-field-empty-unfocused-max-width:100% - var(--ck-search-field-view-horizontal-spacing) - var(--ck-spacing-medium)}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-search__reset{background:none;min-height:auto;min-width:auto;opacity:.5;padding:0}[dir=ltr] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-search__reset{right:var(--ck-spacing-medium)}[dir=rtl] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-search__reset{left:var(--ck-spacing-medium)}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-search__reset:hover{opacity:1}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-input{width:100%}[dir=ltr] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-input:not(.ck-input-text_empty),[dir=rtl] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-input{padding-right:var(--ck-search-field-view-horizontal-spacing)}.ck.ck-search>.ck-search__results{min-width:100%}.ck.ck-search>.ck-search__results>.ck-search__info{padding:var(--ck-spacing-medium) var(--ck-spacing-large);width:100%}.ck.ck-search>.ck-search__results>.ck-search__info *{white-space:normal}.ck.ck-search>.ck-search__results>.ck-search__info>span:first-child{font-weight:700}.ck.ck-search>.ck-search__results>.ck-search__info>span:last-child{margin-top:var(--ck-spacing-medium)}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/search/search.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/search/search.css",
            ],
            names: [],
            mappings:
              "AASE,oFACC,iBAAkB,CAClB,OAAQ,CACR,0BASD,CAZA,8FAME,6BAMF,CAZA,8FAUE,8BAEF,CAEA,uDACC,iBAAkB,CAClB,OAAQ,CACR,0BACD,CAKC,oEACC,aACD,CAGA,qEACC,YACD,CChCH,MACC,8FACD,CAIE,+CACC,UACD,CAEA,gEACC,0FAoBD,CAlBC,+GACC,UAAW,CACX,mBACD,CAEA,0EACC,UAWD,CAJE,kMACC,2DACD,CAKH,iEACC,sGAwCD,CAtCC,6FACC,6HACD,CAEA,mFAIC,eAAgB,CAFhB,eAAgB,CADhB,cAAe,CAIf,UAAW,CACX,SAaD,CAnBA,6FASE,8BAUF,CAnBA,6FAaE,6BAMF,CAHC,yFACC,SACD,CAGD,2EACC,UAWD,CAZA,oMAUE,4DAEF,CAIF,kCACC,cAkBD,CAhBC,mDAEC,wDAAyD,CADzD,UAcD,CAXC,qDACC,kBACD,CAEA,oEACC,eACD,CAEA,mEACC,mCACD",
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-search {\n\t& > .ck-labeled-field-view {\n\t\t& > .ck-labeled-field-view__input-wrapper > .ck-icon {\n\t\t\tposition: absolute;\n\t\t\ttop: 50%;\n\t\t\ttransform: translateY(-50%);\n\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tleft: var(--ck-spacing-medium);\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tright: var(--ck-spacing-medium);\n\t\t\t}\n\t\t}\n\n\t\t& .ck-search__reset {\n\t\t\tposition: absolute;\n\t\t\ttop: 50%;\n\t\t\ttransform: translateY(-50%);\n\t\t}\n\t}\n\n\t& > .ck-search__results {\n\t\t& > .ck-search__info {\n\t\t\t& > span:first-child {\n\t\t\t\tdisplay: block;\n\t\t\t}\n\n\t\t\t/* Hide the filtered view when nothing was found */\n\t\t\t&:not(.ck-hidden) ~ * {\n\t\t\t\tdisplay: none;\n\t\t\t}\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n:root {\n\t--ck-search-field-view-horizontal-spacing: calc(var(--ck-icon-size) + var(--ck-spacing-medium));\n}\n\n.ck.ck-search {\n\t& > .ck-labeled-field-view {\n\t\t& .ck-input {\n\t\t\twidth: 100%;\n\t\t}\n\n\t\t&.ck-search__query_with-icon {\n\t\t\t--ck-labeled-field-label-default-position-x: var(--ck-search-field-view-horizontal-spacing);\n\n\t\t\t& > .ck-labeled-field-view__input-wrapper > .ck-icon {\n\t\t\t\topacity: .5;\n\t\t\t\tpointer-events: none;\n\t\t\t}\n\n\t\t\t& .ck-input {\n\t\t\t\twidth: 100%;\n\n\t\t\t\t@mixin ck-dir ltr {\n\t\t\t\t\tpadding-left: var(--ck-search-field-view-horizontal-spacing);\n\t\t\t\t}\n\n\t\t\t\t@mixin ck-dir rtl {\n\t\t\t\t\t&:not(.ck-input-text_empty) {\n\t\t\t\t\t\tpadding-left: var(--ck-search-field-view-horizontal-spacing);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t&.ck-search__query_with-reset {\n\t\t\t--ck-labeled-field-empty-unfocused-max-width: 100% - 2 * var(--ck-search-field-view-horizontal-spacing);\n\n\t\t\t&.ck-labeled-field-view_empty {\n\t\t\t\t--ck-labeled-field-empty-unfocused-max-width: 100% - var(--ck-search-field-view-horizontal-spacing) - var(--ck-spacing-medium);\n\t\t\t}\n\n\t\t\t& .ck-search__reset {\n\t\t\t\tmin-width: auto;\n\t\t\t\tmin-height: auto;\n\n\t\t\t\tbackground: none;\n\t\t\t\topacity: .5;\n\t\t\t\tpadding: 0;\n\n\t\t\t\t@mixin ck-dir ltr {\n\t\t\t\t\tright: var(--ck-spacing-medium);\n\t\t\t\t}\n\n\t\t\t\t@mixin ck-dir rtl {\n\t\t\t\t\tleft: var(--ck-spacing-medium);\n\t\t\t\t}\n\n\t\t\t\t&:hover {\n\t\t\t\t\topacity: 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t& .ck-input {\n\t\t\t\twidth: 100%;\n\n\t\t\t\t@mixin ck-dir ltr {\n\t\t\t\t\t&:not(.ck-input-text_empty) {\n\t\t\t\t\t\tpadding-right: var(--ck-search-field-view-horizontal-spacing);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t@mixin ck-dir rtl {\n\t\t\t\t\tpadding-right: var(--ck-search-field-view-horizontal-spacing);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t& > .ck-search__results {\n\t\tmin-width: 100%;\n\n\t\t& > .ck-search__info {\n\t\t\twidth: 100%;\n\t\t\tpadding: var(--ck-spacing-medium) var(--ck-spacing-large);\n\n\t\t\t& * {\n\t\t\t\twhite-space: normal;\n\t\t\t}\n\n\t\t\t& > span:first-child {\n\t\t\t\tfont-weight: bold;\n\t\t\t}\n\n\t\t\t& > span:last-child {\n\t\t\t\tmargin-top: var(--ck-spacing-medium);\n\t\t\t}\n\t\t}\n\t}\n}\n\n',
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      446: (t, e, n) => {
        "use strict";
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ".ck.ck-spinner-container{display:block;position:relative}.ck.ck-spinner{left:0;margin:0 auto;position:absolute;right:0;top:50%;transform:translateY(-50%);z-index:1}:root{--ck-toolbar-spinner-size:18px}.ck.ck-spinner-container{animation:rotate 1.5s linear infinite}.ck.ck-spinner,.ck.ck-spinner-container{height:var(--ck-toolbar-spinner-size);width:var(--ck-toolbar-spinner-size)}.ck.ck-spinner{border:2px solid var(--ck-color-text);border-radius:50%;border-top:2px solid transparent}@keyframes rotate{to{transform:rotate(1turn)}}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/spinner/spinner.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/spinner/spinner.css",
            ],
            names: [],
            mappings:
              "AASA,yBACC,aAAc,CACd,iBACD,CAEA,eAGC,MAAO,CAEP,aAAc,CAJd,iBAAkB,CAGlB,OAAQ,CAFR,OAAQ,CAIR,0BAA2B,CAC3B,SACD,CCjBA,MACC,8BACD,CAEA,yBAGC,qCACD,CAEA,wCAJC,qCAAsC,CADtC,oCAWD,CANA,eAKC,qCAA6B,CAF7B,iBAAkB,CAElB,gCACD,CAEA,kBACC,GACC,uBACD,CACD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-toolbar-spinner-size: 18px;\n}\n\n.ck.ck-spinner-container {\n\tdisplay: block;\n\tposition: relative;\n}\n\n.ck.ck-spinner {\n\tposition: absolute;\n\ttop: 50%;\n\tleft: 0;\n\tright: 0;\n\tmargin: 0 auto;\n\ttransform: translateY(-50%);\n\tz-index: 1;\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-toolbar-spinner-size: 18px;\n}\n\n.ck.ck-spinner-container {\n\twidth: var(--ck-toolbar-spinner-size);\n\theight: var(--ck-toolbar-spinner-size);\n\tanimation: 1.5s infinite rotate linear;\n}\n\n.ck.ck-spinner {\n\twidth: var(--ck-toolbar-spinner-size);\n\theight: var(--ck-toolbar-spinner-size);\n\tborder-radius: 50%;\n\tborder: 2px solid var(--ck-color-text);\n\tborder-top-color: transparent;\n}\n\n@keyframes rotate {\n\tto {\n\t\ttransform: rotate(360deg)\n\t}\n}\n\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      224: (t, e, n) => {
        "use strict";
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ".ck-textarea{overflow-x:hidden}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/textarea/textarea.css",
            ],
            names: [],
            mappings: "AASA,aACC,iBACD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/*\n * This fixes a problem in Firefox when the initial height of the complement does not match the number of rows.\n * This bug is especially visible when rows=1.\n */\n.ck-textarea {\n\toverflow-x: hidden\n}\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      176: (t, e, n) => {
        "use strict";
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ".ck.ck-block-toolbar-button{position:absolute;z-index:var(--ck-z-default)}:root{--ck-color-block-toolbar-button:var(--ck-color-text);--ck-block-toolbar-button-size:var(--ck-font-size-normal)}.ck.ck-block-toolbar-button{color:var(--ck-color-block-toolbar-button);font-size:var(--ck-block-toolbar-size)}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/toolbar/blocktoolbar.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/blocktoolbar.css",
            ],
            names: [],
            mappings:
              "AAKA,4BACC,iBAAkB,CAClB,2BACD,CCHA,MACC,oDAAqD,CACrD,yDACD,CAEA,4BACC,0CAA2C,CAC3C,sCACD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-block-toolbar-button {\n\tposition: absolute;\n\tz-index: var(--ck-z-default);\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-block-toolbar-button: var(--ck-color-text);\n\t--ck-block-toolbar-button-size: var(--ck-font-size-normal);\n}\n\n.ck.ck-block-toolbar-button {\n\tcolor: var(--ck-color-block-toolbar-button);\n\tfont-size: var(--ck-block-toolbar-size);\n}\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      768: (t, e, n) => {
        "use strict";
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ".ck.ck-toolbar{align-items:center;display:flex;flex-flow:row nowrap;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-toolbar>.ck-toolbar__items{align-items:center;display:flex;flex-flow:row wrap;flex-grow:1}.ck.ck-toolbar .ck.ck-toolbar__separator{display:inline-block}.ck.ck-toolbar .ck.ck-toolbar__separator:first-child,.ck.ck-toolbar .ck.ck-toolbar__separator:last-child{display:none}.ck.ck-toolbar .ck-toolbar__line-break{flex-basis:100%}.ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items{flex-direction:column}.ck.ck-toolbar.ck-toolbar_floating>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck-dropdown__button .ck-dropdown__arrow{display:none}.ck.ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-toolbar,.ck.ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-toolbar{background:var(--ck-color-toolbar-background);border:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck.ck-toolbar .ck.ck-toolbar__separator{align-self:stretch;background:var(--ck-color-toolbar-border);margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small);min-width:1px;width:1px}.ck.ck-toolbar .ck-toolbar__line-break{height:0}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break){margin-right:var(--ck-spacing-small)}.ck.ck-toolbar>.ck-toolbar__items:empty+.ck.ck-toolbar__separator{display:none}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break),.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown{margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck.ck-toolbar.ck-toolbar_vertical{padding:0}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items>.ck{border-radius:0;margin:0;width:100%}.ck.ck-toolbar.ck-toolbar_compact{padding:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>*{margin:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>:not(:first-child):not(:last-child){border-radius:0}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck.ck-button.ck-dropdown__button{padding-left:var(--ck-spacing-tiny)}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-dropdown__panel{min-width:auto}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-button>.ck-button__label{max-width:7em;width:auto}.ck.ck-toolbar:focus{outline:none}.ck-toolbar-container .ck.ck-toolbar{border:0}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck{margin-right:0}.ck.ck-toolbar[dir=rtl]:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-left:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:first-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=rtl]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=rtl]>.ck.ck-toolbar__separator,[dir=rtl] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=rtl] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-right:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:first-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=ltr]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=ltr]>.ck.ck-toolbar__separator,[dir=ltr] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=ltr] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-right:var(--ck-spacing-small)}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/toolbar/toolbar.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/toolbar.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
            ],
            names: [],
            mappings:
              "AAOA,eAKC,kBAAmB,CAFnB,YAAa,CACb,oBAAqB,CCFrB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBD6CD,CA3CC,kCAGC,kBAAmB,CAFnB,YAAa,CACb,kBAAmB,CAEnB,WAED,CAEA,yCACC,oBAWD,CAJC,yGAEC,YACD,CAGD,uCACC,eACD,CAEA,sDACC,gBACD,CAEA,sDACC,qBACD,CAEA,sDACC,gBACD,CAGC,yFACC,YACD,CE/CF,eCGC,eDwGD,CA3GA,qECOE,qCDoGF,CA3GA,eAGC,6CAA8C,CAE9C,+CAAgD,CADhD,iCAuGD,CApGC,yCACC,kBAAmB,CAGnB,yCAA0C,CAO1C,qCAAsC,CADtC,kCAAmC,CAPnC,aAAc,CADd,SAUD,CAEA,uCACC,QACD,CAGC,gEAEC,oCACD,CAIA,kEACC,YACD,CAGD,gHAIC,qCAAsC,CADtC,kCAED,CAEA,mCAEC,SAaD,CAVC,0DAQC,eAAgB,CAHhB,QAAS,CAHT,UAOD,CAGD,kCAEC,SAWD,CATC,uDAEC,QAMD,CAHC,yFACC,eACD,CASD,kFACC,mCACD,CAMA,wEACC,cACD,CAEA,iFACC,aAAc,CACd,UACD,CAGD,qBACC,YACD,CAtGD,qCAyGE,QAEF,CAYC,+FACC,cACD,CAEA,iJAEC,mCACD,CAEA,qHACC,aACD,CAIC,6JAEC,2BAA4B,CAD5B,wBAED,CAGA,2JAEC,4BAA6B,CAD7B,yBAED,CASD,8RACC,mCACD,CAWA,qHACC,cACD,CAIC,6JAEC,4BAA6B,CAD7B,yBAED,CAGA,2JAEC,2BAA4B,CAD5B,wBAED,CASD,8RACC,oCACD",
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-toolbar {\n\t@mixin ck-unselectable;\n\n\tdisplay: flex;\n\tflex-flow: row nowrap;\n\talign-items: center;\n\n\t& > .ck-toolbar__items {\n\t\tdisplay: flex;\n\t\tflex-flow: row wrap;\n\t\talign-items: center;\n\t\tflex-grow: 1;\n\n\t}\n\n\t& .ck.ck-toolbar__separator {\n\t\tdisplay: inline-block;\n\n\t\t/*\n\t\t * A leading or trailing separator makes no sense (separates from nothing on one side).\n\t\t * For instance, it can happen when toolbar items (also separators) are getting grouped one by one and\n\t\t * moved to another toolbar in the dropdown.\n\t\t */\n\t\t&:first-child,\n\t\t&:last-child {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t& .ck-toolbar__line-break {\n\t\tflex-basis: 100%;\n\t}\n\n\t&.ck-toolbar_grouping > .ck-toolbar__items {\n\t\tflex-wrap: nowrap;\n\t}\n\n\t&.ck-toolbar_vertical > .ck-toolbar__items {\n\t\tflex-direction: column;\n\t}\n\n\t&.ck-toolbar_floating > .ck-toolbar__items {\n\t\tflex-wrap: nowrap;\n\t}\n\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t& > .ck-dropdown__button .ck-dropdown__arrow {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-toolbar {\n\t@mixin ck-rounded-corners;\n\n\tbackground: var(--ck-color-toolbar-background);\n\tpadding: 0 var(--ck-spacing-small);\n\tborder: 1px solid var(--ck-color-toolbar-border);\n\n\t& .ck.ck-toolbar__separator {\n\t\talign-self: stretch;\n\t\twidth: 1px;\n\t\tmin-width: 1px;\n\t\tbackground: var(--ck-color-toolbar-border);\n\n\t\t/*\n\t\t * These margins make the separators look better in balloon toolbars (when aligned with the "tip").\n\t\t * See https://github.com/ckeditor/ckeditor5/issues/7493.\n\t\t */\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t& .ck-toolbar__line-break {\n\t\theight: 0;\n\t}\n\n\t& > .ck-toolbar__items {\n\t\t& > *:not(.ck-toolbar__line-break) {\n\t\t\t/* (#11) Separate toolbar items. */\n\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t}\n\n\t\t/* Don\'t display a separator after an empty items container, for instance,\n\t\twhen all items were grouped */\n\t\t&:empty + .ck.ck-toolbar__separator {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t& > .ck-toolbar__items > *:not(.ck-toolbar__line-break),\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t/* Make sure items wrapped to the next line have v-spacing */\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t&.ck-toolbar_vertical {\n\t\t/* Items in a vertical toolbar span the entire width. */\n\t\tpadding: 0;\n\n\t\t/* Specificity matters here. See https://github.com/ckeditor/ckeditor5-theme-lark/issues/168. */\n\t\t& > .ck-toolbar__items > .ck {\n\t\t\t/* Items in a vertical toolbar should span the horizontal space. */\n\t\t\twidth: 100%;\n\n\t\t\t/* Items in a vertical toolbar should have no margin. */\n\t\t\tmargin: 0;\n\n\t\t\t/* Items in a vertical toolbar span the entire width so rounded corners are pointless. */\n\t\t\tborder-radius: 0;\n\t\t}\n\t}\n\n\t&.ck-toolbar_compact {\n\t\t/* No spacing around items. */\n\t\tpadding: 0;\n\n\t\t& > .ck-toolbar__items > * {\n\t\t\t/* Compact toolbar items have no spacing between them. */\n\t\t\tmargin: 0;\n\n\t\t\t/* "Middle" children should have no rounded corners. */\n\t\t\t&:not(:first-child):not(:last-child) {\n\t\t\t\tborder-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t/*\n\t\t * Dropdown button has asymmetric padding to fit the arrow.\n\t\t * This button has no arrow so let\'s revert that padding back to normal.\n\t\t */\n\t\t& > .ck.ck-button.ck-dropdown__button {\n\t\t\tpadding-left: var(--ck-spacing-tiny);\n\t\t}\n\t}\n\n\t/* A drop-down containing the nested toolbar with configured items. */\n\t& .ck-toolbar__nested-toolbar-dropdown {\n\t\t/* Prevent empty space in the panel when the dropdown label is visible and long but the toolbar has few items. */\n\t\t& > .ck-dropdown__panel {\n\t\t\tmin-width: auto;\n\t\t}\n\n\t\t& > .ck-button > .ck-button__label {\n\t\t\tmax-width: 7em;\n\t\t\twidth: auto;\n\t\t}\n\t}\n\n\t&:focus {\n\t\toutline: none;\n\t}\n\n\t@nest .ck-toolbar-container & {\n\t\tborder: 0;\n\t}\n}\n\n/* stylelint-disable */\n\n/*\n * Styles for RTL toolbars.\n *\n * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"\n * because its parent is not controlled by the editor framework.\n */\n[dir="rtl"] .ck.ck-toolbar,\n.ck.ck-toolbar[dir="rtl"] {\n\t& > .ck-toolbar__items > .ck {\n\t\tmargin-right: 0;\n\t}\n\n\t&:not(.ck-toolbar_compact) > .ck-toolbar__items > .ck {\n\t\t/* (#11) Separate toolbar items. */\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n\n\t& > .ck-toolbar__items > .ck:last-child {\n\t\tmargin-left: 0;\n\t}\n\n\t&.ck-toolbar_compact > .ck-toolbar__items > .ck {\n\t\t/* No rounded corners on the right side of the first child. */\n\t\t&:first-child {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\n\t\t/* No rounded corners on the left side of the last child. */\n\t\t&:last-child {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\t}\n\n\t/* Separate the the separator form the grouping dropdown when some items are grouped. */\n\t& > .ck.ck-toolbar__separator {\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n\n\t/* Some spacing between the items and the separator before the grouped items dropdown. */\n\t&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n}\n\n/*\n * Styles for LTR toolbars.\n *\n * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"\n * because its parent is not controlled by the editor framework.\n */\n[dir="ltr"] .ck.ck-toolbar,\n.ck.ck-toolbar[dir="ltr"] {\n\t& > .ck-toolbar__items > .ck:last-child {\n\t\tmargin-right: 0;\n\t}\n\n\t&.ck-toolbar_compact > .ck-toolbar__items > .ck {\n\t\t/* No rounded corners on the right side of the first child. */\n\t\t&:first-child {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t/* No rounded corners on the left side of the last child. */\n\t\t&:last-child {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\t}\n\n\t/* Separate the the separator form the grouping dropdown when some items are grouped. */\n\t& > .ck.ck-toolbar__separator {\n\t\tmargin-right: var(--ck-spacing-small);\n\t}\n\n\t/* Some spacing between the items and the separator before the grouped items dropdown. */\n\t&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {\n\t\tmargin-right: var(--ck-spacing-small);\n\t}\n}\n\n/* stylelint-enable */\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      888: (t, e, n) => {
        "use strict";
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ".ck.ck-balloon-panel.ck-tooltip{--ck-balloon-border-width:0px;--ck-balloon-arrow-offset:0px;--ck-balloon-arrow-half-width:4px;--ck-balloon-arrow-height:4px;--ck-tooltip-text-padding:4px;--ck-color-panel-background:var(--ck-color-tooltip-background);padding:0 var(--ck-spacing-medium);pointer-events:none;z-index:calc(var(--ck-z-modal) + 100)}.ck.ck-balloon-panel.ck-tooltip .ck-tooltip__text{color:var(--ck-color-tooltip-text);font-size:.9em;line-height:1.5}.ck.ck-balloon-panel.ck-tooltip.ck-tooltip_multi-line .ck-tooltip__text{display:inline-block;padding:var(--ck-tooltip-text-padding) 0;white-space:break-spaces}.ck.ck-balloon-panel.ck-tooltip{box-shadow:none}.ck.ck-balloon-panel.ck-tooltip:before{display:none}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/tooltip/tooltip.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/tooltip/tooltip.css",
            ],
            names: [],
            mappings:
              "AAKA,gCCGC,6BAA8B,CAC9B,6BAA8B,CAC9B,iCAAkC,CAClC,6BAA8B,CAC9B,6BAA8B,CAC9B,8DAA+D,CAE/D,kCAAmC,CDRnC,mBAAoB,CAEpB,qCACD,CCOC,kDAGC,kCAAmC,CAFnC,cAAe,CACf,eAED,CAEA,wEAEC,oBAAqB,CACrB,wCAAyC,CAFzC,wBAGD,CApBD,gCAuBC,eAMD,CAHC,uCACC,YACD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-balloon-panel.ck-tooltip {\n\t/* Keep tooltips transparent for any interactions. */\n\tpointer-events: none;\n\n\tz-index: calc( var(--ck-z-modal) + 100 );\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n.ck.ck-balloon-panel.ck-tooltip {\n\t--ck-balloon-border-width: 0px;\n\t--ck-balloon-arrow-offset: 0px;\n\t--ck-balloon-arrow-half-width: 4px;\n\t--ck-balloon-arrow-height: 4px;\n\t--ck-tooltip-text-padding: 4px;\n\t--ck-color-panel-background: var(--ck-color-tooltip-background);\n\n\tpadding: 0 var(--ck-spacing-medium);\n\n\t& .ck-tooltip__text {\n\t\tfont-size: .9em;\n\t\tline-height: 1.5;\n\t\tcolor: var(--ck-color-tooltip-text);\n\t}\n\n\t&.ck-tooltip_multi-line .ck-tooltip__text {\n\t\twhite-space: break-spaces;\n\t\tdisplay: inline-block;\n\t\tpadding: var(--ck-tooltip-text-padding) 0;\n\t}\n\n\t/* Reset balloon panel styles */\n\tbox-shadow: none;\n\n\t/* Hide the default shadow of the .ck-balloon-panel tip */\n\t&::before {\n\t\tdisplay: none;\n\t}\n}\n',
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      167: (t, e, n) => {
        "use strict";
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ".ck-hidden{display:none!important}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{box-sizing:border-box;height:auto;position:static;width:auto}:root{--ck-z-default:1;--ck-z-modal:calc(var(--ck-z-default) + 999)}.ck-transitions-disabled,.ck-transitions-disabled *{transition:none!important}:root{--ck-powered-by-line-height:10px;--ck-powered-by-padding-vertical:2px;--ck-powered-by-padding-horizontal:4px;--ck-powered-by-text-color:#4f4f4f;--ck-powered-by-border-radius:var(--ck-border-radius);--ck-powered-by-background:#fff;--ck-powered-by-border-color:var(--ck-color-focus-border)}.ck.ck-balloon-panel.ck-powered-by-balloon{--ck-border-radius:var(--ck-powered-by-border-radius);background:var(--ck-powered-by-background);box-shadow:none;min-height:unset;z-index:calc(var(--ck-z-modal) - 1)}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by{line-height:var(--ck-powered-by-line-height)}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by a{align-items:center;cursor:pointer;display:flex;filter:grayscale(80%);line-height:var(--ck-powered-by-line-height);opacity:.66;padding:var(--ck-powered-by-padding-vertical) var(--ck-powered-by-padding-horizontal)}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by .ck-powered-by__label{color:var(--ck-powered-by-text-color);cursor:pointer;font-size:7.5px;font-weight:700;letter-spacing:-.2px;line-height:normal;margin-right:4px;padding-left:2px;text-transform:uppercase}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by .ck-icon{cursor:pointer;display:block}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by:hover a{filter:grayscale(0);opacity:1}.ck.ck-balloon-panel.ck-powered-by-balloon[class*=position_inside]{border-color:transparent}.ck.ck-balloon-panel.ck-powered-by-balloon[class*=position_border]{border:var(--ck-focus-ring);border-color:var(--ck-powered-by-border-color)}:root{--ck-color-base-foreground:#fafafa;--ck-color-base-background:#fff;--ck-color-base-border:#ccced1;--ck-color-base-action:#53a336;--ck-color-base-focus:#6cb5f9;--ck-color-base-text:#333;--ck-color-base-active:#2977ff;--ck-color-base-active-focus:#0d65ff;--ck-color-base-error:#db3700;--ck-color-focus-border-coordinates:218,81.8%,56.9%;--ck-color-focus-border:hsl(var(--ck-color-focus-border-coordinates));--ck-color-focus-outer-shadow:#cae1fc;--ck-color-focus-disabled-shadow:rgba(119,186,248,.3);--ck-color-focus-error-shadow:rgba(255,64,31,.3);--ck-color-text:var(--ck-color-base-text);--ck-color-shadow-drop:rgba(0,0,0,.15);--ck-color-shadow-drop-active:rgba(0,0,0,.2);--ck-color-shadow-inner:rgba(0,0,0,.1);--ck-color-button-default-background:transparent;--ck-color-button-default-hover-background:#f0f0f0;--ck-color-button-default-active-background:#f0f0f0;--ck-color-button-default-disabled-background:transparent;--ck-color-button-on-background:#f0f7ff;--ck-color-button-on-hover-background:#dbecff;--ck-color-button-on-active-background:#dbecff;--ck-color-button-on-disabled-background:#f0f2f4;--ck-color-button-on-color:#2977ff;--ck-color-button-action-background:var(--ck-color-base-action);--ck-color-button-action-hover-background:#4d9d30;--ck-color-button-action-active-background:#4d9d30;--ck-color-button-action-disabled-background:#7ec365;--ck-color-button-action-text:var(--ck-color-base-background);--ck-color-button-save:#008a00;--ck-color-button-cancel:#db3700;--ck-color-switch-button-off-background:#939393;--ck-color-switch-button-off-hover-background:#7d7d7d;--ck-color-switch-button-on-background:var(--ck-color-button-action-background);--ck-color-switch-button-on-hover-background:#4d9d30;--ck-color-switch-button-inner-background:var(--ck-color-base-background);--ck-color-switch-button-inner-shadow:rgba(0,0,0,.1);--ck-color-dropdown-panel-background:var(--ck-color-base-background);--ck-color-dropdown-panel-border:var(--ck-color-base-border);--ck-color-input-background:var(--ck-color-base-background);--ck-color-input-border:var(--ck-color-base-border);--ck-color-input-error-border:var(--ck-color-base-error);--ck-color-input-text:var(--ck-color-base-text);--ck-color-input-disabled-background:#f2f2f2;--ck-color-input-disabled-border:var(--ck-color-base-border);--ck-color-input-disabled-text:#757575;--ck-color-list-background:var(--ck-color-base-background);--ck-color-list-button-hover-background:var(--ck-color-button-default-hover-background);--ck-color-list-button-on-background:var(--ck-color-button-on-color);--ck-color-list-button-on-background-focus:var(--ck-color-button-on-color);--ck-color-list-button-on-text:var(--ck-color-base-background);--ck-color-panel-background:var(--ck-color-base-background);--ck-color-panel-border:var(--ck-color-base-border);--ck-color-toolbar-background:var(--ck-color-base-background);--ck-color-toolbar-border:var(--ck-color-base-border);--ck-color-tooltip-background:var(--ck-color-base-text);--ck-color-tooltip-text:var(--ck-color-base-background);--ck-color-engine-placeholder-text:#707070;--ck-color-upload-bar-background:#6cb5f9;--ck-color-link-default:#0000f0;--ck-color-link-selected-background:rgba(31,176,255,.1);--ck-color-link-fake-selection:rgba(31,176,255,.3);--ck-color-highlight-background:#ff0;--ck-disabled-opacity:.5;--ck-focus-outer-shadow-geometry:0 0 0 3px;--ck-focus-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);--ck-focus-disabled-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);--ck-focus-error-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);--ck-focus-ring:1px solid var(--ck-color-focus-border);--ck-font-size-base:13px;--ck-line-height-base:1.84615;--ck-font-face:Helvetica,Arial,Tahoma,Verdana,Sans-Serif;--ck-font-size-tiny:0.7em;--ck-font-size-small:0.75em;--ck-font-size-normal:1em;--ck-font-size-big:1.4em;--ck-font-size-large:1.8em;--ck-ui-component-min-height:2.3em}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{word-wrap:break-word;background:transparent;border:0;margin:0;padding:0;text-decoration:none;transition:none;vertical-align:middle}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset_all{border-collapse:collapse;color:var(--ck-color-text);cursor:auto;float:none;font:normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);text-align:left;white-space:nowrap}.ck-reset_all .ck-rtl :not(.ck-reset_all-excluded *){text-align:right}.ck-reset_all iframe:not(.ck-reset_all-excluded *){vertical-align:inherit}.ck-reset_all textarea:not(.ck-reset_all-excluded *){white-space:pre-wrap}.ck-reset_all input[type=password]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text]:not(.ck-reset_all-excluded *),.ck-reset_all textarea:not(.ck-reset_all-excluded *){cursor:text}.ck-reset_all input[type=password][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all textarea[disabled]:not(.ck-reset_all-excluded *){cursor:default}.ck-reset_all fieldset:not(.ck-reset_all-excluded *){border:2px groove #dfdee3;padding:10px}.ck-reset_all button:not(.ck-reset_all-excluded *)::-moz-focus-inner{border:0;padding:0}.ck[dir=rtl],.ck[dir=rtl] .ck{text-align:right}:root{--ck-border-radius:2px;--ck-inner-shadow:2px 2px 3px var(--ck-color-shadow-inner) inset;--ck-drop-shadow:0 1px 2px 1px var(--ck-color-shadow-drop);--ck-drop-shadow-active:0 3px 6px 1px var(--ck-color-shadow-drop-active);--ck-spacing-unit:0.6em;--ck-spacing-large:calc(var(--ck-spacing-unit)*1.5);--ck-spacing-standard:var(--ck-spacing-unit);--ck-spacing-medium:calc(var(--ck-spacing-unit)*0.8);--ck-spacing-small:calc(var(--ck-spacing-unit)*0.5);--ck-spacing-tiny:calc(var(--ck-spacing-unit)*0.3);--ck-spacing-extra-tiny:calc(var(--ck-spacing-unit)*0.16)}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_hidden.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_reset.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_zindex.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_transition.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_poweredby.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_colors.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_disabled.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_focus.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_fonts.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_reset.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_rounded.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_shadow.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_spacing.css",
            ],
            names: [],
            mappings:
              "AAQA,WAGC,sBACD,CCPA,2EAGC,qBAAsB,CAEtB,WAAY,CACZ,eAAgB,CAFhB,UAGD,CCPA,MACC,gBAAiB,CACjB,4CACD,CCAA,oDAEC,yBACD,CCNA,MACC,gCAAiC,CACjC,oCAAqC,CACrC,sCAAuC,CACvC,kCAA2C,CAC3C,qDAAsD,CACtD,+BAA4C,CAC5C,yDACD,CAEA,2CACC,qDAAsD,CAGtD,0CAA2C,CAD3C,eAAgB,CAEhB,gBAAiB,CACjB,mCAiDD,CA/CC,6DACC,4CAoCD,CAlCC,+DAGC,kBAAmB,CAFnB,cAAe,CACf,YAAa,CAGb,qBAAsB,CACtB,4CAA6C,CAF7C,WAAY,CAGZ,qFACD,CAEA,mFASC,qCAAsC,CAFtC,cAAe,CANf,eAAgB,CAIhB,eAAiB,CAHjB,oBAAqB,CAMrB,kBAAmB,CAFnB,gBAAiB,CAHjB,gBAAiB,CACjB,wBAOD,CAEA,sEAEC,cAAe,CADf,aAED,CAGC,qEACC,mBAAqB,CACrB,SACD,CAIF,mEACC,wBACD,CAEA,mEACC,2BAA4B,CAC5B,8CACD,CChED,MACC,kCAAmD,CACnD,+BAAoD,CACpD,8BAAkD,CAClD,8BAAuD,CACvD,6BAAmD,CACnD,yBAA+C,CAC/C,8BAAsD,CACtD,oCAA4D,CAC5D,6BAAkD,CAIlD,mDAA4D,CAC5D,qEAA+E,CAC/E,qCAA4D,CAC5D,qDAA8D,CAC9D,gDAAyD,CACzD,yCAAqD,CACrD,sCAAsD,CACtD,4CAA0D,CAC1D,sCAAsD,CAItD,gDAAuD,CACvD,kDAAiE,CACjE,mDAAkE,CAClE,yDAA8D,CAE9D,uCAA6D,CAC7D,6CAAoE,CACpE,8CAAoE,CACpE,gDAAiE,CACjE,kCAAyD,CAGzD,+DAAsE,CACtE,iDAAsE,CACtE,kDAAsE,CACtE,oDAAoE,CACpE,6DAAsE,CAEtE,8BAAoD,CACpD,gCAAqD,CAErD,+CAA8D,CAC9D,qDAAiE,CACjE,+EAAqF,CACrF,oDAAuE,CACvE,yEAA8E,CAC9E,oDAAgE,CAIhE,oEAA2E,CAC3E,4DAAoE,CAIpE,2DAAoE,CACpE,mDAA6D,CAC7D,wDAAgE,CAChE,+CAA0D,CAC1D,4CAA2D,CAC3D,4DAAoE,CACpE,sCAAsD,CAItD,0DAAmE,CACnE,uFAA6F,CAC7F,oEAA2E,CAC3E,0EAA+E,CAC/E,8DAAsE,CAItE,2DAAoE,CACpE,mDAA6D,CAI7D,6DAAsE,CACtE,qDAA+D,CAI/D,uDAAgE,CAChE,uDAAiE,CAIjE,0CAAyD,CAIzD,wCAA2D,CAI3D,+BAAoD,CACpD,uDAAmE,CACnE,kDAAgE,CAIhE,oCAAwD,CCvGxD,wBAAyB,CCAzB,0CAA2C,CAK3C,gGAAiG,CAKjG,4GAA6G,CAK7G,sGAAuG,CAKvG,sDAAuD,CCvBvD,wBAAyB,CACzB,6BAA8B,CAC9B,wDAA6D,CAE7D,yBAA0B,CAC1B,2BAA4B,CAC5B,yBAA0B,CAC1B,wBAAyB,CACzB,0BAA2B,CCJ3B,kCJuGD,CIjGA,2EAaC,oBAAqB,CANrB,sBAAuB,CADvB,QAAS,CAFT,QAAS,CACT,SAAU,CAGV,oBAAqB,CAErB,eAAgB,CADhB,qBAKD,CAKA,8DAGC,wBAAyB,CAEzB,0BAA2B,CAG3B,WAAY,CACZ,UAAW,CALX,iGAAkG,CAElG,eAAgB,CAChB,kBAGD,CAGC,qDACC,gBACD,CAEA,mDAEC,sBACD,CAEA,qDACC,oBACD,CAEA,mLAGC,WACD,CAEA,iNAGC,cACD,CAEA,qDAEC,yBAAoC,CADpC,YAED,CAEA,qEAGC,QAAQ,CADR,SAED,CAMD,8BAEC,gBACD,CCnFA,MACC,sBAAuB,CCAvB,gEAAiE,CAKjE,0DAA2D,CAK3D,wEAAyE,CCbzE,uBAA8B,CAC9B,mDAA2D,CAC3D,4CAAkD,CAClD,oDAA4D,CAC5D,mDAA2D,CAC3D,kDAA2D,CAC3D,yDFFD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which hides an element in DOM.\n */\n.ck-hidden {\n\t/* Override selector specificity. Otherwise, all elements with some display\n\tstyle defined will override this one, which is not a desired result. */\n\tdisplay: none !important;\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\tbox-sizing: border-box;\n\twidth: auto;\n\theight: auto;\n\tposition: static;\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-z-default: 1;\n\t--ck-z-modal: calc( var(--ck-z-default) + 999 );\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class that disables all transitions of the element and its children.\n */\n.ck-transitions-disabled,\n.ck-transitions-disabled * {\n\ttransition: none !important;\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-powered-by-line-height: 10px;\n\t--ck-powered-by-padding-vertical: 2px;\n\t--ck-powered-by-padding-horizontal: 4px;\n\t--ck-powered-by-text-color: hsl(0, 0%, 31%);\n\t--ck-powered-by-border-radius: var(--ck-border-radius);\n\t--ck-powered-by-background: hsl(0, 0%, 100%);\n\t--ck-powered-by-border-color: var(--ck-color-focus-border);\n}\n\n.ck.ck-balloon-panel.ck-powered-by-balloon {\n\t--ck-border-radius: var(--ck-powered-by-border-radius);\n\n\tbox-shadow: none;\n\tbackground: var(--ck-powered-by-background);\n\tmin-height: unset;\n\tz-index: calc( var(--ck-z-modal) - 1 );\n\n\t& .ck.ck-powered-by {\n\t\tline-height: var(--ck-powered-by-line-height);\n\n\t\t& a {\n\t\t\tcursor: pointer;\n\t\t\tdisplay: flex;\n\t\t\talign-items: center;\n\t\t\topacity: .66;\n\t\t\tfilter: grayscale(80%);\n\t\t\tline-height: var(--ck-powered-by-line-height);\n\t\t\tpadding: var(--ck-powered-by-padding-vertical) var(--ck-powered-by-padding-horizontal);\n\t\t}\n\n\t\t& .ck-powered-by__label {\n\t\t\tfont-size: 7.5px;\n\t\t\tletter-spacing: -.2px;\n\t\t\tpadding-left: 2px;\n\t\t\ttext-transform: uppercase;\n\t\t\tfont-weight: bold;\n\t\t\tmargin-right: 4px;\n\t\t\tcursor: pointer;\n\t\t\tline-height: normal;\n\t\t\tcolor: var(--ck-powered-by-text-color);\n\n\t\t}\n\n\t\t& .ck-icon {\n\t\t\tdisplay: block;\n\t\t\tcursor: pointer;\n\t\t}\n\n\t\t&:hover {\n\t\t\t& a {\n\t\t\t\tfilter: grayscale(0%);\n\t\t\t\topacity: 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t&[class*="position_inside"] {\n\t\tborder-color: transparent;\n\t}\n\n\t&[class*="position_border"] {\n\t\tborder: var(--ck-focus-ring);\n\t\tborder-color: var(--ck-powered-by-border-color);\n\t}\n}\n\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-base-foreground: \t\t\t\t\t\t\t\thsl(0, 0%, 98%);\n\t--ck-color-base-background: \t\t\t\t\t\t\t\thsl(0, 0%, 100%);\n\t--ck-color-base-border: \t\t\t\t\t\t\t\t\thsl(220, 6%, 81%);\n\t--ck-color-base-action: \t\t\t\t\t\t\t\t\thsl(104, 50.2%, 42.5%);\n\t--ck-color-base-focus: \t\t\t\t\t\t\t\t\t\thsl(209, 92%, 70%);\n\t--ck-color-base-text: \t\t\t\t\t\t\t\t\t\thsl(0, 0%, 20%);\n\t--ck-color-base-active: \t\t\t\t\t\t\t\t\thsl(218.1, 100%, 58%);\n\t--ck-color-base-active-focus:\t\t\t\t\t\t\t\thsl(218.2, 100%, 52.5%);\n\t--ck-color-base-error:\t\t\t\t\t\t\t\t\t\thsl(15, 100%, 43%);\n\n\t/* -- Generic colors ------------------------------------------------------------------------ */\n\n\t--ck-color-focus-border-coordinates: \t\t\t\t\t\t218, 81.8%, 56.9%;\n\t--ck-color-focus-border: \t\t\t\t\t\t\t\t\thsl(var(--ck-color-focus-border-coordinates));\n\t--ck-color-focus-outer-shadow:\t\t\t\t\t\t\t\thsl(212.4, 89.3%, 89%);\n\t--ck-color-focus-disabled-shadow:\t\t\t\t\t\t\thsla(209, 90%, 72%,.3);\n\t--ck-color-focus-error-shadow:\t\t\t\t\t\t\t\thsla(9,100%,56%,.3);\n\t--ck-color-text: \t\t\t\t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-shadow-drop: \t\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.15);\n\t--ck-color-shadow-drop-active:\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.2);\n\t--ck-color-shadow-inner: \t\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.1);\n\n\t/* -- Buttons ------------------------------------------------------------------------------- */\n\n\t--ck-color-button-default-background: \t\t\t\t\t\ttransparent;\n\t--ck-color-button-default-hover-background: \t\t\t\thsl(0, 0%, 94.1%);\n\t--ck-color-button-default-active-background: \t\t\t\thsl(0, 0%, 94.1%);\n\t--ck-color-button-default-disabled-background: \t\t\t\ttransparent;\n\n\t--ck-color-button-on-background: \t\t\t\t\t\t\thsl(212, 100%, 97.1%);\n\t--ck-color-button-on-hover-background: \t\t\t\t\t\thsl(211.7, 100%, 92.9%);\n\t--ck-color-button-on-active-background: \t\t\t\t\thsl(211.7, 100%, 92.9%);\n\t--ck-color-button-on-disabled-background: \t\t\t\t\thsl(211, 15%, 95%);\n\t--ck-color-button-on-color:\t\t\t\t\t\t\t\t\thsl(218.1, 100%, 58%);\n\n\n\t--ck-color-button-action-background: \t\t\t\t\t\tvar(--ck-color-base-action);\n\t--ck-color-button-action-hover-background: \t\t\t\t\thsl(104, 53.2%, 40.2%);\n\t--ck-color-button-action-active-background: \t\t\t\thsl(104, 53.2%, 40.2%);\n\t--ck-color-button-action-disabled-background: \t\t\t\thsl(104, 44%, 58%);\n\t--ck-color-button-action-text: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t--ck-color-button-save: \t\t\t\t\t\t\t\t\thsl(120, 100%, 27%);\n\t--ck-color-button-cancel: \t\t\t\t\t\t\t\t\thsl(15, 100%, 43%);\n\n\t--ck-color-switch-button-off-background:\t\t\t\t\thsl(0, 0%, 57.6%);\n\t--ck-color-switch-button-off-hover-background:\t\t\t\thsl(0, 0%, 49%);\n\t--ck-color-switch-button-on-background:\t\t\t\t\t\tvar(--ck-color-button-action-background);\n\t--ck-color-switch-button-on-hover-background:\t\t\t\thsl(104, 53.2%, 40.2%);\n\t--ck-color-switch-button-inner-background:\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-switch-button-inner-shadow:\t\t\t\t\t\thsla(0, 0%, 0%, 0.1);\n\n\t/* -- Dropdown ------------------------------------------------------------------------------ */\n\n\t--ck-color-dropdown-panel-background: \t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-dropdown-panel-border: \t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Input --------------------------------------------------------------------------------- */\n\n\t--ck-color-input-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-input-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\t--ck-color-input-error-border:\t\t\t\t\t\t\t\tvar(--ck-color-base-error);\n\t--ck-color-input-text: \t\t\t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-input-disabled-background: \t\t\t\t\t\thsl(0, 0%, 95%);\n\t--ck-color-input-disabled-border: \t\t\t\t\t\t\tvar(--ck-color-base-border);\n\t--ck-color-input-disabled-text: \t\t\t\t\t\t\thsl(0, 0%, 46%);\n\n\t/* -- List ---------------------------------------------------------------------------------- */\n\n\t--ck-color-list-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-list-button-hover-background: \t\t\t\t\tvar(--ck-color-button-default-hover-background);\n\t--ck-color-list-button-on-background: \t\t\t\t\t\tvar(--ck-color-button-on-color);\n\t--ck-color-list-button-on-background-focus: \t\t\t\tvar(--ck-color-button-on-color);\n\t--ck-color-list-button-on-text:\t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t/* -- Panel --------------------------------------------------------------------------------- */\n\n\t--ck-color-panel-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-panel-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Toolbar ------------------------------------------------------------------------------- */\n\n\t--ck-color-toolbar-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-toolbar-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Tooltip ------------------------------------------------------------------------------- */\n\n\t--ck-color-tooltip-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-tooltip-text: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t/* -- Engine -------------------------------------------------------------------------------- */\n\n\t--ck-color-engine-placeholder-text: \t\t\t\t\t\thsl(0, 0%, 44%);\n\n\t/* -- Upload -------------------------------------------------------------------------------- */\n\n\t--ck-color-upload-bar-background:\t\t \t\t\t\t\thsl(209, 92%, 70%);\n\n\t/* -- Link -------------------------------------------------------------------------------- */\n\n\t--ck-color-link-default:\t\t\t\t\t\t\t\t\thsl(240, 100%, 47%);\n\t--ck-color-link-selected-background:\t\t\t\t\t\thsla(201, 100%, 56%, 0.1);\n\t--ck-color-link-fake-selection:\t\t\t\t\t\t\t\thsla(201, 100%, 56%, 0.3);\n\n\t/* -- Search result highlight ---------------------------------------------------------------- */\n\n\t--ck-color-highlight-background:\t\t\t\t\t\t\thsl(60, 100%, 50%)\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * An opacity value of disabled UI item.\n\t */\n\t--ck-disabled-opacity: .5;\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * The geometry of the of focused element's outer shadow.\n\t */\n\t--ck-focus-outer-shadow-geometry: 0 0 0 3px;\n\n\t/**\n\t * A visual style of focused element's outer shadow.\n\t */\n\t--ck-focus-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);\n\n\t/**\n\t * A visual style of focused element's outer shadow (when disabled).\n\t */\n\t--ck-focus-disabled-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);\n\n\t/**\n\t * A visual style of focused element's outer shadow (when has errors).\n\t */\n\t--ck-focus-error-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);\n\n\t/**\n\t * A visual style of focused element's border or outline.\n\t */\n\t--ck-focus-ring: 1px solid var(--ck-color-focus-border);\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-font-size-base: 13px;\n\t--ck-line-height-base: 1.84615;\n\t--ck-font-face: Helvetica, Arial, Tahoma, Verdana, Sans-Serif;\n\n\t--ck-font-size-tiny: 0.7em;\n\t--ck-font-size-small: 0.75em;\n\t--ck-font-size-normal: 1em;\n\t--ck-font-size-big: 1.4em;\n\t--ck-font-size-large: 1.8em;\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/* This is super-important. This is **manually** adjusted so a button without an icon\n\tis never smaller than a button with icon, additionally making sure that text-less buttons\n\tare perfect squares. The value is also shared by other components which should stay "in-line"\n\twith buttons. */\n\t--ck-ui-component-min-height: 2.3em;\n}\n\n/**\n * Resets an element, ignoring its children.\n */\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\t/* Do not include inheritable rules here. */\n\tmargin: 0;\n\tpadding: 0;\n\tborder: 0;\n\tbackground: transparent;\n\ttext-decoration: none;\n\tvertical-align: middle;\n\ttransition: none;\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/105 */\n\tword-wrap: break-word;\n}\n\n/**\n * Resets an element AND its children.\n */\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\t/* These are rule inherited by all children elements. */\n\tborder-collapse: collapse;\n\tfont: normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);\n\tcolor: var(--ck-color-text);\n\ttext-align: left;\n\twhite-space: nowrap;\n\tcursor: auto;\n\tfloat: none;\n}\n\n.ck-reset_all {\n\t& .ck-rtl *:not(.ck-reset_all-excluded *) {\n\t\ttext-align: right;\n\t}\n\n\t& iframe:not(.ck-reset_all-excluded *) {\n\t\t/* For IE */\n\t\tvertical-align: inherit;\n\t}\n\n\t& textarea:not(.ck-reset_all-excluded *) {\n\t\twhite-space: pre-wrap;\n\t}\n\n\t& textarea:not(.ck-reset_all-excluded *),\n\t& input[type="text"]:not(.ck-reset_all-excluded *),\n\t& input[type="password"]:not(.ck-reset_all-excluded *) {\n\t\tcursor: text;\n\t}\n\n\t& textarea[disabled]:not(.ck-reset_all-excluded *),\n\t& input[type="text"][disabled]:not(.ck-reset_all-excluded *),\n\t& input[type="password"][disabled]:not(.ck-reset_all-excluded *) {\n\t\tcursor: default;\n\t}\n\n\t& fieldset:not(.ck-reset_all-excluded *) {\n\t\tpadding: 10px;\n\t\tborder: 2px groove hsl(255, 7%, 88%);\n\t}\n\n\t& button:not(.ck-reset_all-excluded *)::-moz-focus-inner {\n\t\t/* See http://stackoverflow.com/questions/5517744/remove-extra-button-spacing-padding-in-firefox */\n\t\tpadding: 0;\n\t\tborder: 0\n\t}\n}\n\n/**\n * Default UI rules for RTL languages.\n */\n.ck[dir="rtl"],\n.ck[dir="rtl"] .ck {\n\ttext-align: right;\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Default border-radius value.\n */\n:root{\n\t--ck-border-radius: 2px;\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * A visual style of element's inner shadow (i.e. input).\n\t */\n\t--ck-inner-shadow: 2px 2px 3px var(--ck-color-shadow-inner) inset;\n\n\t/**\n\t * A visual style of element's drop shadow (i.e. panel).\n\t */\n\t--ck-drop-shadow: 0 1px 2px 1px var(--ck-color-shadow-drop);\n\n\t/**\n\t * A visual style of element's active shadow (i.e. comment or suggestion).\n\t */\n\t--ck-drop-shadow-active: 0 3px 6px 1px var(--ck-color-shadow-drop-active);\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-spacing-unit: \t\t\t\t\t\t0.6em;\n\t--ck-spacing-large: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 1.5);\n\t--ck-spacing-standard: \t\t\t\t\tvar(--ck-spacing-unit);\n\t--ck-spacing-medium: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.8);\n\t--ck-spacing-small: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.5);\n\t--ck-spacing-tiny: \t\t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.3);\n\t--ck-spacing-extra-tiny: \t\t\t\tcalc(var(--ck-spacing-unit) * 0.16);\n}\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      153: (t, e, n) => {
        "use strict";
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ":root{--ck-color-resizer:var(--ck-color-focus-border);--ck-color-resizer-tooltip-background:#262626;--ck-color-resizer-tooltip-text:#f2f2f2;--ck-resizer-border-radius:var(--ck-border-radius);--ck-resizer-tooltip-offset:10px;--ck-resizer-tooltip-height:calc(var(--ck-spacing-small)*2 + 10px)}.ck .ck-widget,.ck .ck-widget.ck-widget_with-selection-handle{position:relative}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{position:absolute}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{display:block}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{visibility:visible}.ck .ck-size-view{background:var(--ck-color-resizer-tooltip-background);border:1px solid var(--ck-color-resizer-tooltip-text);border-radius:var(--ck-resizer-border-radius);color:var(--ck-color-resizer-tooltip-text);display:block;font-size:var(--ck-font-size-tiny);height:var(--ck-resizer-tooltip-height);line-height:var(--ck-resizer-tooltip-height);padding:0 var(--ck-spacing-small)}.ck .ck-size-view.ck-orientation-above-center,.ck .ck-size-view.ck-orientation-bottom-left,.ck .ck-size-view.ck-orientation-bottom-right,.ck .ck-size-view.ck-orientation-top-left,.ck .ck-size-view.ck-orientation-top-right{position:absolute}.ck .ck-size-view.ck-orientation-top-left{left:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-top-right{right:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-right{bottom:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-left{bottom:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-above-center{left:50%;top:calc(var(--ck-resizer-tooltip-height)*-1);transform:translate(-50%)}:root{--ck-widget-outline-thickness:3px;--ck-widget-handler-icon-size:16px;--ck-widget-handler-animation-duration:200ms;--ck-widget-handler-animation-curve:ease;--ck-color-widget-blurred-border:#dedede;--ck-color-widget-hover-border:#ffc83d;--ck-color-widget-editable-focus-background:var(--ck-color-base-background);--ck-color-widget-drag-handler-icon-color:var(--ck-color-base-background)}.ck .ck-widget{outline-color:transparent;outline-style:solid;outline-width:var(--ck-widget-outline-thickness);transition:outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_selected,.ck .ck-widget.ck-widget_selected:hover{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border)}.ck .ck-widget:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-editor__nested-editable{border:1px solid transparent}.ck .ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck .ck-editor__nested-editable:focus{background-color:var(--ck-color-widget-editable-focus-background);border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{background-color:transparent;border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0;box-sizing:border-box;left:calc(0px - var(--ck-widget-outline-thickness));opacity:0;padding:4px;top:0;transform:translateY(-100%);transition:background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{color:var(--ck-color-widget-drag-handler-icon-color);height:var(--ck-widget-handler-icon-size);width:var(--ck-widget-handler-icon-size)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:0;transition:opacity .3s var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover .ck-icon .ck-icon__selected-indicator{opacity:1}.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{background-color:var(--ck-color-widget-hover-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{background-color:var(--ck-color-focus-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:1}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{left:auto;right:calc(0px - var(--ck-widget-outline-thickness))}.ck.ck-editor__editable.ck-read-only .ck-widget{transition:none}.ck.ck-editor__editable.ck-read-only .ck-widget:not(.ck-widget_selected){--ck-widget-outline-thickness:0px}.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover{outline-color:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle:hover,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable blockquote>.ck-widget.ck-widget_with-selection-handle:first-child,.ck.ck-editor__editable>.ck-widget.ck-widget_with-selection-handle:first-child{margin-top:calc(1em + var(--ck-widget-handler-icon-size))}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widget.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widget.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
            ],
            names: [],
            mappings:
              "AAKA,MACC,+CAAgD,CAChD,6CAAsD,CACtD,uCAAgD,CAEhD,kDAAmD,CACnD,gCAAiC,CACjC,kEACD,CAOA,8DAEC,iBAqBD,CAnBC,4EACC,iBAOD,CALC,qFAGC,aACD,CASD,iLACC,kBACD,CAGD,kBACC,qDAAsD,CAEtD,qDAAsD,CACtD,6CAA8C,CAF9C,0CAA2C,CAI3C,aAAc,CADd,kCAAmC,CAGnC,uCAAwC,CACxC,4CAA6C,CAF7C,iCAsCD,CAlCC,8NAKC,iBACD,CAEA,0CAEC,qCAAsC,CADtC,oCAED,CAEA,2CAEC,sCAAuC,CADvC,oCAED,CAEA,8CACC,uCAAwC,CACxC,sCACD,CAEA,6CACC,uCAAwC,CACxC,qCACD,CAGA,8CAEC,QAAS,CADT,6CAAgD,CAEhD,yBACD,CCjFD,MACC,iCAAkC,CAClC,kCAAmC,CACnC,4CAA6C,CAC7C,wCAAyC,CAEzC,wCAAiD,CACjD,sCAAkD,CAClD,2EAA4E,CAC5E,yEACD,CAEA,eAGC,yBAA0B,CAD1B,mBAAoB,CADpB,gDAAiD,CAGjD,6GAUD,CARC,0EAEC,6EACD,CAEA,qBACC,iDACD,CAGD,gCACC,4BAWD,CAPC,yGAKC,iEAAkE,CCnCnE,2BAA2B,CCF3B,qCAA8B,CDC9B,YDqCA,CAIA,4EAKC,4BAA6B,CAa7B,iEAAkE,CAhBlE,qBAAsB,CAoBtB,mDAAoD,CAhBpD,SAAU,CALV,WAAY,CAsBZ,KAAM,CAFN,2BAA4B,CAT5B,6SAgCD,CAnBC,qFAIC,oDAAqD,CADrD,yCAA0C,CAD1C,wCAWD,CANC,kHACC,SAAU,CAGV,+DACD,CAID,wHACC,SACD,CAID,kFAEC,oDAAqD,CADrD,SAED,CAKC,oMAEC,6CAA8C,CAD9C,SAOD,CAHC,gRACC,SACD,CAOH,qFACC,SAAU,CACV,oDACD,CAGA,gDAEC,eAkBD,CAhBC,yEAOC,iCACD,CAGC,gOAEC,gDACD,CAOD,wIAEC,mDAQD,CALE,ghBAEC,gDACD,CAKH,yKAOC,yDACD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-resizer: var(--ck-color-focus-border);\n\t--ck-color-resizer-tooltip-background: hsl(0, 0%, 15%);\n\t--ck-color-resizer-tooltip-text: hsl(0, 0%, 95%);\n\n\t--ck-resizer-border-radius: var(--ck-border-radius);\n\t--ck-resizer-tooltip-offset: 10px;\n\t--ck-resizer-tooltip-height: calc(var(--ck-spacing-small) * 2 + 10px);\n}\n\n.ck .ck-widget {\n\t/* This is neccessary for type around UI to be positioned properly. */\n\tposition: relative;\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n\t/* Make the widget wrapper a relative positioning container for the drag handle. */\n\tposition: relative;\n\n\t& .ck-widget__selection-handle {\n\t\tposition: absolute;\n\n\t\t& .ck-icon {\n\t\t\t/* Make sure the icon in not a subject to font-size or line-height to avoid\n\t\t\tunnecessary spacing around it. */\n\t\t\tdisplay: block;\n\t\t}\n\t}\n\n\t/* Show the selection handle on mouse hover over the widget, but not for nested widgets. */\n\t&:hover > .ck-widget__selection-handle {\n\t\tvisibility: visible;\n\t}\n\n\t/* Show the selection handle when the widget is selected, but not for nested widgets. */\n\t&.ck-widget_selected > .ck-widget__selection-handle {\n\t\tvisibility: visible;\n\t}\n}\n\n.ck .ck-size-view {\n\tbackground: var(--ck-color-resizer-tooltip-background);\n\tcolor: var(--ck-color-resizer-tooltip-text);\n\tborder: 1px solid var(--ck-color-resizer-tooltip-text);\n\tborder-radius: var(--ck-resizer-border-radius);\n\tfont-size: var(--ck-font-size-tiny);\n\tdisplay: block;\n\tpadding: 0 var(--ck-spacing-small);\n\theight: var(--ck-resizer-tooltip-height);\n\tline-height: var(--ck-resizer-tooltip-height);\n\n\t&.ck-orientation-top-left,\n\t&.ck-orientation-top-right,\n\t&.ck-orientation-bottom-right,\n\t&.ck-orientation-bottom-left,\n\t&.ck-orientation-above-center {\n\t\tposition: absolute;\n\t}\n\n\t&.ck-orientation-top-left {\n\t\ttop: var(--ck-resizer-tooltip-offset);\n\t\tleft: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-top-right {\n\t\ttop: var(--ck-resizer-tooltip-offset);\n\t\tright: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-bottom-right {\n\t\tbottom: var(--ck-resizer-tooltip-offset);\n\t\tright: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-bottom-left {\n\t\tbottom: var(--ck-resizer-tooltip-offset);\n\t\tleft: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t/* Class applied if the widget is too small to contain the size label */\n\t&.ck-orientation-above-center {\n\t\ttop: calc(var(--ck-resizer-tooltip-height) * -1);\n\t\tleft: 50%;\n\t\ttransform: translate(-50%);\n\t}\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_focus.css";\n@import "../mixins/_shadow.css";\n\n:root {\n\t--ck-widget-outline-thickness: 3px;\n\t--ck-widget-handler-icon-size: 16px;\n\t--ck-widget-handler-animation-duration: 200ms;\n\t--ck-widget-handler-animation-curve: ease;\n\n\t--ck-color-widget-blurred-border: hsl(0, 0%, 87%);\n\t--ck-color-widget-hover-border: hsl(43, 100%, 62%);\n\t--ck-color-widget-editable-focus-background: var(--ck-color-base-background);\n\t--ck-color-widget-drag-handler-icon-color: var(--ck-color-base-background);\n}\n\n.ck .ck-widget {\n\toutline-width: var(--ck-widget-outline-thickness);\n\toutline-style: solid;\n\toutline-color: transparent;\n\ttransition: outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border);\n\t}\n\n\t&:hover {\n\t\toutline-color: var(--ck-color-widget-hover-border);\n\t}\n}\n\n.ck .ck-editor__nested-editable {\n\tborder: 1px solid transparent;\n\n\t/* The :focus style is applied before .ck-editor__nested-editable_focused class is rendered in the view.\n\tThese styles show a different border for a blink of an eye, so `:focus` need to have same styles applied. */\n\t&.ck-editor__nested-editable_focused,\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-inner-shadow);\n\n\t\tbackground-color: var(--ck-color-widget-editable-focus-background);\n\t}\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n\t& .ck-widget__selection-handle {\n\t\tpadding: 4px;\n\t\tbox-sizing: border-box;\n\n\t\t/* Background and opacity will be animated as the handler shows up or the widget gets selected. */\n\t\tbackground-color: transparent;\n\t\topacity: 0;\n\n\t\t/* Transition:\n\t\t   * background-color for the .ck-widget_selected state change,\n\t\t   * visibility for hiding the handler,\n\t\t   * opacity for the proper look of the icon when the handler disappears. */\n\t\ttransition:\n\t\t\tbackground-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n\t\t\tvisibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n\t\t\topacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t\t/* Make only top corners round. */\n\t\tborder-radius: var(--ck-border-radius) var(--ck-border-radius) 0 0;\n\n\t\t/* Place the drag handler outside the widget wrapper. */\n\t\ttransform: translateY(-100%);\n\t\tleft: calc(0px - var(--ck-widget-outline-thickness));\n\t\ttop: 0;\n\n\t\t& .ck-icon {\n\t\t\t/* Make sure the dimensions of the icon are independent of the fon-size of the content. */\n\t\t\twidth: var(--ck-widget-handler-icon-size);\n\t\t\theight: var(--ck-widget-handler-icon-size);\n\t\t\tcolor: var(--ck-color-widget-drag-handler-icon-color);\n\n\t\t\t/* The "selected" part of the icon is invisible by default */\n\t\t\t& .ck-icon__selected-indicator {\n\t\t\t\topacity: 0;\n\n\t\t\t\t/* Note: The animation is longer on purpose. Simply feels better. */\n\t\t\t\ttransition: opacity 300ms var(--ck-widget-handler-animation-curve);\n\t\t\t}\n\t\t}\n\n\t\t/* Advertise using the look of the icon that once clicked the handler, the widget will be selected. */\n\t\t&:hover .ck-icon .ck-icon__selected-indicator {\n\t\t\topacity: 1;\n\t\t}\n\t}\n\n\t/* Show the selection handler on mouse hover over the widget, but not for nested widgets. */\n\t&:hover > .ck-widget__selection-handle {\n\t\topacity: 1;\n\t\tbackground-color: var(--ck-color-widget-hover-border);\n\t}\n\n\t/* Show the selection handler when the widget is selected, but not for nested widgets. */\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\t& > .ck-widget__selection-handle {\n\t\t\topacity: 1;\n\t\t\tbackground-color: var(--ck-color-focus-border);\n\n\t\t\t/* When the widget is selected, notify the user using the proper look of the icon. */\n\t\t\t& .ck-icon .ck-icon__selected-indicator {\n\t\t\t\topacity: 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* In a RTL environment, align the selection handler to the right side of the widget */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle {\n\tleft: auto;\n\tright: calc(0px - var(--ck-widget-outline-thickness));\n}\n\n/* https://github.com/ckeditor/ckeditor5/issues/6415 */\n.ck.ck-editor__editable.ck-read-only .ck-widget {\n\t/* Prevent the :hover outline from showing up because of the used outline-color transition. */\n\ttransition: none;\n\n\t&:not(.ck-widget_selected) {\n\t\t/* Disable visual effects of hover/active widget when CKEditor is in readOnly mode.\n\t\t * See: https://github.com/ckeditor/ckeditor5/issues/1261\n\t\t *\n\t\t * Leave the unit because this custom property is used in calc() by other features.\n\t\t * See: https://github.com/ckeditor/ckeditor5/issues/6775\n\t\t */\n\t\t--ck-widget-outline-thickness: 0px;\n\t}\n\n\t&.ck-widget_with-selection-handle {\n\t\t& .ck-widget__selection-handle,\n\t\t& .ck-widget__selection-handle:hover {\n\t\t\tbackground: var(--ck-color-widget-blurred-border);\n\t\t}\n\t}\n}\n\n/* Style the widget when it\'s selected but the editable it belongs to lost focus. */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck.ck-editor__editable.ck-blurred .ck-widget {\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\toutline-color: var(--ck-color-widget-blurred-border);\n\n\t\t&.ck-widget_with-selection-handle {\n\t\t\t& > .ck-widget__selection-handle,\n\t\t\t& > .ck-widget__selection-handle:hover {\n\t\t\t\tbackground: var(--ck-color-widget-blurred-border);\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-editor__editable > .ck-widget.ck-widget_with-selection-handle:first-child,\n.ck.ck-editor__editable blockquote > .ck-widget.ck-widget_with-selection-handle:first-child {\n\t/* Do not crop selection handler if a widget is a first-child in the blockquote or in the root editable.\n\tIn fact, anything with overflow: hidden.\n\thttps://github.com/ckeditor/ckeditor5-block-quote/issues/28\n\thttps://github.com/ckeditor/ckeditor5-widget/issues/44\n\thttps://github.com/ckeditor/ckeditor5-widget/issues/66 */\n\tmargin-top: calc(1em + var(--ck-widget-handler-icon-size));\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      875: (t, e, n) => {
        "use strict";
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ".ck .ck-widget_with-resizer{position:relative}.ck .ck-widget__resizer{display:none;left:0;pointer-events:none;position:absolute;top:0}.ck-focused .ck-widget_with-resizer.ck-widget_selected>.ck-widget__resizer{display:block}.ck .ck-widget__resizer__handle{pointer-events:all;position:absolute}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{cursor:nwse-resize}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{cursor:nesw-resize}:root{--ck-resizer-size:10px;--ck-resizer-offset:calc(var(--ck-resizer-size)/-2 - 2px);--ck-resizer-border-width:1px}.ck .ck-widget__resizer{outline:1px solid var(--ck-color-resizer)}.ck .ck-widget__resizer__handle{background:var(--ck-color-focus-border);border:var(--ck-resizer-border-width) solid #fff;border-radius:var(--ck-resizer-border-radius);height:var(--ck-resizer-size);width:var(--ck-resizer-size)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{left:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{right:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right{bottom:var(--ck-resizer-offset);right:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left{bottom:var(--ck-resizer-offset);left:var(--ck-resizer-offset)}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widgetresize.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widgetresize.css",
            ],
            names: [],
            mappings:
              "AAKA,4BAEC,iBACD,CAEA,wBACC,YAAa,CAMb,MAAO,CAFP,mBAAoB,CAHpB,iBAAkB,CAMlB,KACD,CAGC,2EACC,aACD,CAGD,gCAIC,kBAAmB,CAHnB,iBAcD,CATC,4IAEC,kBACD,CAEA,4IAEC,kBACD,CCpCD,MACC,sBAAuB,CAGvB,yDAAiE,CACjE,6BACD,CAEA,wBACC,yCACD,CAEA,gCAGC,uCAAwC,CACxC,gDAA6D,CAC7D,6CAA8C,CAH9C,6BAA8B,CAD9B,4BAyBD,CAnBC,oEAEC,6BAA8B,CAD9B,4BAED,CAEA,qEAEC,8BAA+B,CAD/B,4BAED,CAEA,wEACC,+BAAgC,CAChC,8BACD,CAEA,uEACC,+BAAgC,CAChC,6BACD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-widget_with-resizer {\n\t/* Make the widget wrapper a relative positioning container for the drag handle. */\n\tposition: relative;\n}\n\n.ck .ck-widget__resizer {\n\tdisplay: none;\n\tposition: absolute;\n\n\t/* The wrapper itself should not interfere with the pointer device, only the handles should. */\n\tpointer-events: none;\n\n\tleft: 0;\n\ttop: 0;\n}\n\n.ck-focused .ck-widget_with-resizer.ck-widget_selected {\n\t& > .ck-widget__resizer {\n\t\tdisplay: block;\n\t}\n}\n\n.ck .ck-widget__resizer__handle {\n\tposition: absolute;\n\n\t/* Resizers are the only UI elements that should interfere with a pointer device. */\n\tpointer-events: all;\n\n\t&.ck-widget__resizer__handle-top-left,\n\t&.ck-widget__resizer__handle-bottom-right {\n\t\tcursor: nwse-resize;\n\t}\n\n\t&.ck-widget__resizer__handle-top-right,\n\t&.ck-widget__resizer__handle-bottom-left {\n\t\tcursor: nesw-resize;\n\t}\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-resizer-size: 10px;\n\n\t/* Set the resizer with a 50% offset. */\n\t--ck-resizer-offset: calc( ( var(--ck-resizer-size) / -2 ) - 2px);\n\t--ck-resizer-border-width: 1px;\n}\n\n.ck .ck-widget__resizer {\n\toutline: 1px solid var(--ck-color-resizer);\n}\n\n.ck .ck-widget__resizer__handle {\n\twidth: var(--ck-resizer-size);\n\theight: var(--ck-resizer-size);\n\tbackground: var(--ck-color-focus-border);\n\tborder: var(--ck-resizer-border-width) solid hsl(0, 0%, 100%);\n\tborder-radius: var(--ck-resizer-border-radius);\n\n\t&.ck-widget__resizer__handle-top-left {\n\t\ttop: var(--ck-resizer-offset);\n\t\tleft: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-top-right {\n\t\ttop: var(--ck-resizer-offset);\n\t\tright: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-bottom-right {\n\t\tbottom: var(--ck-resizer-offset);\n\t\tright: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-bottom-left {\n\t\tbottom: var(--ck-resizer-offset);\n\t\tleft: var(--ck-resizer-offset);\n\t}\n}\n",
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      347: (t, e, n) => {
        "use strict";
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          '.ck .ck-widget .ck-widget__type-around__button{display:block;overflow:hidden;position:absolute;z-index:var(--ck-z-default)}.ck .ck-widget .ck-widget__type-around__button svg{left:50%;position:absolute;top:50%;z-index:calc(var(--ck-z-default) + 2)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_before{left:min(10%,30px);top:calc(var(--ck-widget-outline-thickness)*-.5);transform:translateY(-50%)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_after{bottom:calc(var(--ck-widget-outline-thickness)*-.5);right:min(10%,30px);transform:translateY(50%)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{content:"";display:block;left:1px;position:absolute;top:1px;z-index:calc(var(--ck-z-default) + 1)}.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:none;left:0;position:absolute;right:0}.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__fake-caret{left:calc(var(--ck-widget-outline-thickness)*-1);right:calc(var(--ck-widget-outline-thickness)*-1)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:block;top:calc(var(--ck-widget-outline-thickness)*-1 - 1px)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__fake-caret{bottom:calc(var(--ck-widget-outline-thickness)*-1 - 1px);display:block}.ck.ck-editor__editable.ck-read-only .ck-widget__type-around,.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around,.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around{display:none}:root{--ck-widget-type-around-button-size:20px;--ck-color-widget-type-around-button-active:var(--ck-color-focus-border);--ck-color-widget-type-around-button-hover:var(--ck-color-widget-hover-border);--ck-color-widget-type-around-button-blurred-editable:var(--ck-color-widget-blurred-border);--ck-color-widget-type-around-button-radar-start-alpha:0;--ck-color-widget-type-around-button-radar-end-alpha:.3;--ck-color-widget-type-around-button-icon:var(--ck-color-base-background)}.ck .ck-widget .ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button);border-radius:100px;height:var(--ck-widget-type-around-button-size);opacity:0;pointer-events:none;transition:opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);width:var(--ck-widget-type-around-button-size)}.ck .ck-widget .ck-widget__type-around__button svg{height:8px;margin-top:1px;transform:translate(-50%,-50%);transition:transform .5s ease;width:10px}.ck .ck-widget .ck-widget__type-around__button svg *{stroke-dasharray:10;stroke-dashoffset:0;fill:none;stroke:var(--ck-color-widget-type-around-button-icon);stroke-width:1.5px;stroke-linecap:round;stroke-linejoin:round}.ck .ck-widget .ck-widget__type-around__button svg line{stroke-dasharray:7}.ck .ck-widget .ck-widget__type-around__button:hover{animation:ck-widget-type-around-button-sonar 1s ease infinite}.ck .ck-widget .ck-widget__type-around__button:hover svg polyline{animation:ck-widget-type-around-arrow-dash 2s linear}.ck .ck-widget .ck-widget__type-around__button:hover svg line{animation:ck-widget-type-around-arrow-tip-dash 2s linear}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:1;pointer-events:auto}.ck .ck-widget:not(.ck-widget_selected)>.ck-widget__type-around>.ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button-hover)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover{background:var(--ck-color-widget-type-around-button-active)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{background:linear-gradient(135deg,hsla(0,0%,100%,0),hsla(0,0%,100%,.3));border-radius:100px;height:calc(var(--ck-widget-type-around-button-size) - 2px);width:calc(var(--ck-widget-type-around-button-size) - 2px)}.ck .ck-widget.ck-widget_with-selection-handle>.ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:20px}.ck .ck-widget .ck-widget__type-around__fake-caret{animation:ck-widget-type-around-fake-caret-pulse 1s linear infinite normal forwards;background:var(--ck-color-base-text);height:1px;outline:1px solid hsla(0,0%,100%,.5);pointer-events:none}.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_after,.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_before{outline-color:transparent}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected:hover,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{opacity:0}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:0;margin-right:20px}.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover){background:var(--ck-color-widget-type-around-button-blurred-editable)}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover) svg *{stroke:#999}@keyframes ck-widget-type-around-arrow-dash{0%{stroke-dashoffset:10}20%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-arrow-tip-dash{0%,20%{stroke-dashoffset:7}40%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-button-sonar{0%{box-shadow:0 0 0 0 hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}50%{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-end-alpha))}to{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}}@keyframes ck-widget-type-around-fake-caret-pulse{0%{opacity:1}49%{opacity:1}50%{opacity:0}99%{opacity:0}to{opacity:1}}',
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widgettypearound.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widgettypearound.css",
            ],
            names: [],
            mappings:
              "AASC,+CACC,aAAc,CAEd,eAAgB,CADhB,iBAAkB,CAElB,2BAwBD,CAtBC,mDAGC,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAEA,qFAGC,kBAAoB,CADpB,gDAAoD,CAGpD,0BACD,CAEA,oFAEC,mDAAuD,CACvD,mBAAqB,CAErB,yBACD,CAUA,mLACC,UAAW,CACX,aAAc,CAGd,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAMD,2EACC,YAAa,CAEb,MAAO,CADP,iBAAkB,CAElB,OACD,CAOA,iFACC,gDAAqD,CACrD,iDACD,CAKA,wHAEC,aAAc,CADd,qDAED,CAKA,uHACC,wDAA6D,CAC7D,aACD,CAoBD,mOACC,YACD,CC3GA,MACC,wCAAyC,CACzC,wEAAyE,CACzE,8EAA+E,CAC/E,2FAA4F,CAC5F,wDAAyD,CACzD,uDAAwD,CACxD,yEACD,CAgBC,+CAGC,oDAAqD,CACrD,mBAAoB,CAFpB,+CAAgD,CAVjD,SAAU,CACV,mBAAoB,CAYnB,uMAAyM,CAJzM,8CAkDD,CA1CC,mDAEC,UAAW,CAGX,cAAe,CAFf,8BAA+B,CAC/B,6BAA8B,CAH9B,UAoBD,CAdC,qDACC,mBAAoB,CACpB,mBAAoB,CAEpB,SAAU,CACV,qDAAsD,CACtD,kBAAmB,CACnB,oBAAqB,CACrB,qBACD,CAEA,wDACC,kBACD,CAGD,qDAIC,6DAcD,CARE,kEACC,oDACD,CAEA,8DACC,wDACD,CAUF,uKAvED,SAAU,CACV,mBAwEC,CAOD,gGACC,0DACD,CAOA,uKAEC,2DAQD,CANC,mLAIC,uEAAkF,CADlF,mBAAoB,CADpB,2DAA4D,CAD5D,0DAID,CAOD,8GACC,gBACD,CAKA,mDAGC,mFAAoF,CAOpF,oCAAqC,CARrC,UAAW,CAOX,oCAAwC,CARxC,mBAUD,CAOC,6JAEC,yBACD,CAUA,yKACC,iDACD,CAMA,uOAlJD,SAAU,CACV,mBAmJC,CAoBA,6yBACC,SACD,CASF,uHACC,aAAc,CACd,iBACD,CAYG,iRAlMF,SAAU,CACV,mBAmME,CAQH,kIACC,qEAKD,CAHC,wIACC,WACD,CAGD,4CACC,GACC,oBACD,CACA,OACC,mBACD,CACD,CAEA,gDACC,OACC,mBACD,CACA,OACC,mBACD,CACD,CAEA,8CACC,GACC,6HACD,CACA,IACC,6HACD,CACA,GACC,+HACD,CACD,CAEA,kDACC,GACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,GACC,SACD,CACD",
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-widget {\n\t/*\n\t * Styles of the type around buttons\n\t */\n\t& .ck-widget__type-around__button {\n\t\tdisplay: block;\n\t\tposition: absolute;\n\t\toverflow: hidden;\n\t\tz-index: var(--ck-z-default);\n\n\t\t& svg {\n\t\t\tposition: absolute;\n\t\t\ttop: 50%;\n\t\t\tleft: 50%;\n\t\t\tz-index: calc(var(--ck-z-default) + 2);\n\t\t}\n\n\t\t&.ck-widget__type-around__button_before {\n\t\t\t/* Place it in the middle of the outline */\n\t\t\ttop: calc(-0.5 * var(--ck-widget-outline-thickness));\n\t\t\tleft: min(10%, 30px);\n\n\t\t\ttransform: translateY(-50%);\n\t\t}\n\n\t\t&.ck-widget__type-around__button_after {\n\t\t\t/* Place it in the middle of the outline */\n\t\t\tbottom: calc(-0.5 * var(--ck-widget-outline-thickness));\n\t\t\tright: min(10%, 30px);\n\n\t\t\ttransform: translateY(50%);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the buttons when:\n\t * - the widget is selected,\n\t * - or the button is being hovered (regardless of the widget state).\n\t */\n\t&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,\n\t& > .ck-widget__type-around > .ck-widget__type-around__button:hover {\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\tdisplay: block;\n\t\t\tposition: absolute;\n\t\t\ttop: 1px;\n\t\t\tleft: 1px;\n\t\t\tz-index: calc(var(--ck-z-default) + 1);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.\n\t */\n\t& > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tdisplay: none;\n\t\tposition: absolute;\n\t\tleft: 0;\n\t\tright: 0;\n\t}\n\n\t/*\n\t * When the widget is hovered the "fake caret" would normally be narrower than the\n\t * extra outline displayed around the widget. Let\'s extend the "fake caret" to match\n\t * the full width of the widget.\n\t */\n\t&:hover > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tleft: calc( -1 * var(--ck-widget-outline-thickness) );\n\t\tright: calc( -1 * var(--ck-widget-outline-thickness) );\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" when it should be displayed before the widget (backward keyboard navigation).\n\t */\n\t&.ck-widget_type-around_show-fake-caret_before > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\ttop: calc( -1 * var(--ck-widget-outline-thickness) - 1px );\n\t\tdisplay: block;\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" when it should be displayed after the widget (forward keyboard navigation).\n\t */\n\t&.ck-widget_type-around_show-fake-caret_after > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tbottom: calc( -1 * var(--ck-widget-outline-thickness) - 1px );\n\t\tdisplay: block;\n\t}\n}\n\n/*\n * Integration with the read-only mode of the editor.\n */\n.ck.ck-editor__editable.ck-read-only .ck-widget__type-around {\n\tdisplay: none;\n}\n\n/*\n * Integration with the restricted editing mode (feature) of the editor.\n */\n.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around {\n\tdisplay: none;\n}\n\n/*\n * Integration with the #isEnabled property of the WidgetTypeAround plugin.\n */\n.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around {\n\tdisplay: none;\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-widget-type-around-button-size: 20px;\n\t--ck-color-widget-type-around-button-active: var(--ck-color-focus-border);\n\t--ck-color-widget-type-around-button-hover: var(--ck-color-widget-hover-border);\n\t--ck-color-widget-type-around-button-blurred-editable: var(--ck-color-widget-blurred-border);\n\t--ck-color-widget-type-around-button-radar-start-alpha: 0;\n\t--ck-color-widget-type-around-button-radar-end-alpha: .3;\n\t--ck-color-widget-type-around-button-icon: var(--ck-color-base-background);\n}\n\n@define-mixin ck-widget-type-around-button-visible {\n\topacity: 1;\n\tpointer-events: auto;\n}\n\n@define-mixin ck-widget-type-around-button-hidden {\n\topacity: 0;\n\tpointer-events: none;\n}\n\n.ck .ck-widget {\n\t/*\n\t * Styles of the type around buttons\n\t */\n\t& .ck-widget__type-around__button {\n\t\twidth: var(--ck-widget-type-around-button-size);\n\t\theight: var(--ck-widget-type-around-button-size);\n\t\tbackground: var(--ck-color-widget-type-around-button);\n\t\tborder-radius: 100px;\n\t\ttransition: opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve), background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t\t@mixin ck-widget-type-around-button-hidden;\n\n\t\t& svg {\n\t\t\twidth: 10px;\n\t\t\theight: 8px;\n\t\t\ttransform: translate(-50%,-50%);\n\t\t\ttransition: transform .5s ease;\n\t\t\tmargin-top: 1px;\n\n\t\t\t& * {\n\t\t\t\tstroke-dasharray: 10;\n\t\t\t\tstroke-dashoffset: 0;\n\n\t\t\t\tfill: none;\n\t\t\t\tstroke: var(--ck-color-widget-type-around-button-icon);\n\t\t\t\tstroke-width: 1.5px;\n\t\t\t\tstroke-linecap: round;\n\t\t\t\tstroke-linejoin: round;\n\t\t\t}\n\n\t\t\t& line {\n\t\t\t\tstroke-dasharray: 7;\n\t\t\t}\n\t\t}\n\n\t\t&:hover {\n\t\t\t/*\n\t\t\t * Display the "sonar" around the button when hovered.\n\t\t\t */\n\t\t\tanimation: ck-widget-type-around-button-sonar 1s ease infinite;\n\n\t\t\t/*\n\t\t\t * Animate active button\'s icon.\n\t\t\t */\n\t\t\t& svg {\n\t\t\t\t& polyline {\n\t\t\t\t\tanimation: ck-widget-type-around-arrow-dash 2s linear;\n\t\t\t\t}\n\n\t\t\t\t& line {\n\t\t\t\t\tanimation: ck-widget-type-around-arrow-tip-dash 2s linear;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Show type around buttons when the widget gets selected or being hovered.\n\t */\n\t&.ck-widget_selected,\n\t&:hover {\n\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t@mixin ck-widget-type-around-button-visible;\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the buttons when the widget is NOT selected (but the buttons are visible\n\t * and still can be hovered).\n\t */\n\t&:not(.ck-widget_selected) > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\tbackground: var(--ck-color-widget-type-around-button-hover);\n\t}\n\n\t/*\n\t * Styles for the buttons when:\n\t * - the widget is selected,\n\t * - or the button is being hovered (regardless of the widget state).\n\t */\n\t&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,\n\t& > .ck-widget__type-around > .ck-widget__type-around__button:hover {\n\t\tbackground: var(--ck-color-widget-type-around-button-active);\n\n\t\t&::after {\n\t\t\twidth: calc(var(--ck-widget-type-around-button-size) - 2px);\n\t\t\theight: calc(var(--ck-widget-type-around-button-size) - 2px);\n\t\t\tborder-radius: 100px;\n\t\t\tbackground: linear-gradient(135deg, hsla(0,0%,100%,0) 0%, hsla(0,0%,100%,.3) 100%);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the "before" button when the widget has a selection handle. Because some space\n\t * is consumed by the handle, the button must be moved slightly to the right to let it breathe.\n\t */\n\t&.ck-widget_with-selection-handle > .ck-widget__type-around > .ck-widget__type-around__button_before {\n\t\tmargin-left: 20px;\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.\n\t */\n\t& .ck-widget__type-around__fake-caret {\n\t\tpointer-events: none;\n\t\theight: 1px;\n\t\tanimation: ck-widget-type-around-fake-caret-pulse linear 1s infinite normal forwards;\n\n\t\t/*\n\t\t * The semi-transparent-outline+background combo improves the contrast\n\t\t * when the background underneath the fake caret is dark.\n\t\t */\n\t\toutline: solid 1px hsla(0, 0%, 100%, .5);\n\t\tbackground: var(--ck-color-base-text);\n\t}\n\n\t/*\n\t * Styles of the widget when the "fake caret" is blinking (e.g. upon keyboard navigation).\n\t * Despite the widget being physically selected in the model, its outline should disappear.\n\t */\n\t&.ck-widget_selected {\n\t\t&.ck-widget_type-around_show-fake-caret_before,\n\t\t&.ck-widget_type-around_show-fake-caret_after {\n\t\t\toutline-color: transparent;\n\t\t}\n\t}\n\n\t&.ck-widget_type-around_show-fake-caret_before,\n\t&.ck-widget_type-around_show-fake-caret_after {\n\t\t/*\n\t\t * When the "fake caret" is visible we simulate that the widget is not selected\n\t\t * (despite being physically selected), so the outline color should be for the\n\t\t * unselected widget.\n\t\t */\n\t\t&.ck-widget_selected:hover {\n\t\t\toutline-color: var(--ck-color-widget-hover-border);\n\t\t}\n\n\t\t/*\n\t\t * Styles of the type around buttons when the "fake caret" is blinking (e.g. upon keyboard navigation).\n\t\t * In this state, the type around buttons would collide with the fake carets so they should disappear.\n\t\t */\n\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t@mixin ck-widget-type-around-button-hidden;\n\t\t}\n\n\t\t/*\n\t\t * Fake horizontal caret integration with the selection handle. When the caret is visible, simply\n\t\t * hide the handle because it intersects with the caret (and does not make much sense anyway).\n\t\t */\n\t\t&.ck-widget_with-selection-handle {\n\t\t\t&.ck-widget_selected,\n\t\t\t&.ck-widget_selected:hover {\n\t\t\t\t& > .ck-widget__selection-handle {\n\t\t\t\t\topacity: 0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Fake horizontal caret integration with the resize UI. When the caret is visible, simply\n\t\t * hide the resize UI because it creates too much noise. It can be visible when the user\n\t\t * hovers the widget, though.\n\t\t */\n\t\t&.ck-widget_selected.ck-widget_with-resizer > .ck-widget__resizer {\n\t\t\topacity: 0\n\t\t}\n\t}\n}\n\n/*\n * Styles for the "before" button when the widget has a selection handle in an RTL environment.\n * The selection handler is aligned to the right side of the widget so there is no need to create\n * additional space for it next to the "before" button.\n */\n.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around > .ck-widget__type-around__button_before {\n\tmargin-left: 0;\n\tmargin-right: 20px;\n}\n\n/*\n * Hide type around buttons when the widget is selected as a child of a selected\n * nested editable (e.g. mulit-cell table selection).\n *\n * See https://github.com/ckeditor/ckeditor5/issues/7263.\n */\n.ck-editor__nested-editable.ck-editor__editable_selected {\n\t& .ck-widget {\n\t\t&.ck-widget_selected,\n\t\t&:hover {\n\t\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t\t@mixin ck-widget-type-around-button-hidden;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n * Styles for the buttons when the widget is selected but the user clicked outside of the editor (blurred the editor).\n */\n.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button:not(:hover) {\n\tbackground: var(--ck-color-widget-type-around-button-blurred-editable);\n\n\t& svg * {\n\t\tstroke: hsl(0,0%,60%);\n\t}\n}\n\n@keyframes ck-widget-type-around-arrow-dash {\n\t0% {\n\t\tstroke-dashoffset: 10;\n\t}\n\t20%, 100% {\n\t\tstroke-dashoffset: 0;\n\t}\n}\n\n@keyframes ck-widget-type-around-arrow-tip-dash {\n\t0%, 20% {\n\t\tstroke-dashoffset: 7;\n\t}\n\t40%, 100% {\n\t\tstroke-dashoffset: 0;\n\t}\n}\n\n@keyframes ck-widget-type-around-button-sonar {\n\t0% {\n\t\tbox-shadow: 0 0 0 0 hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));\n\t}\n\t50% {\n\t\tbox-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-end-alpha));\n\t}\n\t100% {\n\t\tbox-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));\n\t}\n}\n\n@keyframes ck-widget-type-around-fake-caret-pulse {\n\t0% {\n\t\topacity: 1;\n\t}\n\t49% {\n\t\topacity: 1;\n\t}\n\t50% {\n\t\topacity: 0;\n\t}\n\t99% {\n\t\topacity: 0;\n\t}\n\t100% {\n\t\topacity: 1;\n\t}\n}\n',
            ],
            sourceRoot: "",
          },
        ]);
        const c = a;
      },
      645: (t) => {
        "use strict";
        t.exports = function (t) {
          var e = [];
          e.toString = function e() {
            return this.map(function (e) {
              var n = t(e);
              if (e[2]) {
                return "@media ".concat(e[2], " {").concat(n, "}");
              }
              return n;
            }).join("");
          };
          e.i = function (t, n, o) {
            if (typeof t === "string") {
              t = [[null, t, ""]];
            }
            var i = {};
            if (o) {
              for (var r = 0; r < this.length; r++) {
                var s = this[r][0];
                if (s != null) {
                  i[s] = true;
                }
              }
            }
            for (var a = 0; a < t.length; a++) {
              var c = [].concat(t[a]);
              if (o && i[c[0]]) {
                continue;
              }
              if (n) {
                if (!c[2]) {
                  c[2] = n;
                } else {
                  c[2] = "".concat(n, " and ").concat(c[2]);
                }
              }
              e.push(c);
            }
          };
          return e;
        };
      },
      15: (t) => {
        "use strict";
        function e(t, e) {
          return s(t) || r(t, e) || o(t, e) || n();
        }
        function n() {
          throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
          );
        }
        function o(t, e) {
          if (!t) return;
          if (typeof t === "string") return i(t, e);
          var n = Object.prototype.toString.call(t).slice(8, -1);
          if (n === "Object" && t.constructor) n = t.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(t);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return i(t, e);
        }
        function i(t, e) {
          if (e == null || e > t.length) e = t.length;
          for (var n = 0, o = new Array(e); n < e; n++) {
            o[n] = t[n];
          }
          return o;
        }
        function r(t, e) {
          var n = t && ((typeof Symbol !== "undefined" && t[Symbol.iterator]) || t["@@iterator"]);
          if (n == null) return;
          var o = [];
          var i = true;
          var r = false;
          var s, a;
          try {
            for (n = n.call(t); !(i = (s = n.next()).done); i = true) {
              o.push(s.value);
              if (e && o.length === e) break;
            }
          } catch (t) {
            r = true;
            a = t;
          } finally {
            try {
              if (!i && n["return"] != null) n["return"]();
            } finally {
              if (r) throw a;
            }
          }
          return o;
        }
        function s(t) {
          if (Array.isArray(t)) return t;
        }
        t.exports = function t(n) {
          var o = e(n, 4),
            i = o[1],
            r = o[3];
          if (!r) {
            return i;
          }
          if (typeof btoa === "function") {
            var s = btoa(unescape(encodeURIComponent(JSON.stringify(r))));
            var a = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(s);
            var c = "/*# ".concat(a, " */");
            var l = r.sources.map(function (t) {
              return "/*# sourceURL=".concat(r.sourceRoot || "").concat(t, " */");
            });
            return [i].concat(l).concat([c]).join("\n");
          }
          return [i].join("\n");
        };
      },
      379: (t, e, n) => {
        "use strict";
        var o = (function t() {
          var e;
          return function t() {
            if (typeof e === "undefined") {
              e = Boolean(window && document && document.all && !window.atob);
            }
            return e;
          };
        })();
        var i = (function t() {
          var e = {};
          return function t(n) {
            if (typeof e[n] === "undefined") {
              var o = document.querySelector(n);
              if (window.HTMLIFrameElement && o instanceof window.HTMLIFrameElement) {
                try {
                  o = o.contentDocument.head;
                } catch (t) {
                  o = null;
                }
              }
              e[n] = o;
            }
            return e[n];
          };
        })();
        var r = [];
        function s(t) {
          var e = -1;
          for (var n = 0; n < r.length; n++) {
            if (r[n].identifier === t) {
              e = n;
              break;
            }
          }
          return e;
        }
        function a(t, e) {
          var n = {};
          var o = [];
          for (var i = 0; i < t.length; i++) {
            var a = t[i];
            var c = e.base ? a[0] + e.base : a[0];
            var l = n[c] || 0;
            var d = "".concat(c, " ").concat(l);
            n[c] = l + 1;
            var h = s(d);
            var u = { css: a[1], media: a[2], sourceMap: a[3] };
            if (h !== -1) {
              r[h].references++;
              r[h].updater(u);
            } else {
              r.push({ identifier: d, updater: g(u, e), references: 1 });
            }
            o.push(d);
          }
          return o;
        }
        function c(t) {
          var e = document.createElement("style");
          var o = t.attributes || {};
          if (typeof o.nonce === "undefined") {
            var r = true ? n.nc : 0;
            if (r) {
              o.nonce = r;
            }
          }
          Object.keys(o).forEach(function (t) {
            e.setAttribute(t, o[t]);
          });
          if (typeof t.insert === "function") {
            t.insert(e);
          } else {
            var s = i(t.insert || "head");
            if (!s) {
              throw new Error(
                "Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid."
              );
            }
            s.appendChild(e);
          }
          return e;
        }
        function l(t) {
          if (t.parentNode === null) {
            return false;
          }
          t.parentNode.removeChild(t);
        }
        var d = (function t() {
          var e = [];
          return function t(n, o) {
            e[n] = o;
            return e.filter(Boolean).join("\n");
          };
        })();
        function h(t, e, n, o) {
          var i = n ? "" : o.media ? "@media ".concat(o.media, " {").concat(o.css, "}") : o.css;
          if (t.styleSheet) {
            t.styleSheet.cssText = d(e, i);
          } else {
            var r = document.createTextNode(i);
            var s = t.childNodes;
            if (s[e]) {
              t.removeChild(s[e]);
            }
            if (s.length) {
              t.insertBefore(r, s[e]);
            } else {
              t.appendChild(r);
            }
          }
        }
        function u(t, e, n) {
          var o = n.css;
          var i = n.media;
          var r = n.sourceMap;
          if (i) {
            t.setAttribute("media", i);
          } else {
            t.removeAttribute("media");
          }
          if (r && typeof btoa !== "undefined") {
            o += "\n/*# sourceMappingURL=data:application/json;base64,".concat(
              btoa(unescape(encodeURIComponent(JSON.stringify(r)))),
              " */"
            );
          }
          if (t.styleSheet) {
            t.styleSheet.cssText = o;
          } else {
            while (t.firstChild) {
              t.removeChild(t.firstChild);
            }
            t.appendChild(document.createTextNode(o));
          }
        }
        var f = null;
        var p = 0;
        function g(t, e) {
          var n;
          var o;
          var i;
          if (e.singleton) {
            var r = p++;
            n = f || (f = c(e));
            o = h.bind(null, n, r, false);
            i = h.bind(null, n, r, true);
          } else {
            n = c(e);
            o = u.bind(null, n, e);
            i = function t() {
              l(n);
            };
          }
          o(t);
          return function e(n) {
            if (n) {
              if (n.css === t.css && n.media === t.media && n.sourceMap === t.sourceMap) {
                return;
              }
              o((t = n));
            } else {
              i();
            }
          };
        }
        t.exports = function (t, e) {
          e = e || {};
          if (!e.singleton && typeof e.singleton !== "boolean") {
            e.singleton = o();
          }
          t = t || [];
          var n = a(t, e);
          return function t(o) {
            o = o || [];
            if (Object.prototype.toString.call(o) !== "[object Array]") {
              return;
            }
            for (var i = 0; i < n.length; i++) {
              var c = n[i];
              var l = s(c);
              r[l].references--;
            }
            var d = a(o, e);
            for (var h = 0; h < n.length; h++) {
              var u = n[h];
              var f = s(u);
              if (r[f].references === 0) {
                r[f].updater();
                r.splice(f, 1);
              }
            }
            n = d;
          };
        };
      },
    };
    var e = {};
    function n(o) {
      var i = e[o];
      if (i !== undefined) {
        return i.exports;
      }
      var r = (e[o] = { id: o, exports: {} });
      t[o](r, r.exports, n);
      return r.exports;
    }
    (() => {
      n.n = (t) => {
        var e = t && t.__esModule ? () => t["default"] : () => t;
        n.d(e, { a: e });
        return e;
      };
    })();
    (() => {
      n.d = (t, e) => {
        for (var o in e) {
          if (n.o(e, o) && !n.o(t, o)) {
            Object.defineProperty(t, o, { enumerable: true, get: e[o] });
          }
        }
      };
    })();
    (() => {
      n.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e);
    })();
    (() => {
      n.nc = undefined;
    })();
    var o = {};
    (() => {
      "use strict";
      n.d(o, { default: () => DR });
      function t() {
        try {
          return navigator.userAgent.toLowerCase();
        } catch (t) {
          return "";
        }
      }
      const e = t();
      const i = {
        isMac: s(e),
        isWindows: a(e),
        isGecko: c(e),
        isSafari: l(e),
        isiOS: d(e),
        isAndroid: h(e),
        isBlink: u(e),
        features: { isRegExpUnicodePropertySupported: f() },
      };
      const r = i;
      function s(t) {
        return t.indexOf("macintosh") > -1;
      }
      function a(t) {
        return t.indexOf("windows") > -1;
      }
      function c(t) {
        return !!t.match(/gecko\/\d+/);
      }
      function l(t) {
        return t.indexOf(" applewebkit/") > -1 && t.indexOf("chrome") === -1;
      }
      function d(t) {
        return !!t.match(/iphone|ipad/i) || (s(t) && navigator.maxTouchPoints > 0);
      }
      function h(t) {
        return t.indexOf("android") > -1;
      }
      function u(t) {
        return t.indexOf("chrome/") > -1 && t.indexOf("edge/") < 0;
      }
      function f() {
        let t = false;
        try {
          t = "ć".search(new RegExp("[\\p{L}]", "u")) === 0;
        } catch (t) {}
        return t;
      }
      function p(t, e, n, o) {
        n =
          n ||
          function (t, e) {
            return t === e;
          };
        const i = Array.isArray(t) ? t : Array.prototype.slice.call(t);
        const r = Array.isArray(e) ? e : Array.prototype.slice.call(e);
        const s = g(i, r, n);
        const a = o ? w(s, r.length) : b(r, s);
        return a;
      }
      function g(t, e, n) {
        const o = m(t, e, n);
        if (o === -1) {
          return { firstIndex: -1, lastIndexOld: -1, lastIndexNew: -1 };
        }
        const i = k(t, o);
        const r = k(e, o);
        const s = m(i, r, n);
        const a = t.length - s;
        const c = e.length - s;
        return { firstIndex: o, lastIndexOld: a, lastIndexNew: c };
      }
      function m(t, e, n) {
        for (let o = 0; o < Math.max(t.length, e.length); o++) {
          if (t[o] === undefined || e[o] === undefined || !n(t[o], e[o])) {
            return o;
          }
        }
        return -1;
      }
      function k(t, e) {
        return t.slice(e).reverse();
      }
      function b(t, e) {
        const n = [];
        const { firstIndex: o, lastIndexOld: i, lastIndexNew: r } = e;
        if (r - o > 0) {
          n.push({ index: o, type: "insert", values: t.slice(o, r) });
        }
        if (i - o > 0) {
          n.push({ index: o + (r - o), type: "delete", howMany: i - o });
        }
        return n;
      }
      function w(t, e) {
        const { firstIndex: n, lastIndexOld: o, lastIndexNew: i } = t;
        if (n === -1) {
          return Array(e).fill("equal");
        }
        let r = [];
        if (n > 0) {
          r = r.concat(Array(n).fill("equal"));
        }
        if (i - n > 0) {
          r = r.concat(Array(i - n).fill("insert"));
        }
        if (o - n > 0) {
          r = r.concat(Array(o - n).fill("delete"));
        }
        if (i < e) {
          r = r.concat(Array(e - i).fill("equal"));
        }
        return r;
      }
      function _(t, e, n) {
        n =
          n ||
          function (t, e) {
            return t === e;
          };
        const o = t.length;
        const i = e.length;
        if (o > 200 || i > 200 || o + i > 300) {
          return _.fastDiff(t, e, n, true);
        }
        let r, s;
        if (i < o) {
          const n = t;
          t = e;
          e = n;
          r = "delete";
          s = "insert";
        } else {
          r = "insert";
          s = "delete";
        }
        const a = t.length;
        const c = e.length;
        const l = c - a;
        const d = {};
        const h = {};
        function u(o) {
          const i = (h[o - 1] !== undefined ? h[o - 1] : -1) + 1;
          const l = h[o + 1] !== undefined ? h[o + 1] : -1;
          const u = i > l ? -1 : 1;
          if (d[o + u]) {
            d[o] = d[o + u].slice(0);
          }
          if (!d[o]) {
            d[o] = [];
          }
          d[o].push(i > l ? r : s);
          let f = Math.max(i, l);
          let p = f - o;
          while (p < a && f < c && n(t[p], e[f])) {
            p++;
            f++;
            d[o].push("equal");
          }
          return f;
        }
        let f = 0;
        let p;
        do {
          for (p = -f; p < l; p++) {
            h[p] = u(p);
          }
          for (p = l + f; p > l; p--) {
            h[p] = u(p);
          }
          h[l] = u(l);
          f++;
        } while (h[l] !== c);
        return d[l].slice(1);
      }
      _.fastDiff = p;
      function v() {
        return function t() {
          t.called = true;
        };
      }
      const A = v;
      class C {
        constructor(t, e) {
          this.source = t;
          this.name = e;
          this.path = [];
          this.stop = A();
          this.off = A();
        }
      }
      const y = new Array(256).fill("").map((t, e) => ("0" + e.toString(16)).slice(-2));
      function x() {
        const t = (Math.random() * 4294967296) >>> 0;
        const e = (Math.random() * 4294967296) >>> 0;
        const n = (Math.random() * 4294967296) >>> 0;
        const o = (Math.random() * 4294967296) >>> 0;
        return (
          "e" +
          y[(t >> 0) & 255] +
          y[(t >> 8) & 255] +
          y[(t >> 16) & 255] +
          y[(t >> 24) & 255] +
          y[(e >> 0) & 255] +
          y[(e >> 8) & 255] +
          y[(e >> 16) & 255] +
          y[(e >> 24) & 255] +
          y[(n >> 0) & 255] +
          y[(n >> 8) & 255] +
          y[(n >> 16) & 255] +
          y[(n >> 24) & 255] +
          y[(o >> 0) & 255] +
          y[(o >> 8) & 255] +
          y[(o >> 16) & 255] +
          y[(o >> 24) & 255]
        );
      }
      const E = {
        get(t = "normal") {
          if (typeof t != "number") {
            return this[t] || this.normal;
          } else {
            return t;
          }
        },
        highest: 1e5,
        high: 1e3,
        normal: 0,
        low: -1e3,
        lowest: -1e5,
      };
      const D = E;
      function S(t, e) {
        const n = D.get(e.priority);
        for (let o = 0; o < t.length; o++) {
          if (D.get(t[o].priority) < n) {
            t.splice(o, 0, e);
            return;
          }
        }
        t.push(e);
      }
      const T = "https://ckeditor.com/docs/ckeditor5/latest/support/error-codes.html";
      class P extends Error {
        constructor(t, e, n) {
          super(I(t, n));
          this.name = "CKEditorError";
          this.context = e;
          this.data = n;
        }
        is(t) {
          return t === "CKEditorError";
        }
        static rethrowUnexpectedError(t, e) {
          if (t.is && t.is("CKEditorError")) {
            throw t;
          }
          const n = new P(t.message, e);
          n.stack = t.stack;
          throw n;
        }
      }
      function B(t, e) {
        console.warn(...z(t, e));
      }
      function O(t, e) {
        console.error(...z(t, e));
      }
      function R(t) {
        return `\nRead more: ${T}#error-${t}`;
      }
      function I(t, e) {
        const n = new WeakSet();
        const o = (t, e) => {
          if (typeof e === "object" && e !== null) {
            if (n.has(e)) {
              return `[object ${e.constructor.name}]`;
            }
            n.add(e);
          }
          return e;
        };
        const i = e ? ` ${JSON.stringify(e, o)}` : "";
        const r = R(t);
        return t + i + r;
      }
      function z(t, e) {
        const n = R(t);
        return e ? [t, e, n] : [t, n];
      }
      const F = "40.0.0";
      const M = null && F;
      const N = new Date(2023, 9, 4);
      if (globalThis.CKEDITOR_VERSION) {
        throw new P("ckeditor-duplicated-modules", null);
      } else {
        globalThis.CKEDITOR_VERSION = F;
      }
      const V = Symbol("listeningTo");
      const L = Symbol("emitterId");
      const H = Symbol("delegations");
      const j = q(Object);
      function q(t) {
        if (!t) {
          return j;
        }
        class e extends t {
          on(t, e, n) {
            this.listenTo(this, t, e, n);
          }
          once(t, e, n) {
            let o = false;
            const i = (t, ...n) => {
              if (!o) {
                o = true;
                t.off();
                e.call(this, t, ...n);
              }
            };
            this.listenTo(this, t, i, n);
          }
          off(t, e) {
            this.stopListening(this, t, e);
          }
          listenTo(t, e, n, o = {}) {
            let i, r;
            if (!this[V]) {
              this[V] = {};
            }
            const s = this[V];
            if (!G(t)) {
              W(t);
            }
            const a = G(t);
            if (!(i = s[a])) {
              i = s[a] = { emitter: t, callbacks: {} };
            }
            if (!(r = i.callbacks[e])) {
              r = i.callbacks[e] = [];
            }
            r.push(n);
            X(this, t, e, n, o);
          }
          stopListening(t, e, n) {
            const o = this[V];
            let i = t && G(t);
            const r = o && i ? o[i] : undefined;
            const s = r && e ? r.callbacks[e] : undefined;
            if (!o || (t && !r) || (e && !s)) {
              return;
            }
            if (n) {
              tt(this, t, e, n);
              const o = s.indexOf(n);
              if (o !== -1) {
                if (s.length === 1) {
                  delete r.callbacks[e];
                } else {
                  tt(this, t, e, n);
                }
              }
            } else if (s) {
              while ((n = s.pop())) {
                tt(this, t, e, n);
              }
              delete r.callbacks[e];
            } else if (r) {
              for (e in r.callbacks) {
                this.stopListening(t, e);
              }
              delete o[i];
            } else {
              for (i in o) {
                this.stopListening(o[i].emitter);
              }
              delete this[V];
            }
          }
          fire(t, ...e) {
            try {
              const n = t instanceof C ? t : new C(this, t);
              const o = n.name;
              let i = Y(this, o);
              n.path.push(this);
              if (i) {
                const t = [n, ...e];
                i = Array.from(i);
                for (let e = 0; e < i.length; e++) {
                  i[e].callback.apply(this, t);
                  if (n.off.called) {
                    delete n.off.called;
                    this._removeEventListener(o, i[e].callback);
                  }
                  if (n.stop.called) {
                    break;
                  }
                }
              }
              const r = this[H];
              if (r) {
                const t = r.get(o);
                const i = r.get("*");
                if (t) {
                  Q(t, n, e);
                }
                if (i) {
                  Q(i, n, e);
                }
              }
              return n.return;
            } catch (t) {
              P.rethrowUnexpectedError(t, this);
            }
          }
          delegate(...t) {
            return {
              to: (e, n) => {
                if (!this[H]) {
                  this[H] = new Map();
                }
                t.forEach((t) => {
                  const o = this[H].get(t);
                  if (!o) {
                    this[H].set(t, new Map([[e, n]]));
                  } else {
                    o.set(e, n);
                  }
                });
              },
            };
          }
          stopDelegating(t, e) {
            if (!this[H]) {
              return;
            }
            if (!t) {
              this[H].clear();
            } else if (!e) {
              this[H].delete(t);
            } else {
              const n = this[H].get(t);
              if (n) {
                n.delete(e);
              }
            }
          }
          _addEventListener(t, e, n) {
            Z(this, t);
            const o = J(this, t);
            const i = D.get(n.priority);
            const r = { callback: e, priority: i };
            for (const t of o) {
              S(t, r);
            }
          }
          _removeEventListener(t, e) {
            const n = J(this, t);
            for (const t of n) {
              for (let n = 0; n < t.length; n++) {
                if (t[n].callback == e) {
                  t.splice(n, 1);
                  n--;
                }
              }
            }
          }
        }
        return e;
      }
      [
        "on",
        "once",
        "off",
        "listenTo",
        "stopListening",
        "fire",
        "delegate",
        "stopDelegating",
        "_addEventListener",
        "_removeEventListener",
      ].forEach((t) => {
        q[t] = j.prototype[t];
      });
      function $(t, e) {
        const n = t[V];
        if (n && n[e]) {
          return n[e].emitter;
        }
        return null;
      }
      function W(t, e) {
        if (!t[L]) {
          t[L] = e || x();
        }
      }
      function G(t) {
        return t[L];
      }
      function K(t) {
        if (!t._events) {
          Object.defineProperty(t, "_events", { value: {} });
        }
        return t._events;
      }
      function U() {
        return { callbacks: [], childEvents: [] };
      }
      function Z(t, e) {
        const n = K(t);
        if (n[e]) {
          return;
        }
        let o = e;
        let i = null;
        const r = [];
        while (o !== "") {
          if (n[o]) {
            break;
          }
          n[o] = U();
          r.push(n[o]);
          if (i) {
            n[o].childEvents.push(i);
          }
          i = o;
          o = o.substr(0, o.lastIndexOf(":"));
        }
        if (o !== "") {
          for (const t of r) {
            t.callbacks = n[o].callbacks.slice();
          }
          n[o].childEvents.push(i);
        }
      }
      function J(t, e) {
        const n = K(t)[e];
        if (!n) {
          return [];
        }
        let o = [n.callbacks];
        for (let e = 0; e < n.childEvents.length; e++) {
          const i = J(t, n.childEvents[e]);
          o = o.concat(i);
        }
        return o;
      }
      function Y(t, e) {
        let n;
        if (!t._events || !(n = t._events[e]) || !n.callbacks.length) {
          if (e.indexOf(":") > -1) {
            return Y(t, e.substr(0, e.lastIndexOf(":")));
          } else {
            return null;
          }
        }
        return n.callbacks;
      }
      function Q(t, e, n) {
        for (let [o, i] of t) {
          if (!i) {
            i = e.name;
          } else if (typeof i == "function") {
            i = i(e.name);
          }
          const t = new C(e.source, i);
          t.path = [...e.path];
          o.fire(t, ...n);
        }
      }
      function X(t, e, n, o, i) {
        if (e._addEventListener) {
          e._addEventListener(n, o, i);
        } else {
          t._addEventListener.call(e, n, o, i);
        }
      }
      function tt(t, e, n, o) {
        if (e._removeEventListener) {
          e._removeEventListener(n, o);
        } else {
          t._removeEventListener.call(e, n, o);
        }
      }
      function et(t) {
        var e = typeof t;
        return t != null && (e == "object" || e == "function");
      }
      const nt = et;
      const ot = Symbol("observableProperties");
      const it = Symbol("boundObservables");
      const rt = Symbol("boundProperties");
      const st = Symbol("decoratedMethods");
      const at = Symbol("decoratedOriginal");
      const ct = lt(q());
      function lt(t) {
        if (!t) {
          return ct;
        }
        class e extends t {
          set(t, e) {
            if (nt(t)) {
              Object.keys(t).forEach((e) => {
                this.set(e, t[e]);
              }, this);
              return;
            }
            dt(this);
            const n = this[ot];
            if (t in this && !n.has(t)) {
              throw new P("observable-set-cannot-override", this);
            }
            Object.defineProperty(this, t, {
              enumerable: true,
              configurable: true,
              get() {
                return n.get(t);
              },
              set(e) {
                const o = n.get(t);
                let i = this.fire(`set:${t}`, t, e, o);
                if (i === undefined) {
                  i = e;
                }
                if (o !== i || !n.has(t)) {
                  n.set(t, i);
                  this.fire(`change:${t}`, t, i, o);
                }
              },
            });
            this[t] = e;
          }
          bind(...t) {
            if (!t.length || !pt(t)) {
              throw new P("observable-bind-wrong-properties", this);
            }
            if (new Set(t).size !== t.length) {
              throw new P("observable-bind-duplicate-properties", this);
            }
            dt(this);
            const e = this[rt];
            t.forEach((t) => {
              if (e.has(t)) {
                throw new P("observable-bind-rebind", this);
              }
            });
            const n = new Map();
            t.forEach((t) => {
              const o = { property: t, to: [] };
              e.set(t, o);
              n.set(t, o);
            });
            return {
              to: ht,
              toMany: ut,
              _observable: this,
              _bindProperties: t,
              _to: [],
              _bindings: n,
            };
          }
          unbind(...t) {
            if (!this[ot]) {
              return;
            }
            const e = this[rt];
            const n = this[it];
            if (t.length) {
              if (!pt(t)) {
                throw new P("observable-unbind-wrong-properties", this);
              }
              t.forEach((t) => {
                const o = e.get(t);
                if (!o) {
                  return;
                }
                o.to.forEach(([t, e]) => {
                  const i = n.get(t);
                  const r = i[e];
                  r.delete(o);
                  if (!r.size) {
                    delete i[e];
                  }
                  if (!Object.keys(i).length) {
                    n.delete(t);
                    this.stopListening(t, "change");
                  }
                });
                e.delete(t);
              });
            } else {
              n.forEach((t, e) => {
                this.stopListening(e, "change");
              });
              n.clear();
              e.clear();
            }
          }
          decorate(t) {
            dt(this);
            const e = this[t];
            if (!e) {
              throw new P("observablemixin-cannot-decorate-undefined", this, {
                object: this,
                methodName: t,
              });
            }
            this.on(t, (t, n) => {
              t.return = e.apply(this, n);
            });
            this[t] = function (...e) {
              return this.fire(t, e);
            };
            this[t][at] = e;
            if (!this[st]) {
              this[st] = [];
            }
            this[st].push(t);
          }
          stopListening(t, e, n) {
            if (!t && this[st]) {
              for (const t of this[st]) {
                this[t] = this[t][at];
              }
              delete this[st];
            }
            super.stopListening(t, e, n);
          }
        }
        return e;
      }
      [
        "set",
        "bind",
        "unbind",
        "decorate",
        "on",
        "once",
        "off",
        "listenTo",
        "stopListening",
        "fire",
        "delegate",
        "stopDelegating",
        "_addEventListener",
        "_removeEventListener",
      ].forEach((t) => {
        lt[t] = ct.prototype[t];
      });
      function dt(t) {
        if (t[ot]) {
          return;
        }
        Object.defineProperty(t, ot, { value: new Map() });
        Object.defineProperty(t, it, { value: new Map() });
        Object.defineProperty(t, rt, { value: new Map() });
      }
      function ht(...t) {
        const e = gt(...t);
        const n = Array.from(this._bindings.keys());
        const o = n.length;
        if (!e.callback && e.to.length > 1) {
          throw new P("observable-bind-to-no-callback", this);
        }
        if (o > 1 && e.callback) {
          throw new P("observable-bind-to-extra-callback", this);
        }
        e.to.forEach((t) => {
          if (t.properties.length && t.properties.length !== o) {
            throw new P("observable-bind-to-properties-length", this);
          }
          if (!t.properties.length) {
            t.properties = this._bindProperties;
          }
        });
        this._to = e.to;
        if (e.callback) {
          this._bindings.get(n[0]).callback = e.callback;
        }
        wt(this._observable, this._to);
        kt(this);
        this._bindProperties.forEach((t) => {
          bt(this._observable, t);
        });
      }
      function ut(t, e, n) {
        if (this._bindings.size > 1) {
          throw new P("observable-bind-to-many-not-one-binding", this);
        }
        this.to(...ft(t, e), n);
      }
      function ft(t, e) {
        const n = t.map((t) => [t, e]);
        return Array.prototype.concat.apply([], n);
      }
      function pt(t) {
        return t.every((t) => typeof t == "string");
      }
      function gt(...t) {
        if (!t.length) {
          throw new P("observable-bind-to-parse-error", null);
        }
        const e = { to: [] };
        let n;
        if (typeof t[t.length - 1] == "function") {
          e.callback = t.pop();
        }
        t.forEach((t) => {
          if (typeof t == "string") {
            n.properties.push(t);
          } else if (typeof t == "object") {
            n = { observable: t, properties: [] };
            e.to.push(n);
          } else {
            throw new P("observable-bind-to-parse-error", null);
          }
        });
        return e;
      }
      function mt(t, e, n, o) {
        const i = t[it];
        const r = i.get(n);
        const s = r || {};
        if (!s[o]) {
          s[o] = new Set();
        }
        s[o].add(e);
        if (!r) {
          i.set(n, s);
        }
      }
      function kt(t) {
        let e;
        t._bindings.forEach((n, o) => {
          t._to.forEach((i) => {
            e = i.properties[n.callback ? 0 : t._bindProperties.indexOf(o)];
            n.to.push([i.observable, e]);
            mt(t._observable, n, i.observable, e);
          });
        });
      }
      function bt(t, e) {
        const n = t[rt];
        const o = n.get(e);
        let i;
        if (o.callback) {
          i = o.callback.apply(
            t,
            o.to.map((t) => t[0][t[1]])
          );
        } else {
          i = o.to[0];
          i = i[0][i[1]];
        }
        if (Object.prototype.hasOwnProperty.call(t, e)) {
          t[e] = i;
        } else {
          t.set(e, i);
        }
      }
      function wt(t, e) {
        e.forEach((e) => {
          const n = t[it];
          let o;
          if (!n.get(e.observable)) {
            t.listenTo(e.observable, "change", (i, r) => {
              o = n.get(e.observable)[r];
              if (o) {
                o.forEach((e) => {
                  bt(t, e.property);
                });
              }
            });
          }
        });
      }
      class _t {
        constructor() {
          this._replacedElements = [];
        }
        replace(t, e) {
          this._replacedElements.push({ element: t, newElement: e });
          t.style.display = "none";
          if (e) {
            t.parentNode.insertBefore(e, t.nextSibling);
          }
        }
        restore() {
          this._replacedElements.forEach(({ element: t, newElement: e }) => {
            t.style.display = "";
            if (e) {
              e.remove();
            }
          });
          this._replacedElements = [];
        }
      }
      function vt(t) {
        let e = 0;
        for (const n of t) {
          e++;
        }
        return e;
      }
      function At(t, e) {
        const n = Math.min(t.length, e.length);
        for (let o = 0; o < n; o++) {
          if (t[o] != e[o]) {
            return o;
          }
        }
        if (t.length == e.length) {
          return "same";
        } else if (t.length < e.length) {
          return "prefix";
        } else {
          return "extension";
        }
      }
      function Ct(t) {
        return !!(t && t[Symbol.iterator]);
      }
      var yt = typeof global == "object" && global && global.Object === Object && global;
      const xt = yt;
      var Et = typeof self == "object" && self && self.Object === Object && self;
      var Dt = xt || Et || Function("return this")();
      const St = Dt;
      var Tt = St.Symbol;
      const Pt = Tt;
      var Bt = Object.prototype;
      var Ot = Bt.hasOwnProperty;
      var Rt = Bt.toString;
      var It = Pt ? Pt.toStringTag : undefined;
      function zt(t) {
        var e = Ot.call(t, It),
          n = t[It];
        try {
          t[It] = undefined;
          var o = true;
        } catch (t) {}
        var i = Rt.call(t);
        if (o) {
          if (e) {
            t[It] = n;
          } else {
            delete t[It];
          }
        }
        return i;
      }
      const Ft = zt;
      var Mt = Object.prototype;
      var Nt = Mt.toString;
      function Vt(t) {
        return Nt.call(t);
      }
      const Lt = Vt;
      var Ht = "[object Null]",
        jt = "[object Undefined]";
      var qt = Pt ? Pt.toStringTag : undefined;
      function $t(t) {
        if (t == null) {
          return t === undefined ? jt : Ht;
        }
        return qt && qt in Object(t) ? Ft(t) : Lt(t);
      }
      const Wt = $t;
      var Gt = Array.isArray;
      const Kt = Gt;
      function Ut(t) {
        return t != null && typeof t == "object";
      }
      const Zt = Ut;
      var Jt = "[object String]";
      function Yt(t) {
        return typeof t == "string" || (!Kt(t) && Zt(t) && Wt(t) == Jt);
      }
      const Qt = Yt;
      function Xt(t, e, n = {}, o = []) {
        const i = n && n.xmlns;
        const r = i ? t.createElementNS(i, e) : t.createElement(e);
        for (const t in n) {
          r.setAttribute(t, n[t]);
        }
        if (Qt(o) || !Ct(o)) {
          o = [o];
        }
        for (let e of o) {
          if (Qt(e)) {
            e = t.createTextNode(e);
          }
          r.appendChild(e);
        }
        return r;
      }
      function te(t, e) {
        return function (n) {
          return t(e(n));
        };
      }
      const ee = te;
      var ne = ee(Object.getPrototypeOf, Object);
      const oe = ne;
      var ie = "[object Object]";
      var re = Function.prototype,
        se = Object.prototype;
      var ae = re.toString;
      var ce = se.hasOwnProperty;
      var le = ae.call(Object);
      function de(t) {
        if (!Zt(t) || Wt(t) != ie) {
          return false;
        }
        var e = oe(t);
        if (e === null) {
          return true;
        }
        var n = ce.call(e, "constructor") && e.constructor;
        return typeof n == "function" && n instanceof n && ae.call(n) == le;
      }
      const he = de;
      function ue() {
        this.__data__ = [];
        this.size = 0;
      }
      const fe = ue;
      function pe(t, e) {
        return t === e || (t !== t && e !== e);
      }
      const ge = pe;
      function me(t, e) {
        var n = t.length;
        while (n--) {
          if (ge(t[n][0], e)) {
            return n;
          }
        }
        return -1;
      }
      const ke = me;
      var be = Array.prototype;
      var we = be.splice;
      function _e(t) {
        var e = this.__data__,
          n = ke(e, t);
        if (n < 0) {
          return false;
        }
        var o = e.length - 1;
        if (n == o) {
          e.pop();
        } else {
          we.call(e, n, 1);
        }
        --this.size;
        return true;
      }
      const ve = _e;
      function Ae(t) {
        var e = this.__data__,
          n = ke(e, t);
        return n < 0 ? undefined : e[n][1];
      }
      const Ce = Ae;
      function ye(t) {
        return ke(this.__data__, t) > -1;
      }
      const xe = ye;
      function Ee(t, e) {
        var n = this.__data__,
          o = ke(n, t);
        if (o < 0) {
          ++this.size;
          n.push([t, e]);
        } else {
          n[o][1] = e;
        }
        return this;
      }
      const De = Ee;
      function Se(t) {
        var e = -1,
          n = t == null ? 0 : t.length;
        this.clear();
        while (++e < n) {
          var o = t[e];
          this.set(o[0], o[1]);
        }
      }
      Se.prototype.clear = fe;
      Se.prototype["delete"] = ve;
      Se.prototype.get = Ce;
      Se.prototype.has = xe;
      Se.prototype.set = De;
      const Te = Se;
      function Pe() {
        this.__data__ = new Te();
        this.size = 0;
      }
      const Be = Pe;
      function Oe(t) {
        var e = this.__data__,
          n = e["delete"](t);
        this.size = e.size;
        return n;
      }
      const Re = Oe;
      function Ie(t) {
        return this.__data__.get(t);
      }
      const ze = Ie;
      function Fe(t) {
        return this.__data__.has(t);
      }
      const Me = Fe;
      var Ne = "[object AsyncFunction]",
        Ve = "[object Function]",
        Le = "[object GeneratorFunction]",
        He = "[object Proxy]";
      function je(t) {
        if (!nt(t)) {
          return false;
        }
        var e = Wt(t);
        return e == Ve || e == Le || e == Ne || e == He;
      }
      const qe = je;
      var $e = St["__core-js_shared__"];
      const We = $e;
      var Ge = (function () {
        var t = /[^.]+$/.exec((We && We.keys && We.keys.IE_PROTO) || "");
        return t ? "Symbol(src)_1." + t : "";
      })();
      function Ke(t) {
        return !!Ge && Ge in t;
      }
      const Ue = Ke;
      var Ze = Function.prototype;
      var Je = Ze.toString;
      function Ye(t) {
        if (t != null) {
          try {
            return Je.call(t);
          } catch (t) {}
          try {
            return t + "";
          } catch (t) {}
        }
        return "";
      }
      const Qe = Ye;
      var Xe = /[\\^$.*+?()[\]{}|]/g;
      var tn = /^\[object .+?Constructor\]$/;
      var en = Function.prototype,
        nn = Object.prototype;
      var on = en.toString;
      var rn = nn.hasOwnProperty;
      var sn = RegExp(
        "^" +
          on
            .call(rn)
            .replace(Xe, "\\$&")
            .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") +
          "$"
      );
      function an(t) {
        if (!nt(t) || Ue(t)) {
          return false;
        }
        var e = qe(t) ? sn : tn;
        return e.test(Qe(t));
      }
      const cn = an;
      function ln(t, e) {
        return t == null ? undefined : t[e];
      }
      const dn = ln;
      function hn(t, e) {
        var n = dn(t, e);
        return cn(n) ? n : undefined;
      }
      const un = hn;
      var fn = un(St, "Map");
      const pn = fn;
      var gn = un(Object, "create");
      const mn = gn;
      function kn() {
        this.__data__ = mn ? mn(null) : {};
        this.size = 0;
      }
      const bn = kn;
      function wn(t) {
        var e = this.has(t) && delete this.__data__[t];
        this.size -= e ? 1 : 0;
        return e;
      }
      const _n = wn;
      var vn = "__lodash_hash_undefined__";
      var An = Object.prototype;
      var Cn = An.hasOwnProperty;
      function yn(t) {
        var e = this.__data__;
        if (mn) {
          var n = e[t];
          return n === vn ? undefined : n;
        }
        return Cn.call(e, t) ? e[t] : undefined;
      }
      const xn = yn;
      var En = Object.prototype;
      var Dn = En.hasOwnProperty;
      function Sn(t) {
        var e = this.__data__;
        return mn ? e[t] !== undefined : Dn.call(e, t);
      }
      const Tn = Sn;
      var Pn = "__lodash_hash_undefined__";
      function Bn(t, e) {
        var n = this.__data__;
        this.size += this.has(t) ? 0 : 1;
        n[t] = mn && e === undefined ? Pn : e;
        return this;
      }
      const On = Bn;
      function Rn(t) {
        var e = -1,
          n = t == null ? 0 : t.length;
        this.clear();
        while (++e < n) {
          var o = t[e];
          this.set(o[0], o[1]);
        }
      }
      Rn.prototype.clear = bn;
      Rn.prototype["delete"] = _n;
      Rn.prototype.get = xn;
      Rn.prototype.has = Tn;
      Rn.prototype.set = On;
      const In = Rn;
      function zn() {
        this.size = 0;
        this.__data__ = { hash: new In(), map: new (pn || Te)(), string: new In() };
      }
      const Fn = zn;
      function Mn(t) {
        var e = typeof t;
        return e == "string" || e == "number" || e == "symbol" || e == "boolean"
          ? t !== "__proto__"
          : t === null;
      }
      const Nn = Mn;
      function Vn(t, e) {
        var n = t.__data__;
        return Nn(e) ? n[typeof e == "string" ? "string" : "hash"] : n.map;
      }
      const Ln = Vn;
      function Hn(t) {
        var e = Ln(this, t)["delete"](t);
        this.size -= e ? 1 : 0;
        return e;
      }
      const jn = Hn;
      function qn(t) {
        return Ln(this, t).get(t);
      }
      const $n = qn;
      function Wn(t) {
        return Ln(this, t).has(t);
      }
      const Gn = Wn;
      function Kn(t, e) {
        var n = Ln(this, t),
          o = n.size;
        n.set(t, e);
        this.size += n.size == o ? 0 : 1;
        return this;
      }
      const Un = Kn;
      function Zn(t) {
        var e = -1,
          n = t == null ? 0 : t.length;
        this.clear();
        while (++e < n) {
          var o = t[e];
          this.set(o[0], o[1]);
        }
      }
      Zn.prototype.clear = Fn;
      Zn.prototype["delete"] = jn;
      Zn.prototype.get = $n;
      Zn.prototype.has = Gn;
      Zn.prototype.set = Un;
      const Jn = Zn;
      var Yn = 200;
      function Qn(t, e) {
        var n = this.__data__;
        if (n instanceof Te) {
          var o = n.__data__;
          if (!pn || o.length < Yn - 1) {
            o.push([t, e]);
            this.size = ++n.size;
            return this;
          }
          n = this.__data__ = new Jn(o);
        }
        n.set(t, e);
        this.size = n.size;
        return this;
      }
      const Xn = Qn;
      function to(t) {
        var e = (this.__data__ = new Te(t));
        this.size = e.size;
      }
      to.prototype.clear = Be;
      to.prototype["delete"] = Re;
      to.prototype.get = ze;
      to.prototype.has = Me;
      to.prototype.set = Xn;
      const eo = to;
      function no(t, e) {
        var n = -1,
          o = t == null ? 0 : t.length;
        while (++n < o) {
          if (e(t[n], n, t) === false) {
            break;
          }
        }
        return t;
      }
      const oo = no;
      var io = (function () {
        try {
          var t = un(Object, "defineProperty");
          t({}, "", {});
          return t;
        } catch (t) {}
      })();
      const ro = io;
      function so(t, e, n) {
        if (e == "__proto__" && ro) {
          ro(t, e, { configurable: true, enumerable: true, value: n, writable: true });
        } else {
          t[e] = n;
        }
      }
      const ao = so;
      var co = Object.prototype;
      var lo = co.hasOwnProperty;
      function ho(t, e, n) {
        var o = t[e];
        if (!(lo.call(t, e) && ge(o, n)) || (n === undefined && !(e in t))) {
          ao(t, e, n);
        }
      }
      const uo = ho;
      function fo(t, e, n, o) {
        var i = !n;
        n || (n = {});
        var r = -1,
          s = e.length;
        while (++r < s) {
          var a = e[r];
          var c = o ? o(n[a], t[a], a, n, t) : undefined;
          if (c === undefined) {
            c = t[a];
          }
          if (i) {
            ao(n, a, c);
          } else {
            uo(n, a, c);
          }
        }
        return n;
      }
      const po = fo;
      function go(t, e) {
        var n = -1,
          o = Array(t);
        while (++n < t) {
          o[n] = e(n);
        }
        return o;
      }
      const mo = go;
      var ko = "[object Arguments]";
      function bo(t) {
        return Zt(t) && Wt(t) == ko;
      }
      const wo = bo;
      var _o = Object.prototype;
      var vo = _o.hasOwnProperty;
      var Ao = _o.propertyIsEnumerable;
      var Co = wo(
        (function () {
          return arguments;
        })()
      )
        ? wo
        : function (t) {
            return Zt(t) && vo.call(t, "callee") && !Ao.call(t, "callee");
          };
      const yo = Co;
      function xo() {
        return false;
      }
      const Eo = xo;
      var Do = typeof exports == "object" && exports && !exports.nodeType && exports;
      var So = Do && typeof module == "object" && module && !module.nodeType && module;
      var To = So && So.exports === Do;
      var Po = To ? St.Buffer : undefined;
      var Bo = Po ? Po.isBuffer : undefined;
      var Oo = Bo || Eo;
      const Ro = Oo;
      var Io = 9007199254740991;
      var zo = /^(?:0|[1-9]\d*)$/;
      function Fo(t, e) {
        var n = typeof t;
        e = e == null ? Io : e;
        return (
          !!e && (n == "number" || (n != "symbol" && zo.test(t))) && t > -1 && t % 1 == 0 && t < e
        );
      }
      const Mo = Fo;
      var No = 9007199254740991;
      function Vo(t) {
        return typeof t == "number" && t > -1 && t % 1 == 0 && t <= No;
      }
      const Lo = Vo;
      var Ho = "[object Arguments]",
        jo = "[object Array]",
        qo = "[object Boolean]",
        $o = "[object Date]",
        Wo = "[object Error]",
        Go = "[object Function]",
        Ko = "[object Map]",
        Uo = "[object Number]",
        Zo = "[object Object]",
        Jo = "[object RegExp]",
        Yo = "[object Set]",
        Qo = "[object String]",
        Xo = "[object WeakMap]";
      var ti = "[object ArrayBuffer]",
        ei = "[object DataView]",
        ni = "[object Float32Array]",
        oi = "[object Float64Array]",
        ii = "[object Int8Array]",
        ri = "[object Int16Array]",
        si = "[object Int32Array]",
        ai = "[object Uint8Array]",
        ci = "[object Uint8ClampedArray]",
        li = "[object Uint16Array]",
        di = "[object Uint32Array]";
      var hi = {};
      hi[ni] = hi[oi] = hi[ii] = hi[ri] = hi[si] = hi[ai] = hi[ci] = hi[li] = hi[di] = true;
      hi[Ho] =
        hi[jo] =
        hi[ti] =
        hi[qo] =
        hi[ei] =
        hi[$o] =
        hi[Wo] =
        hi[Go] =
        hi[Ko] =
        hi[Uo] =
        hi[Zo] =
        hi[Jo] =
        hi[Yo] =
        hi[Qo] =
        hi[Xo] =
          false;
      function ui(t) {
        return Zt(t) && Lo(t.length) && !!hi[Wt(t)];
      }
      const fi = ui;
      function pi(t) {
        return function (e) {
          return t(e);
        };
      }
      const gi = pi;
      var mi = typeof exports == "object" && exports && !exports.nodeType && exports;
      var ki = mi && typeof module == "object" && module && !module.nodeType && module;
      var bi = ki && ki.exports === mi;
      var wi = bi && xt.process;
      var _i = (function () {
        try {
          var t = ki && ki.require && ki.require("util").types;
          if (t) {
            return t;
          }
          return wi && wi.binding && wi.binding("util");
        } catch (t) {}
      })();
      const vi = _i;
      var Ai = vi && vi.isTypedArray;
      var Ci = Ai ? gi(Ai) : fi;
      const yi = Ci;
      var xi = Object.prototype;
      var Ei = xi.hasOwnProperty;
      function Di(t, e) {
        var n = Kt(t),
          o = !n && yo(t),
          i = !n && !o && Ro(t),
          r = !n && !o && !i && yi(t),
          s = n || o || i || r,
          a = s ? mo(t.length, String) : [],
          c = a.length;
        for (var l in t) {
          if (
            (e || Ei.call(t, l)) &&
            !(
              s &&
              (l == "length" ||
                (i && (l == "offset" || l == "parent")) ||
                (r && (l == "buffer" || l == "byteLength" || l == "byteOffset")) ||
                Mo(l, c))
            )
          ) {
            a.push(l);
          }
        }
        return a;
      }
      const Si = Di;
      var Ti = Object.prototype;
      function Pi(t) {
        var e = t && t.constructor,
          n = (typeof e == "function" && e.prototype) || Ti;
        return t === n;
      }
      const Bi = Pi;
      var Oi = ee(Object.keys, Object);
      const Ri = Oi;
      var Ii = Object.prototype;
      var zi = Ii.hasOwnProperty;
      function Fi(t) {
        if (!Bi(t)) {
          return Ri(t);
        }
        var e = [];
        for (var n in Object(t)) {
          if (zi.call(t, n) && n != "constructor") {
            e.push(n);
          }
        }
        return e;
      }
      const Mi = Fi;
      function Ni(t) {
        return t != null && Lo(t.length) && !qe(t);
      }
      const Vi = Ni;
      function Li(t) {
        return Vi(t) ? Si(t) : Mi(t);
      }
      const Hi = Li;
      function ji(t, e) {
        return t && po(e, Hi(e), t);
      }
      const qi = ji;
      function $i(t) {
        var e = [];
        if (t != null) {
          for (var n in Object(t)) {
            e.push(n);
          }
        }
        return e;
      }
      const Wi = $i;
      var Gi = Object.prototype;
      var Ki = Gi.hasOwnProperty;
      function Ui(t) {
        if (!nt(t)) {
          return Wi(t);
        }
        var e = Bi(t),
          n = [];
        for (var o in t) {
          if (!(o == "constructor" && (e || !Ki.call(t, o)))) {
            n.push(o);
          }
        }
        return n;
      }
      const Zi = Ui;
      function Ji(t) {
        return Vi(t) ? Si(t, true) : Zi(t);
      }
      const Yi = Ji;
      function Qi(t, e) {
        return t && po(e, Yi(e), t);
      }
      const Xi = Qi;
      var tr = typeof exports == "object" && exports && !exports.nodeType && exports;
      var er = tr && typeof module == "object" && module && !module.nodeType && module;
      var nr = er && er.exports === tr;
      var or = nr ? St.Buffer : undefined,
        ir = or ? or.allocUnsafe : undefined;
      function rr(t, e) {
        if (e) {
          return t.slice();
        }
        var n = t.length,
          o = ir ? ir(n) : new t.constructor(n);
        t.copy(o);
        return o;
      }
      const sr = rr;
      function ar(t, e) {
        var n = -1,
          o = t.length;
        e || (e = Array(o));
        while (++n < o) {
          e[n] = t[n];
        }
        return e;
      }
      const cr = ar;
      function lr(t, e) {
        var n = -1,
          o = t == null ? 0 : t.length,
          i = 0,
          r = [];
        while (++n < o) {
          var s = t[n];
          if (e(s, n, t)) {
            r[i++] = s;
          }
        }
        return r;
      }
      const dr = lr;
      function hr() {
        return [];
      }
      const ur = hr;
      var fr = Object.prototype;
      var pr = fr.propertyIsEnumerable;
      var gr = Object.getOwnPropertySymbols;
      var mr = !gr
        ? ur
        : function (t) {
            if (t == null) {
              return [];
            }
            t = Object(t);
            return dr(gr(t), function (e) {
              return pr.call(t, e);
            });
          };
      const kr = mr;
      function br(t, e) {
        return po(t, kr(t), e);
      }
      const wr = br;
      function _r(t, e) {
        var n = -1,
          o = e.length,
          i = t.length;
        while (++n < o) {
          t[i + n] = e[n];
        }
        return t;
      }
      const vr = _r;
      var Ar = Object.getOwnPropertySymbols;
      var Cr = !Ar
        ? ur
        : function (t) {
            var e = [];
            while (t) {
              vr(e, kr(t));
              t = oe(t);
            }
            return e;
          };
      const yr = Cr;
      function xr(t, e) {
        return po(t, yr(t), e);
      }
      const Er = xr;
      function Dr(t, e, n) {
        var o = e(t);
        return Kt(t) ? o : vr(o, n(t));
      }
      const Sr = Dr;
      function Tr(t) {
        return Sr(t, Hi, kr);
      }
      const Pr = Tr;
      function Br(t) {
        return Sr(t, Yi, yr);
      }
      const Or = Br;
      var Rr = un(St, "DataView");
      const Ir = Rr;
      var zr = un(St, "Promise");
      const Fr = zr;
      var Mr = un(St, "Set");
      const Nr = Mr;
      var Vr = un(St, "WeakMap");
      const Lr = Vr;
      var Hr = "[object Map]",
        jr = "[object Object]",
        qr = "[object Promise]",
        $r = "[object Set]",
        Wr = "[object WeakMap]";
      var Gr = "[object DataView]";
      var Kr = Qe(Ir),
        Ur = Qe(pn),
        Zr = Qe(Fr),
        Jr = Qe(Nr),
        Yr = Qe(Lr);
      var Qr = Wt;
      if (
        (Ir && Qr(new Ir(new ArrayBuffer(1))) != Gr) ||
        (pn && Qr(new pn()) != Hr) ||
        (Fr && Qr(Fr.resolve()) != qr) ||
        (Nr && Qr(new Nr()) != $r) ||
        (Lr && Qr(new Lr()) != Wr)
      ) {
        Qr = function (t) {
          var e = Wt(t),
            n = e == jr ? t.constructor : undefined,
            o = n ? Qe(n) : "";
          if (o) {
            switch (o) {
              case Kr:
                return Gr;
              case Ur:
                return Hr;
              case Zr:
                return qr;
              case Jr:
                return $r;
              case Yr:
                return Wr;
            }
          }
          return e;
        };
      }
      const Xr = Qr;
      var ts = Object.prototype;
      var es = ts.hasOwnProperty;
      function ns(t) {
        var e = t.length,
          n = new t.constructor(e);
        if (e && typeof t[0] == "string" && es.call(t, "index")) {
          n.index = t.index;
          n.input = t.input;
        }
        return n;
      }
      const os = ns;
      var is = St.Uint8Array;
      const rs = is;
      function ss(t) {
        var e = new t.constructor(t.byteLength);
        new rs(e).set(new rs(t));
        return e;
      }
      const as = ss;
      function cs(t, e) {
        var n = e ? as(t.buffer) : t.buffer;
        return new t.constructor(n, t.byteOffset, t.byteLength);
      }
      const ls = cs;
      var ds = /\w*$/;
      function hs(t) {
        var e = new t.constructor(t.source, ds.exec(t));
        e.lastIndex = t.lastIndex;
        return e;
      }
      const us = hs;
      var fs = Pt ? Pt.prototype : undefined,
        ps = fs ? fs.valueOf : undefined;
      function gs(t) {
        return ps ? Object(ps.call(t)) : {};
      }
      const ms = gs;
      function ks(t, e) {
        var n = e ? as(t.buffer) : t.buffer;
        return new t.constructor(n, t.byteOffset, t.length);
      }
      const bs = ks;
      var ws = "[object Boolean]",
        _s = "[object Date]",
        vs = "[object Map]",
        As = "[object Number]",
        Cs = "[object RegExp]",
        ys = "[object Set]",
        xs = "[object String]",
        Es = "[object Symbol]";
      var Ds = "[object ArrayBuffer]",
        Ss = "[object DataView]",
        Ts = "[object Float32Array]",
        Ps = "[object Float64Array]",
        Bs = "[object Int8Array]",
        Os = "[object Int16Array]",
        Rs = "[object Int32Array]",
        Is = "[object Uint8Array]",
        zs = "[object Uint8ClampedArray]",
        Fs = "[object Uint16Array]",
        Ms = "[object Uint32Array]";
      function Ns(t, e, n) {
        var o = t.constructor;
        switch (e) {
          case Ds:
            return as(t);
          case ws:
          case _s:
            return new o(+t);
          case Ss:
            return ls(t, n);
          case Ts:
          case Ps:
          case Bs:
          case Os:
          case Rs:
          case Is:
          case zs:
          case Fs:
          case Ms:
            return bs(t, n);
          case vs:
            return new o();
          case As:
          case xs:
            return new o(t);
          case Cs:
            return us(t);
          case ys:
            return new o();
          case Es:
            return ms(t);
        }
      }
      const Vs = Ns;
      var Ls = Object.create;
      var Hs = (function () {
        function t() {}
        return function (e) {
          if (!nt(e)) {
            return {};
          }
          if (Ls) {
            return Ls(e);
          }
          t.prototype = e;
          var n = new t();
          t.prototype = undefined;
          return n;
        };
      })();
      const js = Hs;
      function qs(t) {
        return typeof t.constructor == "function" && !Bi(t) ? js(oe(t)) : {};
      }
      const $s = qs;
      var Ws = "[object Map]";
      function Gs(t) {
        return Zt(t) && Xr(t) == Ws;
      }
      const Ks = Gs;
      var Us = vi && vi.isMap;
      var Zs = Us ? gi(Us) : Ks;
      const Js = Zs;
      var Ys = "[object Set]";
      function Qs(t) {
        return Zt(t) && Xr(t) == Ys;
      }
      const Xs = Qs;
      var ta = vi && vi.isSet;
      var ea = ta ? gi(ta) : Xs;
      const na = ea;
      var oa = 1,
        ia = 2,
        ra = 4;
      var sa = "[object Arguments]",
        aa = "[object Array]",
        ca = "[object Boolean]",
        la = "[object Date]",
        da = "[object Error]",
        ha = "[object Function]",
        ua = "[object GeneratorFunction]",
        fa = "[object Map]",
        pa = "[object Number]",
        ga = "[object Object]",
        ma = "[object RegExp]",
        ka = "[object Set]",
        ba = "[object String]",
        wa = "[object Symbol]",
        _a = "[object WeakMap]";
      var va = "[object ArrayBuffer]",
        Aa = "[object DataView]",
        Ca = "[object Float32Array]",
        ya = "[object Float64Array]",
        xa = "[object Int8Array]",
        Ea = "[object Int16Array]",
        Da = "[object Int32Array]",
        Sa = "[object Uint8Array]",
        Ta = "[object Uint8ClampedArray]",
        Pa = "[object Uint16Array]",
        Ba = "[object Uint32Array]";
      var Oa = {};
      Oa[sa] =
        Oa[aa] =
        Oa[va] =
        Oa[Aa] =
        Oa[ca] =
        Oa[la] =
        Oa[Ca] =
        Oa[ya] =
        Oa[xa] =
        Oa[Ea] =
        Oa[Da] =
        Oa[fa] =
        Oa[pa] =
        Oa[ga] =
        Oa[ma] =
        Oa[ka] =
        Oa[ba] =
        Oa[wa] =
        Oa[Sa] =
        Oa[Ta] =
        Oa[Pa] =
        Oa[Ba] =
          true;
      Oa[da] = Oa[ha] = Oa[_a] = false;
      function Ra(t, e, n, o, i, r) {
        var s,
          a = e & oa,
          c = e & ia,
          l = e & ra;
        if (n) {
          s = i ? n(t, o, i, r) : n(t);
        }
        if (s !== undefined) {
          return s;
        }
        if (!nt(t)) {
          return t;
        }
        var d = Kt(t);
        if (d) {
          s = os(t);
          if (!a) {
            return cr(t, s);
          }
        } else {
          var h = Xr(t),
            u = h == ha || h == ua;
          if (Ro(t)) {
            return sr(t, a);
          }
          if (h == ga || h == sa || (u && !i)) {
            s = c || u ? {} : $s(t);
            if (!a) {
              return c ? Er(t, Xi(s, t)) : wr(t, qi(s, t));
            }
          } else {
            if (!Oa[h]) {
              return i ? t : {};
            }
            s = Vs(t, h, a);
          }
        }
        r || (r = new eo());
        var f = r.get(t);
        if (f) {
          return f;
        }
        r.set(t, s);
        if (na(t)) {
          t.forEach(function (o) {
            s.add(Ra(o, e, n, o, t, r));
          });
        } else if (Js(t)) {
          t.forEach(function (o, i) {
            s.set(i, Ra(o, e, n, i, t, r));
          });
        }
        var p = l ? (c ? Or : Pr) : c ? Yi : Hi;
        var g = d ? undefined : p(t);
        oo(g || t, function (o, i) {
          if (g) {
            i = o;
            o = t[i];
          }
          uo(s, i, Ra(o, e, n, i, t, r));
        });
        return s;
      }
      const Ia = Ra;
      var za = 1,
        Fa = 4;
      function Ma(t, e) {
        e = typeof e == "function" ? e : undefined;
        return Ia(t, za | Fa, e);
      }
      const Na = Ma;
      function Va(t) {
        return Zt(t) && t.nodeType === 1 && !he(t);
      }
      const La = Va;
      class Ha {
        constructor(t, e) {
          this._config = {};
          if (e) {
            this.define(ja(e));
          }
          if (t) {
            this._setObjectToTarget(this._config, t);
          }
        }
        set(t, e) {
          this._setToTarget(this._config, t, e);
        }
        define(t, e) {
          const n = true;
          this._setToTarget(this._config, t, e, n);
        }
        get(t) {
          return this._getFromSource(this._config, t);
        }
        *names() {
          for (const t of Object.keys(this._config)) {
            yield t;
          }
        }
        _setToTarget(t, e, n, o = false) {
          if (he(e)) {
            this._setObjectToTarget(t, e, o);
            return;
          }
          const i = e.split(".");
          e = i.pop();
          for (const e of i) {
            if (!he(t[e])) {
              t[e] = {};
            }
            t = t[e];
          }
          if (he(n)) {
            if (!he(t[e])) {
              t[e] = {};
            }
            t = t[e];
            this._setObjectToTarget(t, n, o);
            return;
          }
          if (o && typeof t[e] != "undefined") {
            return;
          }
          t[e] = n;
        }
        _getFromSource(t, e) {
          const n = e.split(".");
          e = n.pop();
          for (const e of n) {
            if (!he(t[e])) {
              t = null;
              break;
            }
            t = t[e];
          }
          return t ? ja(t[e]) : undefined;
        }
        _setObjectToTarget(t, e, n) {
          Object.keys(e).forEach((o) => {
            this._setToTarget(t, o, e[o], n);
          });
        }
      }
      function ja(t) {
        return Na(t, qa);
      }
      function qa(t) {
        return La(t) ? t : undefined;
      }
      function $a(t) {
        if (t) {
          if (t.defaultView) {
            return t instanceof t.defaultView.Document;
          } else if (t.ownerDocument && t.ownerDocument.defaultView) {
            return t instanceof t.ownerDocument.defaultView.Node;
          }
        }
        return false;
      }
      function Wa(t) {
        const e = Object.prototype.toString.apply(t);
        if (e == "[object Window]") {
          return true;
        }
        if (e == "[object global]") {
          return true;
        }
        return false;
      }
      const Ga = Ka(q());
      function Ka(t) {
        if (!t) {
          return Ga;
        }
        class e extends t {
          listenTo(t, e, n, o = {}) {
            if ($a(t) || Wa(t)) {
              const i = { capture: !!o.useCapture, passive: !!o.usePassive };
              const r = this._getProxyEmitter(t, i) || new Ua(t, i);
              this.listenTo(r, e, n, o);
            } else {
              super.listenTo(t, e, n, o);
            }
          }
          stopListening(t, e, n) {
            if ($a(t) || Wa(t)) {
              const o = this._getAllProxyEmitters(t);
              for (const t of o) {
                this.stopListening(t, e, n);
              }
            } else {
              super.stopListening(t, e, n);
            }
          }
          _getProxyEmitter(t, e) {
            return $(this, Ja(t, e));
          }
          _getAllProxyEmitters(t) {
            return [
              { capture: false, passive: false },
              { capture: false, passive: true },
              { capture: true, passive: false },
              { capture: true, passive: true },
            ]
              .map((e) => this._getProxyEmitter(t, e))
              .filter((t) => !!t);
          }
        }
        return e;
      }
      [
        "_getProxyEmitter",
        "_getAllProxyEmitters",
        "on",
        "once",
        "off",
        "listenTo",
        "stopListening",
        "fire",
        "delegate",
        "stopDelegating",
        "_addEventListener",
        "_removeEventListener",
      ].forEach((t) => {
        Ka[t] = Ga.prototype[t];
      });
      class Ua extends q() {
        constructor(t, e) {
          super();
          W(this, Ja(t, e));
          this._domNode = t;
          this._options = e;
        }
        attach(t) {
          if (this._domListeners && this._domListeners[t]) {
            return;
          }
          const e = this._createDomListener(t);
          this._domNode.addEventListener(t, e, this._options);
          if (!this._domListeners) {
            this._domListeners = {};
          }
          this._domListeners[t] = e;
        }
        detach(t) {
          let e;
          if (this._domListeners[t] && (!(e = this._events[t]) || !e.callbacks.length)) {
            this._domListeners[t].removeListener();
          }
        }
        _addEventListener(t, e, n) {
          this.attach(t);
          q().prototype._addEventListener.call(this, t, e, n);
        }
        _removeEventListener(t, e) {
          q().prototype._removeEventListener.call(this, t, e);
          this.detach(t);
        }
        _createDomListener(t) {
          const e = (e) => {
            this.fire(t, e);
          };
          e.removeListener = () => {
            this._domNode.removeEventListener(t, e, this._options);
            delete this._domListeners[t];
          };
          return e;
        }
      }
      function Za(t) {
        return t["data-ck-expando"] || (t["data-ck-expando"] = x());
      }
      function Ja(t, e) {
        let n = Za(t);
        for (const t of Object.keys(e).sort()) {
          if (e[t]) {
            n += "-" + t;
          }
        }
        return n;
      }
      let Ya;
      try {
        Ya = { window, document };
      } catch (t) {
        Ya = { window: {}, document: {} };
      }
      const Qa = Ya;
      function Xa(t) {
        let e = t.parentElement;
        if (!e) {
          return null;
        }
        while (e.tagName != "BODY") {
          const t = e.style.overflowY || global.window.getComputedStyle(e).overflowY;
          if (t === "auto" || t === "scroll") {
            break;
          }
          e = e.parentElement;
          if (!e) {
            return null;
          }
        }
        return e;
      }
      function tc(t) {
        const e = [];
        let n = t;
        while (n && n.nodeType != Node.DOCUMENT_NODE) {
          e.unshift(n);
          n = n.parentNode;
        }
        return e;
      }
      function ec(t) {
        if (t instanceof HTMLTextAreaElement) {
          return t.value;
        }
        return t.innerHTML;
      }
      function nc(t) {
        return Object.prototype.toString.call(t) == "[object Text]";
      }
      function oc(t) {
        return Object.prototype.toString.apply(t) == "[object Range]";
      }
      function ic(t) {
        const e = t.ownerDocument.defaultView.getComputedStyle(t);
        return {
          top: parseInt(e.borderTopWidth, 10),
          right: parseInt(e.borderRightWidth, 10),
          bottom: parseInt(e.borderBottomWidth, 10),
          left: parseInt(e.borderLeftWidth, 10),
        };
      }
      function rc(t) {
        if (!t || !t.parentNode) {
          return null;
        }
        if (t.offsetParent === Qa.document.body) {
          return null;
        }
        return t.offsetParent;
      }
      const sc = ["top", "right", "bottom", "left", "width", "height"];
      class ac {
        constructor(t) {
          const e = oc(t);
          Object.defineProperty(this, "_source", {
            value: t._source || t,
            writable: true,
            enumerable: false,
          });
          if (dc(t) || e) {
            if (e) {
              const e = ac.getDomRangeRects(t);
              cc(this, ac.getBoundingRect(e));
            } else {
              cc(this, t.getBoundingClientRect());
            }
          } else if (Wa(t)) {
            const { innerWidth: e, innerHeight: n } = t;
            cc(this, { top: 0, right: e, bottom: n, left: 0, width: e, height: n });
          } else {
            cc(this, t);
          }
        }
        clone() {
          return new ac(this);
        }
        moveTo(t, e) {
          this.top = e;
          this.right = t + this.width;
          this.bottom = e + this.height;
          this.left = t;
          return this;
        }
        moveBy(t, e) {
          this.top += e;
          this.right += t;
          this.left += t;
          this.bottom += e;
          return this;
        }
        getIntersection(t) {
          const e = {
            top: Math.max(this.top, t.top),
            right: Math.min(this.right, t.right),
            bottom: Math.min(this.bottom, t.bottom),
            left: Math.max(this.left, t.left),
            width: 0,
            height: 0,
          };
          e.width = e.right - e.left;
          e.height = e.bottom - e.top;
          if (e.width < 0 || e.height < 0) {
            return null;
          } else {
            const t = new ac(e);
            t._source = this._source;
            return t;
          }
        }
        getIntersectionArea(t) {
          const e = this.getIntersection(t);
          if (e) {
            return e.getArea();
          } else {
            return 0;
          }
        }
        getArea() {
          return this.width * this.height;
        }
        getVisible() {
          const t = this._source;
          let e = this.clone();
          if (lc(t)) {
            return e;
          }
          let n = t;
          let o = t.parentNode || t.commonAncestorContainer;
          let i;
          while (o && !lc(o)) {
            const t = uc(o) === "visible";
            if (n instanceof HTMLElement && hc(n) === "absolute") {
              i = n;
            }
            const r = hc(o);
            if (t || (i && ((r === "relative" && t) || r !== "relative"))) {
              n = o;
              o = o.parentNode;
              continue;
            }
            const s = new ac(o);
            const a = e.getIntersection(s);
            if (a) {
              if (a.getArea() < e.getArea()) {
                e = a;
              }
            } else {
              return null;
            }
            n = o;
            o = o.parentNode;
          }
          return e;
        }
        isEqual(t) {
          for (const e of sc) {
            if (this[e] !== t[e]) {
              return false;
            }
          }
          return true;
        }
        contains(t) {
          const e = this.getIntersection(t);
          return !!(e && e.isEqual(t));
        }
        toAbsoluteRect() {
          const { scrollX: t, scrollY: e } = Qa.window;
          const n = this.clone().moveBy(t, e);
          if (dc(n._source)) {
            const t = rc(n._source);
            if (t) {
              fc(n, t);
            }
          }
          return n;
        }
        excludeScrollbarsAndBorders() {
          const t = this._source;
          let e, n, o;
          if (Wa(t)) {
            e = t.innerWidth - t.document.documentElement.clientWidth;
            n = t.innerHeight - t.document.documentElement.clientHeight;
            o = t.getComputedStyle(t.document.documentElement).direction;
          } else {
            const i = ic(t);
            e = t.offsetWidth - t.clientWidth - i.left - i.right;
            n = t.offsetHeight - t.clientHeight - i.top - i.bottom;
            o = t.ownerDocument.defaultView.getComputedStyle(t).direction;
            this.left += i.left;
            this.top += i.top;
            this.right -= i.right;
            this.bottom -= i.bottom;
            this.width = this.right - this.left;
            this.height = this.bottom - this.top;
          }
          this.width -= e;
          if (o === "ltr") {
            this.right -= e;
          } else {
            this.left += e;
          }
          this.height -= n;
          this.bottom -= n;
          return this;
        }
        static getDomRangeRects(t) {
          const e = [];
          const n = Array.from(t.getClientRects());
          if (n.length) {
            for (const t of n) {
              e.push(new ac(t));
            }
          } else {
            let n = t.startContainer;
            if (nc(n)) {
              n = n.parentNode;
            }
            const o = new ac(n.getBoundingClientRect());
            o.right = o.left;
            o.width = 0;
            e.push(o);
          }
          return e;
        }
        static getBoundingRect(t) {
          const e = {
            left: Number.POSITIVE_INFINITY,
            top: Number.POSITIVE_INFINITY,
            right: Number.NEGATIVE_INFINITY,
            bottom: Number.NEGATIVE_INFINITY,
            width: 0,
            height: 0,
          };
          let n = 0;
          for (const o of t) {
            n++;
            e.left = Math.min(e.left, o.left);
            e.top = Math.min(e.top, o.top);
            e.right = Math.max(e.right, o.right);
            e.bottom = Math.max(e.bottom, o.bottom);
          }
          if (n == 0) {
            return null;
          }
          e.width = e.right - e.left;
          e.height = e.bottom - e.top;
          return new ac(e);
        }
      }
      function cc(t, e) {
        for (const n of sc) {
          t[n] = e[n];
        }
      }
      function lc(t) {
        if (!dc(t)) {
          return false;
        }
        return t === t.ownerDocument.body;
      }
      function dc(t) {
        return (
          t !== null &&
          typeof t === "object" &&
          t.nodeType === 1 &&
          typeof t.getBoundingClientRect === "function"
        );
      }
      function hc(t) {
        return t instanceof HTMLElement
          ? t.ownerDocument.defaultView.getComputedStyle(t).position
          : "static";
      }
      function uc(t) {
        return t instanceof HTMLElement
          ? t.ownerDocument.defaultView.getComputedStyle(t).overflow
          : "visible";
      }
      function fc(t, e) {
        const n = new ac(e);
        const o = ic(e);
        let i = 0;
        let r = 0;
        i -= n.left;
        r -= n.top;
        i += e.scrollLeft;
        r += e.scrollTop;
        i -= o.left;
        r -= o.top;
        t.moveBy(i, r);
      }
      class pc {
        constructor(t, e) {
          if (!pc._observerInstance) {
            pc._createObserver();
          }
          this._element = t;
          this._callback = e;
          pc._addElementCallback(t, e);
          pc._observerInstance.observe(t);
        }
        get element() {
          return this._element;
        }
        destroy() {
          pc._deleteElementCallback(this._element, this._callback);
        }
        static _addElementCallback(t, e) {
          if (!pc._elementCallbacks) {
            pc._elementCallbacks = new Map();
          }
          let n = pc._elementCallbacks.get(t);
          if (!n) {
            n = new Set();
            pc._elementCallbacks.set(t, n);
          }
          n.add(e);
        }
        static _deleteElementCallback(t, e) {
          const n = pc._getElementCallbacks(t);
          if (n) {
            n.delete(e);
            if (!n.size) {
              pc._elementCallbacks.delete(t);
              pc._observerInstance.unobserve(t);
            }
          }
          if (pc._elementCallbacks && !pc._elementCallbacks.size) {
            pc._observerInstance = null;
            pc._elementCallbacks = null;
          }
        }
        static _getElementCallbacks(t) {
          if (!pc._elementCallbacks) {
            return null;
          }
          return pc._elementCallbacks.get(t);
        }
        static _createObserver() {
          pc._observerInstance = new Qa.window.ResizeObserver((t) => {
            for (const e of t) {
              const t = pc._getElementCallbacks(e.target);
              if (t) {
                for (const n of t) {
                  n(e);
                }
              }
            }
          });
        }
      }
      pc._observerInstance = null;
      pc._elementCallbacks = null;
      function gc(t, e) {
        if (t instanceof HTMLTextAreaElement) {
          t.value = e;
        }
        t.innerHTML = e;
      }
      function mc(t) {
        return (e) => e + t;
      }
      function kc(t) {
        let e = 0;
        while (t.previousSibling) {
          t = t.previousSibling;
          e++;
        }
        return e;
      }
      function bc(t, e, n) {
        t.insertBefore(n, t.childNodes[e] || null);
      }
      function wc(t) {
        return t && t.nodeType === Node.COMMENT_NODE;
      }
      function _c(t) {
        try {
          Qa.document.createAttribute(t);
        } catch (t) {
          return false;
        }
        return true;
      }
      function vc(t) {
        return !!(t && t.getClientRects && t.getClientRects().length);
      }
      function Ac({
        element: t,
        target: e,
        positions: n,
        limiter: o,
        fitInViewport: i,
        viewportOffsetConfig: r,
      }) {
        if (qe(e)) {
          e = e();
        }
        if (qe(o)) {
          o = o();
        }
        const s = rc(t);
        const a = yc(r);
        const c = new ac(t);
        const l = Cc(e, a);
        let d;
        if (!l || !a.getIntersection(l)) {
          return null;
        }
        const h = { targetRect: l, elementRect: c, positionedElementAncestor: s, viewportRect: a };
        if (!o && !i) {
          d = new Ec(n[0], h);
        } else {
          if (o) {
            const t = Cc(o, a);
            if (t) {
              h.limiterRect = t;
            }
          }
          d = xc(n, h);
        }
        return d;
      }
      function Cc(t, e) {
        const n = new ac(t).getVisible();
        if (!n) {
          return null;
        }
        return n.getIntersection(e);
      }
      function yc(t) {
        t = Object.assign({ top: 0, bottom: 0, left: 0, right: 0 }, t);
        const e = new ac(Qa.window);
        e.top += t.top;
        e.height -= t.top;
        e.bottom -= t.bottom;
        e.height -= t.bottom;
        return e;
      }
      function xc(t, e) {
        const { elementRect: n } = e;
        const o = n.getArea();
        const i = t.map((t) => new Ec(t, e)).filter((t) => !!t.name);
        let r = 0;
        let s = null;
        for (const t of i) {
          const { limiterIntersectionArea: e, viewportIntersectionArea: n } = t;
          if (e === o) {
            return t;
          }
          const i = n ** 2 + e ** 2;
          if (i > r) {
            r = i;
            s = t;
          }
        }
        return s;
      }
      class Ec {
        constructor(t, e) {
          const n = t(e.targetRect, e.elementRect, e.viewportRect, e.limiterRect);
          if (!n) {
            return;
          }
          const { left: o, top: i, name: r, config: s } = n;
          this.name = r;
          this.config = s;
          this._positioningFunctionCoordinates = { left: o, top: i };
          this._options = e;
        }
        get left() {
          return this._absoluteRect.left;
        }
        get top() {
          return this._absoluteRect.top;
        }
        get limiterIntersectionArea() {
          const t = this._options.limiterRect;
          if (t) {
            return t.getIntersectionArea(this._rect);
          }
          return 0;
        }
        get viewportIntersectionArea() {
          const t = this._options.viewportRect;
          return t.getIntersectionArea(this._rect);
        }
        get _rect() {
          if (this._cachedRect) {
            return this._cachedRect;
          }
          this._cachedRect = this._options.elementRect
            .clone()
            .moveTo(
              this._positioningFunctionCoordinates.left,
              this._positioningFunctionCoordinates.top
            );
          return this._cachedRect;
        }
        get _absoluteRect() {
          if (this._cachedAbsoluteRect) {
            return this._cachedAbsoluteRect;
          }
          this._cachedAbsoluteRect = this._rect.toAbsoluteRect();
          return this._cachedAbsoluteRect;
        }
      }
      function Dc(t) {
        const e = t.parentNode;
        if (e) {
          e.removeChild(t);
        }
      }
      function Sc({
        target: t,
        viewportOffset: e = 0,
        ancestorOffset: n = 0,
        alignToTop: o,
        forceScroll: i,
      }) {
        const r = Fc(t);
        let s = r;
        let a = null;
        e = Vc(e);
        while (s) {
          let c;
          if (s == r) {
            c = Mc(t);
          } else {
            c = Mc(a);
          }
          Bc({
            parent: c,
            getRect: () => Nc(t, s),
            alignToTop: o,
            ancestorOffset: n,
            forceScroll: i,
          });
          const l = Nc(t, s);
          Pc({ window: s, rect: l, viewportOffset: e, alignToTop: o, forceScroll: i });
          if (s.parent != s) {
            a = s.frameElement;
            s = s.parent;
            if (!a) {
              return;
            }
          } else {
            s = null;
          }
        }
      }
      function Tc(t, e, n) {
        const o = Mc(t);
        Bc({ parent: o, getRect: () => new Rect(t), ancestorOffset: e, limiterElement: n });
      }
      function Pc({ window: t, rect: e, alignToTop: n, forceScroll: o, viewportOffset: i }) {
        const r = e.clone().moveBy(0, i.bottom);
        const s = e.clone().moveBy(0, -i.top);
        const a = new ac(t).excludeScrollbarsAndBorders();
        const c = [s, r];
        const l = n && o;
        const d = c.every((t) => a.contains(t));
        let { scrollX: h, scrollY: u } = t;
        const f = h;
        const p = u;
        if (l) {
          u -= a.top - e.top + i.top;
        } else if (!d) {
          if (Rc(s, a)) {
            u -= a.top - e.top + i.top;
          } else if (Oc(r, a)) {
            if (n) {
              u += e.top - a.top - i.top;
            } else {
              u += e.bottom - a.bottom + i.bottom;
            }
          }
        }
        if (!d) {
          if (Ic(e, a)) {
            h -= a.left - e.left + i.left;
          } else if (zc(e, a)) {
            h += e.right - a.right + i.right;
          }
        }
        if (h != f || u !== p) {
          t.scrollTo(h, u);
        }
      }
      function Bc({
        parent: t,
        getRect: e,
        alignToTop: n,
        forceScroll: o,
        ancestorOffset: i = 0,
        limiterElement: r,
      }) {
        const s = Fc(t);
        const a = n && o;
        let c, l, d;
        const h = r || s.document.body;
        while (t != h) {
          l = e();
          c = new ac(t).excludeScrollbarsAndBorders();
          d = c.contains(l);
          if (a) {
            t.scrollTop -= c.top - l.top + i;
          } else if (!d) {
            if (Rc(l, c)) {
              t.scrollTop -= c.top - l.top + i;
            } else if (Oc(l, c)) {
              if (n) {
                t.scrollTop += l.top - c.top - i;
              } else {
                t.scrollTop += l.bottom - c.bottom + i;
              }
            }
          }
          if (!d) {
            if (Ic(l, c)) {
              t.scrollLeft -= c.left - l.left + i;
            } else if (zc(l, c)) {
              t.scrollLeft += l.right - c.right + i;
            }
          }
          t = t.parentNode;
        }
      }
      function Oc(t, e) {
        return t.bottom > e.bottom;
      }
      function Rc(t, e) {
        return t.top < e.top;
      }
      function Ic(t, e) {
        return t.left < e.left;
      }
      function zc(t, e) {
        return t.right > e.right;
      }
      function Fc(t) {
        if (oc(t)) {
          return t.startContainer.ownerDocument.defaultView;
        } else {
          return t.ownerDocument.defaultView;
        }
      }
      function Mc(t) {
        if (oc(t)) {
          let e = t.commonAncestorContainer;
          if (nc(e)) {
            e = e.parentNode;
          }
          return e;
        } else {
          return t.parentNode;
        }
      }
      function Nc(t, e) {
        const n = Fc(t);
        const o = new ac(t);
        if (n === e) {
          return o;
        } else {
          let t = n;
          while (t != e) {
            const e = t.frameElement;
            const n = new ac(e).excludeScrollbarsAndBorders();
            o.moveBy(n.left, n.top);
            t = t.parent;
          }
        }
        return o;
      }
      function Vc(t) {
        if (typeof t === "number") {
          return { top: t, bottom: t, left: t, right: t };
        }
        return t;
      }
      const Lc = { ctrl: "⌃", cmd: "⌘", alt: "⌥", shift: "⇧" };
      const Hc = { ctrl: "Ctrl+", alt: "Alt+", shift: "Shift+" };
      const jc = Yc();
      const qc = Object.fromEntries(
        Object.entries(jc).map(([t, e]) => [e, t.charAt(0).toUpperCase() + t.slice(1)])
      );
      function $c(t) {
        let e;
        if (typeof t == "string") {
          e = jc[t.toLowerCase()];
          if (!e) {
            throw new P("keyboard-unknown-key", null, { key: t });
          }
        } else {
          e =
            t.keyCode +
            (t.altKey ? jc.alt : 0) +
            (t.ctrlKey ? jc.ctrl : 0) +
            (t.shiftKey ? jc.shift : 0) +
            (t.metaKey ? jc.cmd : 0);
        }
        return e;
      }
      function Wc(t) {
        if (typeof t == "string") {
          t = Qc(t);
        }
        return t.map((t) => (typeof t == "string" ? Zc(t) : t)).reduce((t, e) => e + t, 0);
      }
      function Gc(t) {
        let e = Wc(t);
        const n = Object.entries(r.isMac || r.isiOS ? Lc : Hc);
        const o = n.reduce((t, [n, o]) => {
          if ((e & jc[n]) != 0) {
            e &= ~jc[n];
            t += o;
          }
          return t;
        }, "");
        return o + (e ? qc[e] : "");
      }
      function Kc(t) {
        return t == jc.arrowright || t == jc.arrowleft || t == jc.arrowup || t == jc.arrowdown;
      }
      function Uc(t, e) {
        const n = e === "ltr";
        switch (t) {
          case jc.arrowleft:
            return n ? "left" : "right";
          case jc.arrowright:
            return n ? "right" : "left";
          case jc.arrowup:
            return "up";
          case jc.arrowdown:
            return "down";
        }
      }
      function Zc(t) {
        if (t.endsWith("!")) {
          return $c(t.slice(0, -1));
        }
        const e = $c(t);
        return (r.isMac || r.isiOS) && e == jc.ctrl ? jc.cmd : e;
      }
      function Jc(t, e) {
        const n = Uc(t, e);
        return n === "down" || n === "right";
      }
      function Yc() {
        const t = {
          arrowleft: 37,
          arrowup: 38,
          arrowright: 39,
          arrowdown: 40,
          backspace: 8,
          delete: 46,
          enter: 13,
          space: 32,
          esc: 27,
          tab: 9,
          ctrl: 1114112,
          shift: 2228224,
          alt: 4456448,
          cmd: 8912896,
        };
        for (let e = 65; e <= 90; e++) {
          const n = String.fromCharCode(e);
          t[n.toLowerCase()] = e;
        }
        for (let e = 48; e <= 57; e++) {
          t[e - 48] = e;
        }
        for (let e = 112; e <= 123; e++) {
          t["f" + (e - 111)] = e;
        }
        for (const e of "`-=[];',./\\") {
          t[e] = e.charCodeAt(0);
        }
        return t;
      }
      function Qc(t) {
        return t.split("+").map((t) => t.trim());
      }
      function Xc(t) {
        return Array.isArray(t) ? t : [t];
      }
      if (!Qa.window.CKEDITOR_TRANSLATIONS) {
        Qa.window.CKEDITOR_TRANSLATIONS = {};
      }
      function tl(t, e, n) {
        if (!global.window.CKEDITOR_TRANSLATIONS[t]) {
          global.window.CKEDITOR_TRANSLATIONS[t] = {};
        }
        const o = global.window.CKEDITOR_TRANSLATIONS[t];
        o.dictionary = o.dictionary || {};
        o.getPluralForm = n || o.getPluralForm;
        Object.assign(o.dictionary, e);
      }
      function el(t, e, n = 1) {
        if (typeof n !== "number") {
          throw new P("translation-service-quantity-not-a-number", null, { quantity: n });
        }
        const o = il();
        if (o === 1) {
          t = Object.keys(Qa.window.CKEDITOR_TRANSLATIONS)[0];
        }
        const i = e.id || e.string;
        if (o === 0 || !ol(t, i)) {
          if (n !== 1) {
            return e.plural;
          }
          return e.string;
        }
        const r = Qa.window.CKEDITOR_TRANSLATIONS[t].dictionary;
        const s = Qa.window.CKEDITOR_TRANSLATIONS[t].getPluralForm || ((t) => (t === 1 ? 0 : 1));
        const a = r[i];
        if (typeof a === "string") {
          return a;
        }
        const c = Number(s(n));
        return a[c];
      }
      function nl() {
        global.window.CKEDITOR_TRANSLATIONS = {};
      }
      function ol(t, e) {
        return (
          !!Qa.window.CKEDITOR_TRANSLATIONS[t] && !!Qa.window.CKEDITOR_TRANSLATIONS[t].dictionary[e]
        );
      }
      function il() {
        return Object.keys(Qa.window.CKEDITOR_TRANSLATIONS).length;
      }
      const rl = ["ar", "ara", "fa", "per", "fas", "he", "heb", "ku", "kur", "ug", "uig"];
      function sl(t) {
        return rl.includes(t) ? "rtl" : "ltr";
      }
      class al {
        constructor({ uiLanguage: t = "en", contentLanguage: e } = {}) {
          this.uiLanguage = t;
          this.contentLanguage = e || this.uiLanguage;
          this.uiLanguageDirection = sl(this.uiLanguage);
          this.contentLanguageDirection = sl(this.contentLanguage);
          this.t = (t, e) => this._t(t, e);
        }
        get language() {
          console.warn(
            "locale-deprecated-language-property: " +
              "The Locale#language property has been deprecated and will be removed in the near future. " +
              "Please use #uiLanguage and #contentLanguage properties instead."
          );
          return this.uiLanguage;
        }
        _t(t, e = []) {
          e = Xc(e);
          if (typeof t === "string") {
            t = { string: t };
          }
          const n = !!t.plural;
          const o = n ? e[0] : 1;
          const i = el(this.uiLanguage, t, o);
          return cl(i, e);
        }
      }
      function cl(t, e) {
        return t.replace(/%(\d+)/g, (t, n) => (n < e.length ? e[n] : t));
      }
      class ll extends q() {
        constructor(t = {}, e = {}) {
          super();
          const n = Ct(t);
          if (!n) {
            e = t;
          }
          this._items = [];
          this._itemMap = new Map();
          this._idProperty = e.idProperty || "id";
          this._bindToExternalToInternalMap = new WeakMap();
          this._bindToInternalToExternalMap = new WeakMap();
          this._skippedIndexesFromExternal = [];
          if (n) {
            for (const e of t) {
              this._items.push(e);
              this._itemMap.set(this._getItemIdBeforeAdding(e), e);
            }
          }
        }
        get length() {
          return this._items.length;
        }
        get first() {
          return this._items[0] || null;
        }
        get last() {
          return this._items[this.length - 1] || null;
        }
        add(t, e) {
          return this.addMany([t], e);
        }
        addMany(t, e) {
          if (e === undefined) {
            e = this._items.length;
          } else if (e > this._items.length || e < 0) {
            throw new P("collection-add-item-invalid-index", this);
          }
          let n = 0;
          for (const o of t) {
            const t = this._getItemIdBeforeAdding(o);
            const i = e + n;
            this._items.splice(i, 0, o);
            this._itemMap.set(t, o);
            this.fire("add", o, i);
            n++;
          }
          this.fire("change", { added: t, removed: [], index: e });
          return this;
        }
        get(t) {
          let e;
          if (typeof t == "string") {
            e = this._itemMap.get(t);
          } else if (typeof t == "number") {
            e = this._items[t];
          } else {
            throw new P("collection-get-invalid-arg", this);
          }
          return e || null;
        }
        has(t) {
          if (typeof t == "string") {
            return this._itemMap.has(t);
          } else {
            const e = this._idProperty;
            const n = t[e];
            return n && this._itemMap.has(n);
          }
        }
        getIndex(t) {
          let e;
          if (typeof t == "string") {
            e = this._itemMap.get(t);
          } else {
            e = t;
          }
          return e ? this._items.indexOf(e) : -1;
        }
        remove(t) {
          const [e, n] = this._remove(t);
          this.fire("change", { added: [], removed: [e], index: n });
          return e;
        }
        map(t, e) {
          return this._items.map(t, e);
        }
        find(t, e) {
          return this._items.find(t, e);
        }
        filter(t, e) {
          return this._items.filter(t, e);
        }
        clear() {
          if (this._bindToCollection) {
            this.stopListening(this._bindToCollection);
            this._bindToCollection = null;
          }
          const t = Array.from(this._items);
          while (this.length) {
            this._remove(0);
          }
          this.fire("change", { added: [], removed: t, index: 0 });
        }
        bindTo(t) {
          if (this._bindToCollection) {
            throw new P("collection-bind-to-rebind", this);
          }
          this._bindToCollection = t;
          return {
            as: (t) => {
              this._setUpBindToBinding((e) => new t(e));
            },
            using: (t) => {
              if (typeof t == "function") {
                this._setUpBindToBinding(t);
              } else {
                this._setUpBindToBinding((e) => e[t]);
              }
            },
          };
        }
        _setUpBindToBinding(t) {
          const e = this._bindToCollection;
          const n = (n, o, i) => {
            const r = e._bindToCollection == this;
            const s = e._bindToInternalToExternalMap.get(o);
            if (r && s) {
              this._bindToExternalToInternalMap.set(o, s);
              this._bindToInternalToExternalMap.set(s, o);
            } else {
              const n = t(o);
              if (!n) {
                this._skippedIndexesFromExternal.push(i);
                return;
              }
              let r = i;
              for (const t of this._skippedIndexesFromExternal) {
                if (i > t) {
                  r--;
                }
              }
              for (const t of e._skippedIndexesFromExternal) {
                if (r >= t) {
                  r++;
                }
              }
              this._bindToExternalToInternalMap.set(o, n);
              this._bindToInternalToExternalMap.set(n, o);
              this.add(n, r);
              for (let t = 0; t < e._skippedIndexesFromExternal.length; t++) {
                if (r <= e._skippedIndexesFromExternal[t]) {
                  e._skippedIndexesFromExternal[t]++;
                }
              }
            }
          };
          for (const t of e) {
            n(null, t, e.getIndex(t));
          }
          this.listenTo(e, "add", n);
          this.listenTo(e, "remove", (t, e, n) => {
            const o = this._bindToExternalToInternalMap.get(e);
            if (o) {
              this.remove(o);
            }
            this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce((t, e) => {
              if (n < e) {
                t.push(e - 1);
              }
              if (n > e) {
                t.push(e);
              }
              return t;
            }, []);
          });
        }
        _getItemIdBeforeAdding(t) {
          const e = this._idProperty;
          let n;
          if (e in t) {
            n = t[e];
            if (typeof n != "string") {
              throw new P("collection-add-invalid-id", this);
            }
            if (this.get(n)) {
              throw new P("collection-add-item-already-exists", this);
            }
          } else {
            t[e] = n = x();
          }
          return n;
        }
        _remove(t) {
          let e, n, o;
          let i = false;
          const r = this._idProperty;
          if (typeof t == "string") {
            n = t;
            o = this._itemMap.get(n);
            i = !o;
            if (o) {
              e = this._items.indexOf(o);
            }
          } else if (typeof t == "number") {
            e = t;
            o = this._items[e];
            i = !o;
            if (o) {
              n = o[r];
            }
          } else {
            o = t;
            n = o[r];
            e = this._items.indexOf(o);
            i = e == -1 || !this._itemMap.get(n);
          }
          if (i) {
            throw new P("collection-remove-404", this);
          }
          this._items.splice(e, 1);
          this._itemMap.delete(n);
          const s = this._bindToInternalToExternalMap.get(o);
          this._bindToInternalToExternalMap.delete(o);
          this._bindToExternalToInternalMap.delete(s);
          this.fire("remove", o, e);
          return [o, e];
        }
        [Symbol.iterator]() {
          return this._items[Symbol.iterator]();
        }
      }
      function dl(t) {
        const e = t.next();
        if (e.done) {
          return null;
        }
        return e.value;
      }
      class hl extends Ka(lt()) {
        constructor() {
          super();
          this._elements = new Set();
          this._nextEventLoopTimeout = null;
          this.set("isFocused", false);
          this.set("focusedElement", null);
        }
        add(t) {
          if (this._elements.has(t)) {
            throw new P("focustracker-add-element-already-exist", this);
          }
          this.listenTo(t, "focus", () => this._focus(t), { useCapture: true });
          this.listenTo(t, "blur", () => this._blur(), { useCapture: true });
          this._elements.add(t);
        }
        remove(t) {
          if (t === this.focusedElement) {
            this._blur();
          }
          if (this._elements.has(t)) {
            this.stopListening(t);
            this._elements.delete(t);
          }
        }
        destroy() {
          this.stopListening();
        }
        _focus(t) {
          clearTimeout(this._nextEventLoopTimeout);
          this.focusedElement = t;
          this.isFocused = true;
        }
        _blur() {
          clearTimeout(this._nextEventLoopTimeout);
          this._nextEventLoopTimeout = setTimeout(() => {
            this.focusedElement = null;
            this.isFocused = false;
          }, 0);
        }
      }
      class ul {
        constructor() {
          this._listener = new (Ka())();
        }
        listenTo(t) {
          this._listener.listenTo(t, "keydown", (t, e) => {
            this._listener.fire("_keydown:" + $c(e), e);
          });
        }
        set(t, e, n = {}) {
          const o = Wc(t);
          const i = n.priority;
          this._listener.listenTo(
            this._listener,
            "_keydown:" + o,
            (t, n) => {
              e(n, () => {
                n.preventDefault();
                n.stopPropagation();
                t.stop();
              });
              t.return = true;
            },
            { priority: i }
          );
        }
        press(t) {
          return !!this._listener.fire("_keydown:" + $c(t), t);
        }
        stopListening(t) {
          this._listener.stopListening(t);
        }
        destroy() {
          this.stopListening();
        }
      }
      function fl(t) {
        const e = new Map();
        for (const n in t) {
          e.set(n, t[n]);
        }
        return e;
      }
      function pl(t) {
        if (Ct(t)) {
          return new Map(t);
        } else {
          return fl(t);
        }
      }
      const gl = 1e4;
      function ml(t, e, n, o) {
        if (Math.max(e.length, t.length) > gl) {
          return t
            .slice(0, n)
            .concat(e)
            .concat(t.slice(n + o, t.length));
        } else {
          const i = Array.from(t);
          i.splice(n, o, ...e);
          return i;
        }
      }
      function kl(t, e) {
        let n;
        function o(...i) {
          o.cancel();
          n = setTimeout(() => t(...i), e);
        }
        o.cancel = () => {
          clearTimeout(n);
        };
        return o;
      }
      function bl(t) {
        function e(t) {
          if (t.length >= 40 && t.length <= 255) {
            return "VALID";
          } else {
            return "INVALID";
          }
        }
        if (!t) {
          return "INVALID";
        }
        let n = "";
        try {
          n = atob(t);
        } catch (t) {
          return "INVALID";
        }
        const o = n.split("-");
        const i = o[0];
        const r = o[1];
        if (!r) {
          return e(t);
        }
        try {
          atob(r);
        } catch (n) {
          try {
            atob(i);
            if (!atob(i).length) {
              return e(t);
            }
          } catch (n) {
            return e(t);
          }
        }
        if (i.length < 40 || i.length > 255) {
          return "INVALID";
        }
        let s = "";
        try {
          atob(i);
          s = atob(r);
        } catch (t) {
          return "INVALID";
        }
        if (s.length !== 8) {
          return "INVALID";
        }
        const a = Number(s.substring(0, 4));
        const c = Number(s.substring(4, 6)) - 1;
        const l = Number(s.substring(6, 8));
        const d = new Date(a, c, l);
        if (d < N || isNaN(Number(d))) {
          return "INVALID";
        }
        return "VALID";
      }
      function wl(t) {
        return (
          !!t &&
          t.length == 1 &&
          /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(t)
        );
      }
      function _l(t) {
        return !!t && t.length == 1 && /[\ud800-\udbff]/.test(t);
      }
      function vl(t) {
        return !!t && t.length == 1 && /[\udc00-\udfff]/.test(t);
      }
      function Al(t, e) {
        return _l(t.charAt(e - 1)) && vl(t.charAt(e));
      }
      function Cl(t, e) {
        return wl(t.charAt(e));
      }
      const yl = El();
      function xl(t, e) {
        const n = String(t).matchAll(yl);
        return Array.from(n).some((t) => t.index < e && e < t.index + t[0].length);
      }
      function El() {
        const t = [
          /\p{Emoji}[\u{E0020}-\u{E007E}]+\u{E007F}/u,
          /\p{Emoji}\u{FE0F}?\u{20E3}/u,
          /\p{Emoji}\u{FE0F}/u,
          /(?=\p{General_Category=Other_Symbol})\p{Emoji}\p{Emoji_Modifier}*/u,
        ];
        const e = /\p{Regional_Indicator}{2}/u.source;
        const n = "(?:" + t.map((t) => t.source).join("|") + ")";
        const o = `${e}|${n}(?:‍${n})*`;
        return new RegExp(o, "ug");
      }
      class Dl extends ll {
        constructor(t = []) {
          super(t, { idProperty: "viewUid" });
          this.on("add", (t, e, n) => {
            this._renderViewIntoCollectionParent(e, n);
          });
          this.on("remove", (t, e) => {
            if (e.element && this._parentElement) {
              e.element.remove();
            }
          });
          this._parentElement = null;
        }
        destroy() {
          this.map((t) => t.destroy());
        }
        setParent(t) {
          this._parentElement = t;
          for (const t of this) {
            this._renderViewIntoCollectionParent(t);
          }
        }
        delegate(...t) {
          if (!t.length || !Sl(t)) {
            throw new P("ui-viewcollection-delegate-wrong-events", this);
          }
          return {
            to: (e) => {
              for (const n of this) {
                for (const o of t) {
                  n.delegate(o).to(e);
                }
              }
              this.on("add", (n, o) => {
                for (const n of t) {
                  o.delegate(n).to(e);
                }
              });
              this.on("remove", (n, o) => {
                for (const n of t) {
                  o.stopDelegating(n, e);
                }
              });
            },
          };
        }
        _renderViewIntoCollectionParent(t, e) {
          if (!t.isRendered) {
            t.render();
          }
          if (t.element && this._parentElement) {
            this._parentElement.insertBefore(t.element, this._parentElement.children[e]);
          }
        }
        remove(t) {
          return super.remove(t);
        }
      }
      function Sl(t) {
        return t.every((t) => typeof t == "string");
      }
      var Tl = n(379);
      var Pl = n.n(Tl);
      var Bl = n(167);
      var Ol = { injectType: "singletonStyleTag", attributes: { "data-cke": true } };
      Ol.insert = "head";
      Ol.singleton = true;
      var Rl = Pl()(Bl.Z, Ol);
      const Il = Bl.Z.locals || {};
      class zl extends Ka(lt()) {
        constructor(t) {
          super();
          this.element = null;
          this.isRendered = false;
          this.locale = t;
          this.t = t && t.t;
          this._viewCollections = new ll();
          this._unboundChildren = this.createCollection();
          this._viewCollections.on("add", (e, n) => {
            n.locale = t;
            n.t = t && t.t;
          });
          this.decorate("render");
        }
        get bindTemplate() {
          if (this._bindTemplate) {
            return this._bindTemplate;
          }
          return (this._bindTemplate = Ml.bind(this, this));
        }
        createCollection(t) {
          const e = new Dl(t);
          this._viewCollections.add(e);
          return e;
        }
        registerChild(t) {
          if (!Ct(t)) {
            t = [t];
          }
          for (const e of t) {
            this._unboundChildren.add(e);
          }
        }
        deregisterChild(t) {
          if (!Ct(t)) {
            t = [t];
          }
          for (const e of t) {
            this._unboundChildren.remove(e);
          }
        }
        setTemplate(t) {
          this.template = new Ml(t);
        }
        extendTemplate(t) {
          Ml.extend(this.template, t);
        }
        render() {
          if (this.isRendered) {
            throw new P("ui-view-render-already-rendered", this);
          }
          if (this.template) {
            this.element = this.template.render();
            this.registerChild(this.template.getViews());
          }
          this.isRendered = true;
        }
        destroy() {
          this.stopListening();
          this._viewCollections.map((t) => t.destroy());
          if (this.template && this.template._revertData) {
            this.template.revert(this.element);
          }
        }
      }
      const Fl = "http://www.w3.org/1999/xhtml";
      class Ml extends q() {
        constructor(t) {
          super();
          Object.assign(this, Ul(Kl(t)));
          this._isRendered = false;
          this._revertData = null;
        }
        render() {
          const t = this._renderNode({ intoFragment: true });
          this._isRendered = true;
          return t;
        }
        apply(t) {
          this._revertData = cd();
          this._renderNode({
            node: t,
            intoFragment: false,
            isApplying: true,
            revertData: this._revertData,
          });
          return t;
        }
        revert(t) {
          if (!this._revertData) {
            throw new P("ui-template-revert-not-applied", [this, t]);
          }
          this._revertTemplateFromNode(t, this._revertData);
        }
        *getViews() {
          function* t(e) {
            if (e.children) {
              for (const n of e.children) {
                if (id(n)) {
                  yield n;
                } else if (rd(n)) {
                  yield* t(n);
                }
              }
            }
          }
          yield* t(this);
        }
        static bind(t, e) {
          return {
            to(n, o) {
              return new Vl({
                eventNameOrFunction: n,
                attribute: n,
                observable: t,
                emitter: e,
                callback: o,
              });
            },
            if(n, o, i) {
              return new Ll({
                observable: t,
                emitter: e,
                attribute: n,
                valueIfTrue: o,
                callback: i,
              });
            },
          };
        }
        static extend(t, e) {
          if (t._isRendered) {
            throw new P("template-extend-render", [this, t]);
          }
          nd(t, Ul(Kl(e)));
        }
        _renderNode(t) {
          let e;
          if (t.node) {
            e = this.tag && this.text;
          } else {
            e = this.tag ? this.text : !this.text;
          }
          if (e) {
            throw new P("ui-template-wrong-syntax", this);
          }
          if (this.text) {
            return this._renderText(t);
          } else {
            return this._renderElement(t);
          }
        }
        _renderElement(t) {
          let e = t.node;
          if (!e) {
            e = t.node = document.createElementNS(this.ns || Fl, this.tag);
          }
          this._renderAttributes(t);
          this._renderElementChildren(t);
          this._setUpListeners(t);
          return e;
        }
        _renderText(t) {
          let e = t.node;
          if (e) {
            t.revertData.text = e.textContent;
          } else {
            e = t.node = document.createTextNode("");
          }
          if (Hl(this.text)) {
            this._bindToObservable({ schema: this.text, updater: $l(e), data: t });
          } else {
            e.textContent = this.text.join("");
          }
          return e;
        }
        _renderAttributes(t) {
          if (!this.attributes) {
            return;
          }
          const e = t.node;
          const n = t.revertData;
          for (const o in this.attributes) {
            const i = e.getAttribute(o);
            const r = this.attributes[o];
            if (n) {
              n.attributes[o] = i;
            }
            const s = ad(r) ? r[0].ns : null;
            if (Hl(r)) {
              const a = ad(r) ? r[0].value : r;
              if (n && ld(o)) {
                a.unshift(i);
              }
              this._bindToObservable({ schema: a, updater: Wl(e, o, s), data: t });
            } else if (o == "style" && typeof r[0] !== "string") {
              this._renderStyleAttribute(r[0], t);
            } else {
              if (n && i && ld(o)) {
                r.unshift(i);
              }
              const t = r
                .map((t) => (t ? t.value || t : t))
                .reduce((t, e) => t.concat(e), [])
                .reduce(td, "");
              if (!od(t)) {
                e.setAttributeNS(s, o, t);
              }
            }
          }
        }
        _renderStyleAttribute(t, e) {
          const n = e.node;
          for (const o in t) {
            const i = t[o];
            if (Hl(i)) {
              this._bindToObservable({ schema: [i], updater: Gl(n, o), data: e });
            } else {
              n.style[o] = i;
            }
          }
        }
        _renderElementChildren(t) {
          const e = t.node;
          const n = t.intoFragment ? document.createDocumentFragment() : e;
          const o = t.isApplying;
          let i = 0;
          for (const r of this.children) {
            if (sd(r)) {
              if (!o) {
                r.setParent(e);
                for (const t of r) {
                  n.appendChild(t.element);
                }
              }
            } else if (id(r)) {
              if (!o) {
                if (!r.isRendered) {
                  r.render();
                }
                n.appendChild(r.element);
              }
            } else if ($a(r)) {
              n.appendChild(r);
            } else {
              if (o) {
                const e = t.revertData;
                const o = cd();
                e.children.push(o);
                r._renderNode({
                  intoFragment: false,
                  node: n.childNodes[i++],
                  isApplying: true,
                  revertData: o,
                });
              } else {
                n.appendChild(r.render());
              }
            }
          }
          if (t.intoFragment) {
            e.appendChild(n);
          }
        }
        _setUpListeners(t) {
          if (!this.eventListeners) {
            return;
          }
          for (const e in this.eventListeners) {
            const n = this.eventListeners[e].map((n) => {
              const [o, i] = e.split("@");
              return n.activateDomEventListener(o, i, t);
            });
            if (t.revertData) {
              t.revertData.bindings.push(n);
            }
          }
        }
        _bindToObservable({ schema: t, updater: e, data: n }) {
          const o = n.revertData;
          ql(t, e, n);
          const i = t
            .filter((t) => !od(t))
            .filter((t) => t.observable)
            .map((o) => o.activateAttributeListener(t, e, n));
          if (o) {
            o.bindings.push(i);
          }
        }
        _revertTemplateFromNode(t, e) {
          for (const t of e.bindings) {
            for (const e of t) {
              e();
            }
          }
          if (e.text) {
            t.textContent = e.text;
            return;
          }
          const n = t;
          for (const t in e.attributes) {
            const o = e.attributes[t];
            if (o === null) {
              n.removeAttribute(t);
            } else {
              n.setAttribute(t, o);
            }
          }
          for (let t = 0; t < e.children.length; ++t) {
            this._revertTemplateFromNode(n.childNodes[t], e.children[t]);
          }
        }
      }
      class Nl {
        constructor(t) {
          this.attribute = t.attribute;
          this.observable = t.observable;
          this.emitter = t.emitter;
          this.callback = t.callback;
        }
        getValue(t) {
          const e = this.observable[this.attribute];
          return this.callback ? this.callback(e, t) : e;
        }
        activateAttributeListener(t, e, n) {
          const o = () => ql(t, e, n);
          this.emitter.listenTo(this.observable, `change:${this.attribute}`, o);
          return () => {
            this.emitter.stopListening(this.observable, `change:${this.attribute}`, o);
          };
        }
      }
      class Vl extends Nl {
        constructor(t) {
          super(t);
          this.eventNameOrFunction = t.eventNameOrFunction;
        }
        activateDomEventListener(t, e, n) {
          const o = (t, n) => {
            if (!e || n.target.matches(e)) {
              if (typeof this.eventNameOrFunction == "function") {
                this.eventNameOrFunction(n);
              } else {
                this.observable.fire(this.eventNameOrFunction, n);
              }
            }
          };
          this.emitter.listenTo(n.node, t, o);
          return () => {
            this.emitter.stopListening(n.node, t, o);
          };
        }
      }
      class Ll extends Nl {
        constructor(t) {
          super(t);
          this.valueIfTrue = t.valueIfTrue;
        }
        getValue(t) {
          const e = super.getValue(t);
          return od(e) ? false : this.valueIfTrue || true;
        }
      }
      function Hl(t) {
        if (!t) {
          return false;
        }
        if (t.value) {
          t = t.value;
        }
        if (Array.isArray(t)) {
          return t.some(Hl);
        } else if (t instanceof Nl) {
          return true;
        }
        return false;
      }
      function jl(t, e) {
        return t.map((t) => {
          if (t instanceof Nl) {
            return t.getValue(e);
          }
          return t;
        });
      }
      function ql(t, e, { node: n }) {
        const o = jl(t, n);
        let i;
        if (t.length == 1 && t[0] instanceof Ll) {
          i = o[0];
        } else {
          i = o.reduce(td, "");
        }
        if (od(i)) {
          e.remove();
        } else {
          e.set(i);
        }
      }
      function $l(t) {
        return {
          set(e) {
            t.textContent = e;
          },
          remove() {
            t.textContent = "";
          },
        };
      }
      function Wl(t, e, n) {
        return {
          set(o) {
            t.setAttributeNS(n, e, o);
          },
          remove() {
            t.removeAttributeNS(n, e);
          },
        };
      }
      function Gl(t, e) {
        return {
          set(n) {
            t.style[e] = n;
          },
          remove() {
            t.style[e] = null;
          },
        };
      }
      function Kl(t) {
        const e = Na(t, (t) => {
          if (t && (t instanceof Nl || rd(t) || id(t) || sd(t))) {
            return t;
          }
        });
        return e;
      }
      function Ul(t) {
        if (typeof t == "string") {
          t = Yl(t);
        } else if (t.text) {
          Ql(t);
        }
        if (t.on) {
          t.eventListeners = Jl(t.on);
          delete t.on;
        }
        if (!t.text) {
          if (t.attributes) {
            Zl(t.attributes);
          }
          const e = [];
          if (t.children) {
            if (sd(t.children)) {
              e.push(t.children);
            } else {
              for (const n of t.children) {
                if (rd(n) || id(n) || $a(n)) {
                  e.push(n);
                } else {
                  e.push(new Ml(n));
                }
              }
            }
          }
          t.children = e;
        }
        return t;
      }
      function Zl(t) {
        for (const e in t) {
          if (t[e].value) {
            t[e].value = Xc(t[e].value);
          }
          Xl(t, e);
        }
      }
      function Jl(t) {
        for (const e in t) {
          Xl(t, e);
        }
        return t;
      }
      function Yl(t) {
        return { text: [t] };
      }
      function Ql(t) {
        t.text = Xc(t.text);
      }
      function Xl(t, e) {
        t[e] = Xc(t[e]);
      }
      function td(t, e) {
        if (od(e)) {
          return t;
        } else if (od(t)) {
          return e;
        } else {
          return `${t} ${e}`;
        }
      }
      function ed(t, e) {
        for (const n in e) {
          if (t[n]) {
            t[n].push(...e[n]);
          } else {
            t[n] = e[n];
          }
        }
      }
      function nd(t, e) {
        if (e.attributes) {
          if (!t.attributes) {
            t.attributes = {};
          }
          ed(t.attributes, e.attributes);
        }
        if (e.eventListeners) {
          if (!t.eventListeners) {
            t.eventListeners = {};
          }
          ed(t.eventListeners, e.eventListeners);
        }
        if (e.text) {
          t.text.push(...e.text);
        }
        if (e.children && e.children.length) {
          if (t.children.length != e.children.length) {
            throw new P("ui-template-extend-children-mismatch", t);
          }
          let n = 0;
          for (const o of e.children) {
            nd(t.children[n++], o);
          }
        }
      }
      function od(t) {
        return !t && t !== 0;
      }
      function id(t) {
        return t instanceof zl;
      }
      function rd(t) {
        return t instanceof Ml;
      }
      function sd(t) {
        return t instanceof Dl;
      }
      function ad(t) {
        return nt(t[0]) && t[0].ns;
      }
      function cd() {
        return { children: [], bindings: [], attributes: {} };
      }
      function ld(t) {
        return t == "class" || t == "style";
      }
      class dd extends Dl {
        constructor(t, e = []) {
          super(e);
          this.locale = t;
        }
        get bodyCollectionContainer() {
          return this._bodyCollectionContainer;
        }
        attachToDom() {
          this._bodyCollectionContainer = new Ml({
            tag: "div",
            attributes: {
              class: ["ck", "ck-reset_all", "ck-body", "ck-rounded-corners"],
              dir: this.locale.uiLanguageDirection,
            },
            children: this,
          }).render();
          let t = document.querySelector(".ck-body-wrapper");
          if (!t) {
            t = Xt(document, "div", { class: "ck-body-wrapper" });
            document.body.appendChild(t);
          }
          t.appendChild(this._bodyCollectionContainer);
        }
        detachFromDom() {
          super.destroy();
          if (this._bodyCollectionContainer) {
            this._bodyCollectionContainer.remove();
          }
          const t = document.querySelector(".ck-body-wrapper");
          if (t && t.childElementCount == 0) {
            t.remove();
          }
        }
      }
      var hd = n(977);
      var ud = { injectType: "singletonStyleTag", attributes: { "data-cke": true } };
      ud.insert = "head";
      ud.singleton = true;
      var fd = Pl()(hd.Z, ud);
      const pd = hd.Z.locals || {};
      class gd extends zl {
        constructor() {
          super();
          const t = this.bindTemplate;
          this.set("content", "");
          this.set("viewBox", "0 0 20 20");
          this.set("fillColor", "");
          this.set("isColorInherited", true);
          this.set("isVisible", true);
          this.setTemplate({
            tag: "svg",
            ns: "http://www.w3.org/2000/svg",
            attributes: {
              class: [
                "ck",
                "ck-icon",
                t.if("isVisible", "ck-hidden", (t) => !t),
                "ck-reset_all-excluded",
                t.if("isColorInherited", "ck-icon_inherit-color"),
              ],
              viewBox: t.to("viewBox"),
            },
          });
        }
        render() {
          super.render();
          this._updateXMLContent();
          this._colorFillPaths();
          this.on("change:content", () => {
            this._updateXMLContent();
            this._colorFillPaths();
          });
          this.on("change:fillColor", () => {
            this._colorFillPaths();
          });
        }
        _updateXMLContent() {
          if (this.content) {
            const t = new DOMParser().parseFromString(this.content.trim(), "image/svg+xml");
            const e = t.querySelector("svg");
            const n = e.getAttribute("viewBox");
            if (n) {
              this.viewBox = n;
            }
            for (const { name: t, value: n } of Array.from(e.attributes)) {
              if (gd.presentationalAttributeNames.includes(t)) {
                this.element.setAttribute(t, n);
              }
            }
            while (this.element.firstChild) {
              this.element.removeChild(this.element.firstChild);
            }
            while (e.childNodes.length > 0) {
              this.element.appendChild(e.childNodes[0]);
            }
          }
        }
        _colorFillPaths() {
          if (this.fillColor) {
            this.element.querySelectorAll(".ck-icon__fill").forEach((t) => {
              t.style.fill = this.fillColor;
            });
          }
        }
      }
      gd.presentationalAttributeNames = [
        "alignment-baseline",
        "baseline-shift",
        "clip-path",
        "clip-rule",
        "color",
        "color-interpolation",
        "color-interpolation-filters",
        "color-rendering",
        "cursor",
        "direction",
        "display",
        "dominant-baseline",
        "fill",
        "fill-opacity",
        "fill-rule",
        "filter",
        "flood-color",
        "flood-opacity",
        "font-family",
        "font-size",
        "font-size-adjust",
        "font-stretch",
        "font-style",
        "font-variant",
        "font-weight",
        "image-rendering",
        "letter-spacing",
        "lighting-color",
        "marker-end",
        "marker-mid",
        "marker-start",
        "mask",
        "opacity",
        "overflow",
        "paint-order",
        "pointer-events",
        "shape-rendering",
        "stop-color",
        "stop-opacity",
        "stroke",
        "stroke-dasharray",
        "stroke-dashoffset",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke-width",
        "text-anchor",
        "text-decoration",
        "text-overflow",
        "text-rendering",
        "transform",
        "unicode-bidi",
        "vector-effect",
        "visibility",
        "white-space",
        "word-spacing",
        "writing-mode",
      ];
      class md extends zl {
        constructor() {
          super();
          this.set({ style: undefined, text: undefined, id: undefined });
          const t = this.bindTemplate;
          this.setTemplate({
            tag: "span",
            attributes: { class: ["ck", "ck-button__label"], style: t.to("style"), id: t.to("id") },
            children: [{ text: t.to("text") }],
          });
        }
      }
      var kd = n(971);
      var bd = { injectType: "singletonStyleTag", attributes: { "data-cke": true } };
      bd.insert = "head";
      bd.singleton = true;
      var wd = Pl()(kd.Z, bd);
      const _d = kd.Z.locals || {};
      class vd extends zl {
        constructor(t, e = new md()) {
          super(t);
          this._focusDelayed = null;
          const n = this.bindTemplate;
          const o = x();
          this.set("ariaChecked", undefined);
          this.set("ariaLabel", undefined);
          this.set("ariaLabelledBy", `ck-editor__aria-label_${o}`);
          this.set("class", undefined);
          this.set("labelStyle", undefined);
          this.set("icon", undefined);
          this.set("isEnabled", true);
          this.set("isOn", false);
          this.set("isVisible", true);
          this.set("isToggleable", false);
          this.set("keystroke", undefined);
          this.set("label", undefined);
          this.set("role", undefined);
          this.set("tabindex", -1);
          this.set("tooltip", false);
          this.set("tooltipPosition", "s");
          this.set("type", "button");
          this.set("withText", false);
          this.set("withKeystroke", false);
          this.children = this.createCollection();
          this.labelView = this._setupLabelView(e);
          this.iconView = new gd();
          this.iconView.extendTemplate({ attributes: { class: "ck-button__icon" } });
          this.keystrokeView = this._createKeystrokeView();
          this.bind("_tooltipString").to(
            this,
            "tooltip",
            this,
            "label",
            this,
            "keystroke",
            this._getTooltipString.bind(this)
          );
          const i = {
            tag: "button",
            attributes: {
              class: [
                "ck",
                "ck-button",
                n.to("class"),
                n.if("isEnabled", "ck-disabled", (t) => !t),
                n.if("isVisible", "ck-hidden", (t) => !t),
                n.to("isOn", (t) => (t ? "ck-on" : "ck-off")),
                n.if("withText", "ck-button_with-text"),
                n.if("withKeystroke", "ck-button_with-keystroke"),
              ],
              role: n.to("role"),
              type: n.to("type", (t) => (t ? t : "button")),
              tabindex: n.to("tabindex"),
              "aria-label": n.to("ariaLabel"),
              "aria-labelledby": n.to("ariaLabelledBy"),
              "aria-disabled": n.if("isEnabled", true, (t) => !t),
              "aria-checked": n.to("isOn"),
              "aria-pressed": n.to("isOn", (t) => (this.isToggleable ? String(!!t) : false)),
              "data-cke-tooltip-text": n.to("_tooltipString"),
              "data-cke-tooltip-position": n.to("tooltipPosition"),
            },
            children: this.children,
            on: {
              click: n.to((t) => {
                if (this.isEnabled) {
                  this.fire("execute");
                } else {
                  t.preventDefault();
                }
              }),
            },
          };
          if (r.isSafari) {
            if (!this._focusDelayed) {
              this._focusDelayed = kl(() => this.focus(), 0);
            }
            i.on.mousedown = n.to(() => {
              this._focusDelayed();
            });
            i.on.mouseup = n.to(() => {
              this._focusDelayed.cancel();
            });
          }
          this.setTemplate(i);
        }
        render() {
          super.render();
          if (this.icon) {
            this.iconView.bind("content").to(this, "icon");
            this.children.add(this.iconView);
          }
          this.children.add(this.labelView);
          if (this.withKeystroke && this.keystroke) {
            this.children.add(this.keystrokeView);
          }
        }
        focus() {
          this.element.focus();
        }
        destroy() {
          if (this._focusDelayed) {
            this._focusDelayed.cancel();
          }
          super.destroy();
        }
        _setupLabelView(t) {
          t.bind("text", "style", "id").to(this, "label", "labelStyle", "ariaLabelledBy");
          return t;
        }
        _createKeystrokeView() {
          const t = new zl();
          t.setTemplate({
            tag: "span",
            attributes: { class: ["ck", "ck-button__keystroke"] },
            children: [{ text: this.bindTemplate.to("keystroke", (t) => Gc(t)) }],
          });
          return t;
        }
        _getTooltipString(t, e, n) {
          if (t) {
            if (typeof t == "string") {
              return t;
            } else {
              if (n) {
                n = Gc(n);
              }
              if (t instanceof Function) {
                return t(e, n);
              } else {
                return `${e}${n ? ` (${n})` : ""}`;
              }
            }
          }
          return "";
        }
      }
      var Ad = n(258);
      var Cd = { injectType: "singletonStyleTag", attributes: { "data-cke": true } };
      Cd.insert = "head";
      Cd.singleton = true;
      var yd = Pl()(Ad.Z, Cd);
      const xd = Ad.Z.locals || {};
      class Ed extends vd {
        constructor(t) {
          super(t);
          this.isToggleable = true;
          this.toggleSwitchView = this._createToggleView();
          this.extendTemplate({ attributes: { class: "ck-switchbutton" } });
        }
        render() {
          super.render();
          this.children.add(this.toggleSwitchView);
        }
        _createToggleView() {
          const t = new zl();
          t.setTemplate({
            tag: "span",
            attributes: { class: ["ck", "ck-button__toggle"] },
            children: [{ tag: "span", attributes: { class: ["ck", "ck-button__toggle__inner"] } }],
          });
          return t;
        }
      }
      function Dd(t, e) {
        const n = t.t;
        const o = {
          Black: n("Black"),
          "Dim grey": n("Dim grey"),
          Grey: n("Grey"),
          "Light grey": n("Light grey"),
          White: n("White"),
          Red: n("Red"),
          Orange: n("Orange"),
          Yellow: n("Yellow"),
          "Light green": n("Light green"),
          Green: n("Green"),
          Aquamarine: n("Aquamarine"),
          Turquoise: n("Turquoise"),
          "Light blue": n("Light blue"),
          Blue: n("Blue"),
          Purple: n("Purple"),
        };
        return e.map((t) => {
          const e = o[t.label];
          if (e && e != t.label) {
            t.label = e;
          }
          return t;
        });
      }
      function Sd(t) {
        return t.map(Td).filter((t) => !!t);
      }
      function Td(t) {
        if (typeof t === "string") {
          return {
            model: t,
            label: t,
            hasBorder: false,
            view: { name: "span", styles: { color: t } },
          };
        } else {
          return {
            model: t.color,
            label: t.label || t.color,
            hasBorder: t.hasBorder === undefined ? false : t.hasBorder,
            view: { name: "span", styles: { color: `${t.color}` } },
          };
        }
      }
      const Pd =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M16.935 5.328a2 2 0 0 1 0 2.829l-7.778 7.778a2 2 0 0 1-2.829 0L3.5 13.107a1.999 1.999 0 1 1 2.828-2.829l.707.707a1 1 0 0 0 1.414 0l5.658-5.657a2 2 0 0 1 2.828 0z"/><path d="M14.814 6.035 8.448 12.4a1 1 0 0 1-1.414 0l-1.413-1.415A1 1 0 1 0 4.207 12.4l2.829 2.829a1 1 0 0 0 1.414 0l7.778-7.778a1 1 0 1 0-1.414-1.415z"/></svg>';
      class Bd extends vd {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          this.set("color", undefined);
          this.set("hasBorder", false);
          this.icon = Pd;
          this.extendTemplate({
            attributes: {
              style: { backgroundColor: e.to("color") },
              class: [
                "ck",
                "ck-color-grid__tile",
                e.if("hasBorder", "ck-color-selector__color-tile_bordered"),
              ],
            },
          });
        }
        render() {
          super.render();
          this.iconView.fillColor = "hsl(0, 0%, 100%)";
        }
      }
      function Od({
        keystrokeHandler: t,
        focusTracker: e,
        gridItems: n,
        numberOfColumns: o,
        uiLanguageDirection: i,
      }) {
        const r = typeof o === "number" ? () => o : o;
        t.set(
          "arrowright",
          s((t, e) => (i === "rtl" ? c(t, e.length) : a(t, e.length)))
        );
        t.set(
          "arrowleft",
          s((t, e) => (i === "rtl" ? a(t, e.length) : c(t, e.length)))
        );
        t.set(
          "arrowup",
          s((t, e) => {
            let n = t - r();
            if (n < 0) {
              n = t + r() * Math.floor(e.length / r());
              if (n > e.length - 1) {
                n -= r();
              }
            }
            return n;
          })
        );
        t.set(
          "arrowdown",
          s((t, e) => {
            let n = t + r();
            if (n > e.length - 1) {
              n = t % r();
            }
            return n;
          })
        );
        function s(t) {
          return (o) => {
            const i = n.find((t) => t.element === e.focusedElement);
            const r = n.getIndex(i);
            const s = t(r, n);
            n.get(s).focus();
            o.stopPropagation();
            o.preventDefault();
          };
        }
        function a(t, e) {
          if (t === e - 1) {
            return 0;
          } else {
            return t + 1;
          }
        }
        function c(t, e) {
          if (t === 0) {
            return e - 1;
          } else {
            return t - 1;
          }
        }
      }
      var Rd = n(923);
      var Id = { injectType: "singletonStyleTag", attributes: { "data-cke": true } };
      Id.insert = "head";
      Id.singleton = true;
      var zd = Pl()(Rd.Z, Id);
      const Fd = Rd.Z.locals || {};
      class Md extends zl {
        constructor(t, e) {
          super(t);
          const n = e && e.colorDefinitions ? e.colorDefinitions : [];
          this.columns = e && e.columns ? e.columns : 5;
          const o = { gridTemplateColumns: `repeat( ${this.columns}, 1fr)` };
          this.set("selectedColor", undefined);
          this.items = this.createCollection();
          this.focusTracker = new hl();
          this.keystrokes = new ul();
          this.items.on("add", (t, e) => {
            e.isOn = e.color === this.selectedColor;
          });
          n.forEach((t) => {
            const e = new Bd();
            e.set({
              color: t.color,
              label: t.label,
              tooltip: true,
              hasBorder: t.options.hasBorder,
            });
            e.on("execute", () => {
              this.fire("execute", {
                value: t.color,
                hasBorder: t.options.hasBorder,
                label: t.label,
              });
            });
            this.items.add(e);
          });
          this.setTemplate({
            tag: "div",
            children: this.items,
            attributes: { class: ["ck", "ck-color-grid"], style: o },
          });
          this.on("change:selectedColor", (t, e, n) => {
            for (const t of this.items) {
              t.isOn = t.color === n;
            }
          });
        }
        focus() {
          if (this.items.length) {
            this.items.first.focus();
          }
        }
        focusLast() {
          if (this.items.length) {
            this.items.last.focus();
          }
        }
        render() {
          super.render();
          for (const t of this.items) {
            this.focusTracker.add(t.element);
          }
          this.items.on("add", (t, e) => {
            this.focusTracker.add(e.element);
          });
          this.items.on("remove", (t, e) => {
            this.focusTracker.remove(e.element);
          });
          this.keystrokes.listenTo(this.element);
          Od({
            keystrokeHandler: this.keystrokes,
            focusTracker: this.focusTracker,
            gridItems: this.items,
            numberOfColumns: this.columns,
            uiLanguageDirection: this.locale && this.locale.uiLanguageDirection,
          });
        }
        destroy() {
          super.destroy();
          this.focusTracker.destroy();
          this.keystrokes.destroy();
        }
      }
      var Nd = n(874);
      const Vd = Hd;
      var Ld = { red: 0, orange: 60, yellow: 120, green: 180, blue: 240, purple: 300 };
      function Hd(t) {
        var e,
          n = [],
          o = 1,
          i;
        if (typeof t === "string") {
          if (Nd[t]) {
            n = Nd[t].slice();
            i = "rgb";
          } else if (t === "transparent") {
            o = 0;
            i = "rgb";
            n = [0, 0, 0];
          } else if (/^#[A-Fa-f0-9]+$/.test(t)) {
            var r = t.slice(1);
            var s = r.length;
            var a = s <= 4;
            o = 1;
            if (a) {
              n = [parseInt(r[0] + r[0], 16), parseInt(r[1] + r[1], 16), parseInt(r[2] + r[2], 16)];
              if (s === 4) {
                o = parseInt(r[3] + r[3], 16) / 255;
              }
            } else {
              n = [parseInt(r[0] + r[1], 16), parseInt(r[2] + r[3], 16), parseInt(r[4] + r[5], 16)];
              if (s === 8) {
                o = parseInt(r[6] + r[7], 16) / 255;
              }
            }
            if (!n[0]) n[0] = 0;
            if (!n[1]) n[1] = 0;
            if (!n[2]) n[2] = 0;
            i = "rgb";
          } else if (
            (e =
              /^((?:rgb|hs[lvb]|hwb|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms)a?)\s*\(([^\)]*)\)/.exec(
                t
              ))
          ) {
            var c = e[1];
            var l = c === "rgb";
            var r = c.replace(/a$/, "");
            i = r;
            var s = r === "cmyk" ? 4 : r === "gray" ? 1 : 3;
            n = e[2]
              .trim()
              .split(/\s*[,\/]\s*|\s+/)
              .map(function (t, e) {
                if (/%$/.test(t)) {
                  if (e === s) return parseFloat(t) / 100;
                  if (r === "rgb") return (parseFloat(t) * 255) / 100;
                  return parseFloat(t);
                } else if (r[e] === "h") {
                  if (/deg$/.test(t)) {
                    return parseFloat(t);
                  } else if (Ld[t] !== undefined) {
                    return Ld[t];
                  }
                }
                return parseFloat(t);
              });
            if (c === r) n.push(1);
            o = l ? 1 : n[s] === undefined ? 1 : n[s];
            n = n.slice(0, s);
          } else if (t.length > 10 && /[0-9](?:\s|\/)/.test(t)) {
            n = t.match(/([0-9]+)/g).map(function (t) {
              return parseFloat(t);
            });
            i = t
              .match(/([a-z])/gi)
              .join("")
              .toLowerCase();
          }
        } else if (!isNaN(t)) {
          i = "rgb";
          n = [t >>> 16, (t & 65280) >>> 8, t & 255];
        } else if (Array.isArray(t) || t.length) {
          n = [t[0], t[1], t[2]];
          i = "rgb";
          o = t.length === 4 ? t[3] : 1;
        } else if (t instanceof Object) {
          if (t.r != null || t.red != null || t.R != null) {
            i = "rgb";
            n = [t.r || t.red || t.R || 0, t.g || t.green || t.G || 0, t.b || t.blue || t.B || 0];
          } else {
            i = "hsl";
            n = [
              t.h || t.hue || t.H || 0,
              t.s || t.saturation || t.S || 0,
              t.l || t.lightness || t.L || t.b || t.brightness,
            ];
          }
          o = t.a || t.alpha || t.opacity || 1;
          if (t.opacity != null) o /= 100;
        }
        return { space: i, values: n, alpha: o };
      }
      var jd = n(85);
      function qd(t, e) {
        if (!t) {
          return "";
        }
        const n = Gd(t);
        if (!n) {
          return "";
        }
        if (n.space === e) {
          return t;
        }
        if (!Kd(n)) {
          return "";
        }
        const o = jd[n.space];
        const i = o[e];
        if (!i) {
          return "";
        }
        const r = i(n.space === "hex" ? n.hexValue : n.values);
        return Wd(r, e);
      }
      function $d(t) {
        if (!t) {
          return "";
        }
        const e = Gd(t);
        if (!e) {
          return "#000";
        }
        if (e.space === "hex") {
          return e.hexValue;
        }
        return qd(t, "hex");
      }
      function Wd(t, e) {
        switch (e) {
          case "hex":
            return `#${t}`;
          case "rgb":
            return `rgb( ${t[0]}, ${t[1]}, ${t[2]} )`;
          case "hsl":
            return `hsl( ${t[0]}, ${t[1]}%, ${t[2]}% )`;
          case "hwb":
            return `hwb( ${t[0]}, ${t[1]}, ${t[2]} )`;
          case "lab":
            return `lab( ${t[0]}% ${t[1]} ${t[2]} )`;
          case "lch":
            return `lch( ${t[0]}% ${t[1]} ${t[2]} )`;
          default:
            return "";
        }
      }
      function Gd(t) {
        if (t.startsWith("#")) {
          const e = Vd(t);
          return { space: "hex", values: e.values, hexValue: t, alpha: e.alpha };
        }
        const e = Vd(t);
        if (!e.space) {
          return null;
        }
        return e;
      }
      function Kd(t) {
        return Object.keys(jd).includes(t.space);
      }
      var Ud = function () {
        return St.Date.now();
      };
      const Zd = Ud;
      var Jd = /\s/;
      function Yd(t) {
        var e = t.length;
        while (e-- && Jd.test(t.charAt(e))) {}
        return e;
      }
      const Qd = Yd;
      var Xd = /^\s+/;
      function th(t) {
        return t ? t.slice(0, Qd(t) + 1).replace(Xd, "") : t;
      }
      const eh = th;
      var nh = "[object Symbol]";
      function oh(t) {
        return typeof t == "symbol" || (Zt(t) && Wt(t) == nh);
      }
      const ih = oh;
      var rh = 0 / 0;
      var sh = /^[-+]0x[0-9a-f]+$/i;
      var ah = /^0b[01]+$/i;
      var ch = /^0o[0-7]+$/i;
      var lh = parseInt;
      function dh(t) {
        if (typeof t == "number") {
          return t;
        }
        if (ih(t)) {
          return rh;
        }
        if (nt(t)) {
          var e = typeof t.valueOf == "function" ? t.valueOf() : t;
          t = nt(e) ? e + "" : e;
        }
        if (typeof t != "string") {
          return t === 0 ? t : +t;
        }
        t = eh(t);
        var n = ah.test(t);
        return n || ch.test(t) ? lh(t.slice(2), n ? 2 : 8) : sh.test(t) ? rh : +t;
      }
      const hh = dh;
      var uh = "Expected a function";
      var fh = Math.max,
        ph = Math.min;
      function gh(t, e, n) {
        var o,
          i,
          r,
          s,
          a,
          c,
          l = 0,
          d = false,
          h = false,
          u = true;
        if (typeof t != "function") {
          throw new TypeError(uh);
        }
        e = hh(e) || 0;
        if (nt(n)) {
          d = !!n.leading;
          h = "maxWait" in n;
          r = h ? fh(hh(n.maxWait) || 0, e) : r;
          u = "trailing" in n ? !!n.trailing : u;
        }
        function f(e) {
          var n = o,
            r = i;
          o = i = undefined;
          l = e;
          s = t.apply(r, n);
          return s;
        }
        function p(t) {
          l = t;
          a = setTimeout(k, e);
          return d ? f(t) : s;
        }
        function g(t) {
          var n = t - c,
            o = t - l,
            i = e - n;
          return h ? ph(i, r - o) : i;
        }
        function m(t) {
          var n = t - c,
            o = t - l;
          return c === undefined || n >= e || n < 0 || (h && o >= r);
        }
        function k() {
          var t = Zd();
          if (m(t)) {
            return b(t);
          }
          a = setTimeout(k, g(t));
        }
        function b(t) {
          a = undefined;
          if (u && o) {
            return f(t);
          }
          o = i = undefined;
          return s;
        }
        function w() {
          if (a !== undefined) {
            clearTimeout(a);
          }
          l = 0;
          o = c = i = a = undefined;
        }
        function _() {
          return a === undefined ? s : b(Zd());
        }
        function v() {
          var t = Zd(),
            n = m(t);
          o = arguments;
          i = this;
          c = t;
          if (n) {
            if (a === undefined) {
              return p(c);
            }
            if (h) {
              clearTimeout(a);
              a = setTimeout(k, e);
              return f(c);
            }
          }
          if (a === undefined) {
            a = setTimeout(k, e);
          }
          return s;
        }
        v.cancel = w;
        v.flush = _;
        return v;
      }
      const mh = gh;
      var kh = n(525);
      var bh = { injectType: "singletonStyleTag", attributes: { "data-cke": true } };
      bh.insert = "head";
      bh.singleton = true;
      var wh = Pl()(kh.Z, bh);
      const _h = kh.Z.locals || {};
      class vh extends zl {
        constructor(t) {
          super(t);
          this.set("text", undefined);
          this.set("for", undefined);
          this.id = `ck-editor__label_${x()}`;
          const e = this.bindTemplate;
          this.setTemplate({
            tag: "label",
            attributes: { class: ["ck", "ck-label"], id: this.id, for: e.to("for") },
            children: [{ text: e.to("text") }],
          });
        }
      }
      var Ah = n(933);
      var Ch = { injectType: "singletonStyleTag", attributes: { "data-cke": true } };
      Ch.insert = "head";
      Ch.singleton = true;
      var yh = Pl()(Ah.Z, Ch);
      const xh = Ah.Z.locals || {};
      class Eh extends zl {
        constructor(t, e) {
          super(t);
          const n = `ck-labeled-field-view-${x()}`;
          const o = `ck-labeled-field-view-status-${x()}`;
          this.fieldView = e(this, n, o);
          this.set("label", undefined);
          this.set("isEnabled", true);
          this.set("isEmpty", true);
          this.set("isFocused", false);
          this.set("errorText", null);
          this.set("infoText", null);
          this.set("class", undefined);
          this.set("placeholder", undefined);
          this.labelView = this._createLabelView(n);
          this.statusView = this._createStatusView(o);
          this.fieldWrapperChildren = this.createCollection([this.fieldView, this.labelView]);
          this.bind("_statusText").to(this, "errorText", this, "infoText", (t, e) => t || e);
          const i = this.bindTemplate;
          this.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-labeled-field-view",
                i.to("class"),
                i.if("isEnabled", "ck-disabled", (t) => !t),
                i.if("isEmpty", "ck-labeled-field-view_empty"),
                i.if("isFocused", "ck-labeled-field-view_focused"),
                i.if("placeholder", "ck-labeled-field-view_placeholder"),
                i.if("errorText", "ck-error"),
              ],
            },
            children: [
              {
                tag: "div",
                attributes: { class: ["ck", "ck-labeled-field-view__input-wrapper"] },
                children: this.fieldWrapperChildren,
              },
              this.statusView,
            ],
          });
        }
        _createLabelView(t) {
          const e = new vh(this.locale);
          e.for = t;
          e.bind("text").to(this, "label");
          return e;
        }
        _createStatusView(t) {
          const e = new zl(this.locale);
          const n = this.bindTemplate;
          e.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-labeled-field-view__status",
                n.if("errorText", "ck-labeled-field-view__status_error"),
                n.if("_statusText", "ck-hidden", (t) => !t),
              ],
              id: t,
              role: n.if("errorText", "alert"),
            },
            children: [{ text: n.to("_statusText") }],
          });
          return e;
        }
        focus(t) {
          this.fieldView.focus(t);
        }
      }
      class Dh extends zl {
        constructor(t) {
          super(t);
          this.set("value", undefined);
          this.set("id", undefined);
          this.set("placeholder", undefined);
          this.set("isReadOnly", false);
          this.set("hasError", false);
          this.set("ariaDescribedById", undefined);
          this.focusTracker = new hl();
          this.bind("isFocused").to(this.focusTracker);
          this.set("isEmpty", true);
          const e = this.bindTemplate;
          this.setTemplate({
            tag: "input",
            attributes: {
              class: [
                "ck",
                "ck-input",
                e.if("isFocused", "ck-input_focused"),
                e.if("isEmpty", "ck-input-text_empty"),
                e.if("hasError", "ck-error"),
              ],
              id: e.to("id"),
              placeholder: e.to("placeholder"),
              readonly: e.to("isReadOnly"),
              "aria-invalid": e.if("hasError", true),
              "aria-describedby": e.to("ariaDescribedById"),
            },
            on: {
              input: e.to((...t) => {
                this.fire("input", ...t);
                this._updateIsEmpty();
              }),
              change: e.to(this._updateIsEmpty.bind(this)),
            },
          });
        }
        render() {
          super.render();
          this.focusTracker.add(this.element);
          this._setDomElementValue(this.value);
          this._updateIsEmpty();
          this.on("change:value", (t, e, n) => {
            this._setDomElementValue(n);
            this._updateIsEmpty();
          });
        }
        destroy() {
          super.destroy();
          this.focusTracker.destroy();
        }
        select() {
          this.element.select();
        }
        focus() {
          this.element.focus();
        }
        reset() {
          this.value = this.element.value = "";
          this._updateIsEmpty();
        }
        _updateIsEmpty() {
          this.isEmpty = Sh(this.element);
        }
        _setDomElementValue(t) {
          this.element.value = !t && t !== 0 ? "" : t;
        }
      }
      function Sh(t) {
        return !t.value;
      }
      var Th = n(470);
      var Ph = { injectType: "singletonStyleTag", attributes: { "data-cke": true } };
      Ph.insert = "head";
      Ph.singleton = true;
      var Bh = Pl()(Th.Z, Ph);
      const Oh = Th.Z.locals || {};
      class Rh extends Dh {
        constructor(t) {
          super(t);
          this.set("inputMode", "text");
          const e = this.bindTemplate;
          this.extendTemplate({ attributes: { inputmode: e.to("inputMode") } });
        }
      }
      class Ih extends Rh {
        constructor(t) {
          super(t);
          this.extendTemplate({ attributes: { type: "text", class: ["ck-input-text"] } });
        }
      }
      class zh extends (null && InputView) {
        constructor(t, { min: e, max: n, step: o } = {}) {
          super(t);
          const i = this.bindTemplate;
          this.set("min", e);
          this.set("max", n);
          this.set("step", o);
          this.extendTemplate({
            attributes: {
              type: "number",
              class: ["ck-input-number"],
              min: i.to("min"),
              max: i.to("max"),
              step: i.to("step"),
            },
          });
        }
      }
      var Fh = n(224);
      var Mh = { injectType: "singletonStyleTag", attributes: { "data-cke": true } };
      Mh.insert = "head";
      Mh.singleton = true;
      var Nh = Pl()(Fh.Z, Mh);
      const Vh = Fh.Z.locals || {};
      class Lh extends (null && InputBase) {
        constructor(t) {
          super(t);
          const e = toUnit("px");
          this.set("minRows", 2);
          this.set("maxRows", 5);
          this.set("_height", null);
          this.set("resize", "none");
          this.on("change:minRows", this._validateMinMaxRows.bind(this));
          this.on("change:maxRows", this._validateMinMaxRows.bind(this));
          const n = this.bindTemplate;
          this.template.tag = "textarea";
          this.extendTemplate({
            attributes: {
              class: ["ck-textarea"],
              style: { height: n.to("_height", (t) => (t ? e(t) : null)), resize: n.to("resize") },
              rows: n.to("minRows"),
            },
          });
        }
        render() {
          super.render();
          this.on("input", () => {
            this._updateAutoGrowHeight(true);
            this.fire("update");
          });
          this.on("change:value", () => {
            global.window.requestAnimationFrame(() => {
              this._updateAutoGrowHeight();
              this.fire("update");
            });
          });
        }
        reset() {
          super.reset();
          this._updateAutoGrowHeight();
          this.fire("update");
        }
        _updateAutoGrowHeight(t) {
          const e = this.element;
          const n = Hh(e, "1");
          const o = Hh(e, e.value);
          const i = n.ownerDocument.defaultView.getComputedStyle(n);
          const r = parseFloat(i.paddingTop) + parseFloat(i.paddingBottom);
          const s = getBorderWidths(n);
          const a = parseFloat(i.lineHeight);
          const c = s.top + s.bottom;
          const l = new Rect(n).height;
          const d = Math.round((o.scrollHeight - r) / a);
          const h = this.maxRows * a + r + c;
          const u = d === 1 ? l : this.minRows * a + r + c;
          this._height = Math.min(Math.max(Math.max(d, this.minRows) * a + r + c, u), h);
          if (t) {
            e.scrollTop = e.scrollHeight;
          }
          n.remove();
          o.remove();
        }
        _validateMinMaxRows() {
          if (this.minRows > this.maxRows) {
            throw new CKEditorError("ui-textarea-view-min-rows-greater-than-max-rows", {
              textareaView: this,
              minRows: this.minRows,
              maxRows: this.maxRows,
            });
          }
        }
      }
      function Hh(t, e) {
        const n = t.cloneNode();
        n.style.position = "absolute";
        n.style.top = "-99999px";
        n.style.left = "-99999px";
        n.style.height = "auto";
        n.style.overflow = "hidden";
        n.style.width = t.ownerDocument.defaultView.getComputedStyle(t).width;
        n.tabIndex = -1;
        n.rows = 1;
        n.value = e;
        t.parentNode.insertBefore(n, t);
        return n;
      }
      class jh extends zl {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          this.set("isVisible", false);
          this.set("position", "se");
          this.children = this.createCollection();
          this.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-reset",
                "ck-dropdown__panel",
                e.to("position", (t) => `ck-dropdown__panel_${t}`),
                e.if("isVisible", "ck-dropdown__panel-visible"),
              ],
              tabindex: "-1",
            },
            children: this.children,
            on: {
              selectstart: e.to((t) => {
                if (t.target.tagName.toLocaleLowerCase() === "input") {
                  return;
                }
                t.preventDefault();
              }),
            },
          });
        }
        focus() {
          if (this.children.length) {
            const t = this.children.first;
            if (typeof t.focus === "function") {
              t.focus();
            } else {
              B("ui-dropdown-panel-focus-child-missing-focus", {
                childView: this.children.first,
                dropdownPanel: this,
              });
            }
          }
        }
        focusLast() {
          if (this.children.length) {
            const t = this.children.last;
            if (typeof t.focusLast === "function") {
              t.focusLast();
            } else {
              t.focus();
            }
          }
        }
      }
      var qh = n(62);
      var $h = { injectType: "singletonStyleTag", attributes: { "data-cke": true } };
      $h.insert = "head";
      $h.singleton = true;
      var Wh = Pl()(qh.Z, $h);
      const Gh = qh.Z.locals || {};
      class Kh extends zl {
        constructor(t, e, n) {
          super(t);
          const o = this.bindTemplate;
          this.buttonView = e;
          this.panelView = n;
          this.set("isOpen", false);
          this.set("isEnabled", true);
          this.set("class", undefined);
          this.set("id", undefined);
          this.set("panelPosition", "auto");
          this.keystrokes = new ul();
          this.focusTracker = new hl();
          this.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-dropdown",
                o.to("class"),
                o.if("isEnabled", "ck-disabled", (t) => !t),
              ],
              id: o.to("id"),
              "aria-describedby": o.to("ariaDescribedById"),
            },
            children: [e, n],
          });
          e.extendTemplate({
            attributes: {
              class: ["ck-dropdown__button"],
              "data-cke-tooltip-disabled": o.to("isOpen"),
            },
          });
        }
        render() {
          super.render();
          this.focusTracker.add(this.buttonView.element);
          this.focusTracker.add(this.panelView.element);
          this.listenTo(this.buttonView, "open", () => {
            this.isOpen = !this.isOpen;
          });
          this.panelView.bind("isVisible").to(this, "isOpen");
          this.on("change:isOpen", (t, e, n) => {
            if (!n) {
              return;
            }
            if (this.panelPosition === "auto") {
              const t = Kh._getOptimalPosition({
                element: this.panelView.element,
                target: this.buttonView.element,
                fitInViewport: true,
                positions: this._panelPositions,
              });
              this.panelView.position = t ? t.name : this._panelPositions[0].name;
            } else {
              this.panelView.position = this.panelPosition;
            }
          });
          this.keystrokes.listenTo(this.element);
          const t = (t, e) => {
            if (this.isOpen) {
              this.isOpen = false;
              e();
            }
          };
          this.keystrokes.set("arrowdown", (t, e) => {
            if (this.buttonView.isEnabled && !this.isOpen) {
              this.isOpen = true;
              e();
            }
          });
          this.keystrokes.set("arrowright", (t, e) => {
            if (this.isOpen) {
              e();
            }
          });
          this.keystrokes.set("arrowleft", t);
          this.keystrokes.set("esc", t);
        }
        focus() {
          this.buttonView.focus();
        }
        get _panelPositions() {
          const {
            south: t,
            north: e,
            southEast: n,
            southWest: o,
            northEast: i,
            northWest: r,
            southMiddleEast: s,
            southMiddleWest: a,
            northMiddleEast: c,
            northMiddleWest: l,
          } = Kh.defaultPanelPositions;
          if (this.locale.uiLanguageDirection !== "rtl") {
            return [n, o, s, a, t, i, r, c, l, e];
          } else {
            return [o, n, a, s, t, r, i, l, c, e];
          }
        }
      }
      Kh.defaultPanelPositions = {
        south: (t, e) => ({ top: t.bottom, left: t.left - (e.width - t.width) / 2, name: "s" }),
        southEast: (t) => ({ top: t.bottom, left: t.left, name: "se" }),
        southWest: (t, e) => ({ top: t.bottom, left: t.left - e.width + t.width, name: "sw" }),
        southMiddleEast: (t, e) => ({
          top: t.bottom,
          left: t.left - (e.width - t.width) / 4,
          name: "sme",
        }),
        southMiddleWest: (t, e) => ({
          top: t.bottom,
          left: t.left - ((e.width - t.width) * 3) / 4,
          name: "smw",
        }),
        north: (t, e) => ({
          top: t.top - e.height,
          left: t.left - (e.width - t.width) / 2,
          name: "n",
        }),
        northEast: (t, e) => ({ top: t.top - e.height, left: t.left, name: "ne" }),
        northWest: (t, e) => ({
          top: t.top - e.height,
          left: t.left - e.width + t.width,
          name: "nw",
        }),
        northMiddleEast: (t, e) => ({
          top: t.top - e.height,
          left: t.left - (e.width - t.width) / 4,
          name: "nme",
        }),
        northMiddleWest: (t, e) => ({
          top: t.top - e.height,
          left: t.left - ((e.width - t.width) * 3) / 4,
          name: "nmw",
        }),
      };
      Kh._getOptimalPosition = Ac;
      const Uh =
        '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>';
      class Zh extends vd {
        constructor(t) {
          super(t);
          this.arrowView = this._createArrowView();
          this.extendTemplate({
            attributes: {
              "aria-haspopup": true,
              "aria-expanded": this.bindTemplate.to("isOn", (t) => String(t)),
            },
          });
          this.delegate("execute").to(this, "open");
        }
        render() {
          super.render();
          this.children.add(this.arrowView);
        }
        _createArrowView() {
          const t = new gd();
          t.content = Uh;
          t.extendTemplate({ attributes: { class: "ck-dropdown__arrow" } });
          return t;
        }
      }
      class Jh extends q() {
        constructor(t) {
          super();
          this.focusables = t.focusables;
          this.focusTracker = t.focusTracker;
          this.keystrokeHandler = t.keystrokeHandler;
          this.actions = t.actions;
          if (t.actions && t.keystrokeHandler) {
            for (const e in t.actions) {
              let n = t.actions[e];
              if (typeof n == "string") {
                n = [n];
              }
              for (const o of n) {
                t.keystrokeHandler.set(o, (t, n) => {
                  this[e]();
                  n();
                });
              }
            }
          }
          this.on("forwardCycle", () => this.focusFirst(), { priority: "low" });
          this.on("backwardCycle", () => this.focusLast(), { priority: "low" });
        }
        get first() {
          return this.focusables.find(Yh) || null;
        }
        get last() {
          return this.focusables.filter(Yh).slice(-1)[0] || null;
        }
        get next() {
          return this._getFocusableItem(1);
        }
        get previous() {
          return this._getFocusableItem(-1);
        }
        get current() {
          let t = null;
          if (this.focusTracker.focusedElement === null) {
            return null;
          }
          this.focusables.find((e, n) => {
            const o = e.element === this.focusTracker.focusedElement;
            if (o) {
              t = n;
            }
            return o;
          });
          return t;
        }
        focusFirst() {
          this._focus(this.first, 1);
        }
        focusLast() {
          this._focus(this.last, -1);
        }
        focusNext() {
          const t = this.next;
          if (t && this.focusables.getIndex(t) === this.current) {
            return;
          }
          if (t === this.first) {
            this.fire("forwardCycle");
          } else {
            this._focus(t, 1);
          }
        }
        focusPrevious() {
          const t = this.previous;
          if (t && this.focusables.getIndex(t) === this.current) {
            return;
          }
          if (t === this.last) {
            this.fire("backwardCycle");
          } else {
            this._focus(t, -1);
          }
        }
        _focus(t, e) {
          if (t) {
            t.focus(e);
          }
        }
        _getFocusableItem(t) {
          const e = this.current;
          const n = this.focusables.length;
          if (!n) {
            return null;
          }
          if (e === null) {
            return this[t === 1 ? "first" : "last"];
          }
          let o = (e + n + t) % n;
          do {
            const e = this.focusables.get(o);
            if (Yh(e)) {
              return e;
            }
            o = (o + n + t) % n;
          } while (o !== e);
          return null;
        }
      }
      function Yh(t) {
        return !!("focus" in t && vc(t.element));
      }
      class Qh extends zl {
        constructor(t) {
          super(t);
          this.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-toolbar__separator"] } });
        }
      }
      class Xh extends zl {
        constructor(t) {
          super(t);
          this.setTemplate({
            tag: "span",
            attributes: { class: ["ck", "ck-toolbar__line-break"] },
          });
        }
      }
      function tu(t) {
        return t.bindTemplate.to((e) => {
          if (e.target === t.element) {
            e.preventDefault();
          }
        });
      }
      function eu(t) {
        if (Array.isArray(t)) {
          return { items: t, removeItems: [] };
        }
        if (!t) {
          return { items: [], removeItems: [] };
        }
        return Object.assign({ items: [], removeItems: [] }, t);
      }
      class nu extends lt() {
        constructor(t) {
          super();
          this._disableStack = new Set();
          this.editor = t;
          this.set("isEnabled", true);
        }
        forceDisabled(t) {
          this._disableStack.add(t);
          if (this._disableStack.size == 1) {
            this.on("set:isEnabled", ou, { priority: "highest" });
            this.isEnabled = false;
          }
        }
        clearForceDisabled(t) {
          this._disableStack.delete(t);
          if (this._disableStack.size == 0) {
            this.off("set:isEnabled", ou);
            this.isEnabled = true;
          }
        }
        destroy() {
          this.stopListening();
        }
        static get isContextPlugin() {
          return false;
        }
      }
      function ou(t) {
        t.return = false;
        t.stop();
      }
      class iu extends lt() {
        constructor(t) {
          super();
          this.editor = t;
          this.set("value", undefined);
          this.set("isEnabled", false);
          this._affectsData = true;
          this._isEnabledBasedOnSelection = true;
          this._disableStack = new Set();
          this.decorate("execute");
          this.listenTo(this.editor.model.document, "change", () => {
            this.refresh();
          });
          this.listenTo(t, "change:isReadOnly", () => {
            this.refresh();
          });
          this.on(
            "set:isEnabled",
            (e) => {
              if (!this.affectsData) {
                return;
              }
              const n = t.model.document.selection;
              const o = n.getFirstPosition().root.rootName == "$graveyard";
              const i = !o && t.model.canEditAt(n);
              if (t.isReadOnly || (this._isEnabledBasedOnSelection && !i)) {
                e.return = false;
                e.stop();
              }
            },
            { priority: "highest" }
          );
          this.on(
            "execute",
            (t) => {
              if (!this.isEnabled) {
                t.stop();
              }
            },
            { priority: "high" }
          );
        }
        get affectsData() {
          return this._affectsData;
        }
        set affectsData(t) {
          this._affectsData = t;
        }
        refresh() {
          this.isEnabled = true;
        }
        forceDisabled(t) {
          this._disableStack.add(t);
          if (this._disableStack.size == 1) {
            this.on("set:isEnabled", ru, { priority: "highest" });
            this.isEnabled = false;
          }
        }
        clearForceDisabled(t) {
          this._disableStack.delete(t);
          if (this._disableStack.size == 0) {
            this.off("set:isEnabled", ru);
            this.refresh();
          }
        }
        execute(...t) {
          return undefined;
        }
        destroy() {
          this.stopListening();
        }
      }
      function ru(t) {
        t.return = false;
        t.stop();
      }
      class su extends (null && Command) {
        constructor() {
          super(...arguments);
          this._childCommandsDefinitions = [];
        }
        refresh() {}
        execute(...t) {
          const e = this._getFirstEnabledCommand();
          return !!e && e.execute(t);
        }
        registerChildCommand(t, e = {}) {
          insertToPriorityArray(this._childCommandsDefinitions, {
            command: t,
            priority: e.priority || "normal",
          });
          t.on("change:isEnabled", () => this._checkEnabled());
          this._checkEnabled();
        }
        _checkEnabled() {
          this.isEnabled = !!this._getFirstEnabledCommand();
        }
        _getFirstEnabledCommand() {
          const t = this._childCommandsDefinitions.find(({ command: t }) => t.isEnabled);
          return t && t.command;
        }
      }
      class au extends q() {
        constructor(t, e = [], n = []) {
          super();
          this._plugins = new Map();
          this._context = t;
          this._availablePlugins = new Map();
          for (const t of e) {
            if (t.pluginName) {
              this._availablePlugins.set(t.pluginName, t);
            }
          }
          this._contextPlugins = new Map();
          for (const [t, e] of n) {
            this._contextPlugins.set(t, e);
            this._contextPlugins.set(e, t);
            if (t.pluginName) {
              this._availablePlugins.set(t.pluginName, t);
            }
          }
        }
        *[Symbol.iterator]() {
          for (const t of this._plugins) {
            if (typeof t[0] == "function") {
              yield t;
            }
          }
        }
        get(t) {
          const e = this._plugins.get(t);
          if (!e) {
            let e = t;
            if (typeof t == "function") {
              e = t.pluginName || t.name;
            }
            throw new P("plugincollection-plugin-not-loaded", this._context, { plugin: e });
          }
          return e;
        }
        has(t) {
          return this._plugins.has(t);
        }
        init(t, e = [], n = []) {
          const o = this;
          const i = this._context;
          u(t);
          p(t);
          const r = t.filter((t) => !d(t, e));
          const s = [...f(r)];
          _(s, n);
          const a = b(s);
          return w(a, "init")
            .then(() => w(a, "afterInit"))
            .then(() => a);
          function c(t) {
            return typeof t === "function";
          }
          function l(t) {
            return c(t) && !!t.isContextPlugin;
          }
          function d(t, e) {
            return e.some((e) => {
              if (e === t) {
                return true;
              }
              if (h(t) === e) {
                return true;
              }
              if (h(e) === t) {
                return true;
              }
              return false;
            });
          }
          function h(t) {
            return c(t) ? t.pluginName || t.name : t;
          }
          function u(t, e = new Set()) {
            t.forEach((t) => {
              if (!c(t)) {
                return;
              }
              if (e.has(t)) {
                return;
              }
              e.add(t);
              if (t.pluginName && !o._availablePlugins.has(t.pluginName)) {
                o._availablePlugins.set(t.pluginName, t);
              }
              if (t.requires) {
                u(t.requires, e);
              }
            });
          }
          function f(t, e = new Set()) {
            return t
              .map((t) => (c(t) ? t : o._availablePlugins.get(t)))
              .reduce((t, n) => {
                if (e.has(n)) {
                  return t;
                }
                e.add(n);
                if (n.requires) {
                  p(n.requires, n);
                  f(n.requires, e).forEach((e) => t.add(e));
                }
                return t.add(n);
              }, new Set());
          }
          function p(t, e = null) {
            t.map((t) => (c(t) ? t : o._availablePlugins.get(t) || t)).forEach((t) => {
              g(t, e);
              m(t, e);
              k(t, e);
            });
          }
          function g(t, e) {
            if (c(t)) {
              return;
            }
            if (e) {
              throw new P("plugincollection-soft-required", i, {
                missingPlugin: t,
                requiredBy: h(e),
              });
            }
            throw new P("plugincollection-plugin-not-found", i, { plugin: t });
          }
          function m(t, e) {
            if (!l(e)) {
              return;
            }
            if (l(t)) {
              return;
            }
            throw new P("plugincollection-context-required", i, { plugin: h(t), requiredBy: h(e) });
          }
          function k(t, n) {
            if (!n) {
              return;
            }
            if (!d(t, e)) {
              return;
            }
            throw new P("plugincollection-required", i, { plugin: h(t), requiredBy: h(n) });
          }
          function b(t) {
            return t.map((t) => {
              let e = o._contextPlugins.get(t);
              e = e || new t(i);
              o._add(t, e);
              return e;
            });
          }
          function w(t, e) {
            return t.reduce((t, n) => {
              if (!n[e]) {
                return t;
              }
              if (o._contextPlugins.has(n)) {
                return t;
              }
              return t.then(n[e].bind(n));
            }, Promise.resolve());
          }
          function _(t, e) {
            for (const n of e) {
              if (typeof n != "function") {
                throw new P("plugincollection-replace-plugin-invalid-type", null, {
                  pluginItem: n,
                });
              }
              const e = n.pluginName;
              if (!e) {
                throw new P("plugincollection-replace-plugin-missing-name", null, {
                  pluginItem: n,
                });
              }
              if (n.requires && n.requires.length) {
                throw new P(
                  "plugincollection-plugin-for-replacing-cannot-have-dependencies",
                  null,
                  { pluginName: e }
                );
              }
              const i = o._availablePlugins.get(e);
              if (!i) {
                throw new P("plugincollection-plugin-for-replacing-not-exist", null, {
                  pluginName: e,
                });
              }
              const r = t.indexOf(i);
              if (r === -1) {
                if (o._contextPlugins.has(i)) {
                  return;
                }
                throw new P("plugincollection-plugin-for-replacing-not-loaded", null, {
                  pluginName: e,
                });
              }
              if (i.requires && i.requires.length) {
                throw new P("plugincollection-replaced-plugin-cannot-have-dependencies", null, {
                  pluginName: e,
                });
              }
              t.splice(r, 1, n);
              o._availablePlugins.set(e, n);
            }
          }
        }
        destroy() {
          const t = [];
          for (const [, e] of this) {
            if (typeof e.destroy == "function" && !this._contextPlugins.has(e)) {
              t.push(e.destroy());
            }
          }
          return Promise.all(t);
        }
        _add(t, e) {
          this._plugins.set(t, e);
          const n = t.pluginName;
          if (!n) {
            return;
          }
          if (this._plugins.has(n)) {
            throw new P("plugincollection-plugin-name-conflict", null, {
              pluginName: n,
              plugin1: this._plugins.get(n).constructor,
              plugin2: t,
            });
          }
          this._plugins.set(n, e);
        }
      }
      class cu {
        constructor(t) {
          this._contextOwner = null;
          this.config = new Ha(t, this.constructor.defaultConfig);
          const e = this.constructor.builtinPlugins;
          this.config.define("plugins", e);
          this.plugins = new au(this, e);
          const n = this.config.get("language") || {};
          this.locale = new al({
            uiLanguage: typeof n === "string" ? n : n.ui,
            contentLanguage: this.config.get("language.content"),
          });
          this.t = this.locale.t;
          this.editors = new ll();
        }
        initPlugins() {
          const t = this.config.get("plugins") || [];
          const e = this.config.get("substitutePlugins") || [];
          for (const n of t.concat(e)) {
            if (typeof n != "function") {
              throw new P("context-initplugins-constructor-only", null, { Plugin: n });
            }
            if (n.isContextPlugin !== true) {
              throw new P("context-initplugins-invalid-plugin", null, { Plugin: n });
            }
          }
          return this.plugins.init(t, [], e);
        }
        destroy() {
          return Promise.all(Array.from(this.editors, (t) => t.destroy())).then(() =>
            this.plugins.destroy()
          );
        }
        _addEditor(t, e) {
          if (this._contextOwner) {
            throw new P("context-addeditor-private-context");
          }
          this.editors.add(t);
          if (e) {
            this._contextOwner = t;
          }
        }
        _removeEditor(t) {
          if (this.editors.has(t)) {
            this.editors.remove(t);
          }
          if (this._contextOwner === t) {
            return this.destroy();
          }
          return Promise.resolve();
        }
        _getEditorConfig() {
          const t = {};
          for (const e of this.config.names()) {
            if (!["plugins", "removePlugins", "extraPlugins"].includes(e)) {
              t[e] = this.config.get(e);
            }
          }
          return t;
        }
        static create(t) {
          return new Promise((e) => {
            const n = new this(t);
            e(n.initPlugins().then(() => n));
          });
        }
      }
      class lu extends lt() {
        constructor(t) {
          super();
          this.context = t;
        }
        destroy() {
          this.stopListening();
        }
        static get isContextPlugin() {
          return true;
        }
      }
      var du = n(372);
      var hu = { injectType: "singletonStyleTag", attributes: { "data-cke": true } };
      hu.insert = "head";
      hu.singleton = true;
      var uu = Pl()(du.Z, hu);
      const fu = du.Z.locals || {};
      const pu = new WeakMap();
      let gu = false;
      function mu({
        view: t,
        element: e,
        text: n,
        isDirectHost: o = true,
        keepOnFocus: i = false,
      }) {
        const r = t.document;
        if (!pu.has(r)) {
          pu.set(r, new Map());
          r.registerPostFixer((t) => vu(r, t));
          r.on(
            "change:isComposing",
            () => {
              t.change((t) => vu(r, t));
            },
            { priority: "high" }
          );
        }
        if (e.is("editableElement")) {
          e.on("change:placeholder", (t, e, n) => {
            s(n);
          });
        }
        if (e.placeholder) {
          s(e.placeholder);
        } else if (n) {
          s(n);
        }
        if (n) {
          yu();
        }
        function s(n) {
          pu.get(r).set(e, { text: n, isDirectHost: o, keepOnFocus: i, hostElement: o ? e : null });
          t.change((t) => vu(r, t));
        }
      }
      function ku(t, e) {
        const n = e.document;
        if (!pu.has(n)) {
          return;
        }
        t.change((t) => {
          const o = pu.get(n);
          const i = o.get(e);
          t.removeAttribute("data-placeholder", i.hostElement);
          wu(t, i.hostElement);
          o.delete(e);
        });
      }
      function bu(t, e) {
        if (!e.hasClass("ck-placeholder")) {
          t.addClass("ck-placeholder", e);
          return true;
        }
        return false;
      }
      function wu(t, e) {
        if (e.hasClass("ck-placeholder")) {
          t.removeClass("ck-placeholder", e);
          return true;
        }
        return false;
      }
      function _u(t, e) {
        if (!t.isAttached()) {
          return false;
        }
        const n = Array.from(t.getChildren()).some((t) => !t.is("uiElement"));
        if (n) {
          return false;
        }
        const o = t.document;
        const i = o.selection;
        const r = i.anchor;
        if (o.isComposing && r && r.parent === t) {
          return false;
        }
        if (e) {
          return true;
        }
        if (!o.isFocused) {
          return true;
        }
        return !!r && r.parent !== t;
      }
      function vu(t, e) {
        const n = pu.get(t);
        const o = [];
        let i = false;
        for (const [t, r] of n) {
          if (r.isDirectHost) {
            o.push(t);
            if (Au(e, t, r)) {
              i = true;
            }
          }
        }
        for (const [t, r] of n) {
          if (r.isDirectHost) {
            continue;
          }
          const n = Cu(t);
          if (!n) {
            continue;
          }
          if (o.includes(n)) {
            continue;
          }
          r.hostElement = n;
          if (Au(e, t, r)) {
            i = true;
          }
        }
        return i;
      }
      function Au(t, e, n) {
        const { text: o, isDirectHost: i, hostElement: r } = n;
        let s = false;
        if (r.getAttribute("data-placeholder") !== o) {
          t.setAttribute("data-placeholder", o, r);
          s = true;
        }
        const a = i || e.childCount == 1;
        if (a && _u(r, n.keepOnFocus)) {
          if (bu(t, r)) {
            s = true;
          }
        } else if (wu(t, r)) {
          s = true;
        }
        return s;
      }
      function Cu(t) {
        if (t.childCount) {
          const e = t.getChild(0);
          if (e.is("element") && !e.is("uiElement") && !e.is("attributeElement")) {
            return e;
          }
        }
        return null;
      }
      function yu() {
        if (!gu) {
          B("enableplaceholder-deprecated-text-option");
        }
        gu = true;
      }
      class xu {
        is() {
          throw new Error("is() method is abstract");
        }
      }
      var Eu = 4;
      function Du(t) {
        return Ia(t, Eu);
      }
      const Su = Du;
      class Tu extends q(xu) {
        constructor(t) {
          super();
          this.document = t;
          this.parent = null;
        }
        get index() {
          let t;
          if (!this.parent) {
            return null;
          }
          if ((t = this.parent.getChildIndex(this)) == -1) {
            throw new P("view-node-not-found-in-parent", this);
          }
          return t;
        }
        get nextSibling() {
          const t = this.index;
          return (t !== null && this.parent.getChild(t + 1)) || null;
        }
        get previousSibling() {
          const t = this.index;
          return (t !== null && this.parent.getChild(t - 1)) || null;
        }
        get root() {
          let t = this;
          while (t.parent) {
            t = t.parent;
          }
          return t;
        }
        isAttached() {
          return this.root.is("rootElement");
        }
        getPath() {
          const t = [];
          let e = this;
          while (e.parent) {
            t.unshift(e.index);
            e = e.parent;
          }
          return t;
        }
        getAncestors(t = {}) {
          const e = [];
          let n = t.includeSelf ? this : this.parent;
          while (n) {
            e[t.parentFirst ? "push" : "unshift"](n);
            n = n.parent;
          }
          return e;
        }
        getCommonAncestor(t, e = {}) {
          const n = this.getAncestors(e);
          const o = t.getAncestors(e);
          let i = 0;
          while (n[i] == o[i] && n[i]) {
            i++;
          }
          return i === 0 ? null : n[i - 1];
        }
        isBefore(t) {
          if (this == t) {
            return false;
          }
          if (this.root !== t.root) {
            return false;
          }
          const e = this.getPath();
          const n = t.getPath();
          const o = At(e, n);
          switch (o) {
            case "prefix":
              return true;
            case "extension":
              return false;
            default:
              return e[o] < n[o];
          }
        }
        isAfter(t) {
          if (this == t) {
            return false;
          }
          if (this.root !== t.root) {
            return false;
          }
          return !this.isBefore(t);
        }
        _remove() {
          this.parent._removeChildren(this.index);
        }
        _fireChange(t, e) {
          this.fire(`change:${t}`, e);
          if (this.parent) {
            this.parent._fireChange(t, e);
          }
        }
        toJSON() {
          const t = Su(this);
          delete t.parent;
          return t;
        }
      }
      Tu.prototype.is = function (t) {
        return t === "node" || t === "view:node";
      };
      class Pu extends Tu {
        constructor(t, e) {
          super(t);
          this._textData = e;
        }
        get data() {
          return this._textData;
        }
        get _data() {
          return this.data;
        }
        set _data(t) {
          this._fireChange("text", this);
          this._textData = t;
        }
        isSimilar(t) {
          if (!(t instanceof Pu)) {
            return false;
          }
          return this === t || this.data === t.data;
        }
        _clone() {
          return new Pu(this.document, this.data);
        }
      }
      Pu.prototype.is = function (t) {
        return (
          t === "$text" ||
          t === "view:$text" ||
          t === "text" ||
          t === "view:text" ||
          t === "node" ||
          t === "view:node"
        );
      };
      class Bu extends xu {
        constructor(t, e, n) {
          super();
          this.textNode = t;
          if (e < 0 || e > t.data.length) {
            throw new P("view-textproxy-wrong-offsetintext", this);
          }
          if (n < 0 || e + n > t.data.length) {
            throw new P("view-textproxy-wrong-length", this);
          }
          this.data = t.data.substring(e, e + n);
          this.offsetInText = e;
        }
        get offsetSize() {
          return this.data.length;
        }
        get isPartial() {
          return this.data.length !== this.textNode.data.length;
        }
        get parent() {
          return this.textNode.parent;
        }
        get root() {
          return this.textNode.root;
        }
        get document() {
          return this.textNode.document;
        }
        getAncestors(t = {}) {
          const e = [];
          let n = t.includeSelf ? this.textNode : this.parent;
          while (n !== null) {
            e[t.parentFirst ? "push" : "unshift"](n);
            n = n.parent;
          }
          return e;
        }
      }
      Bu.prototype.is = function (t) {
        return (
          t === "$textProxy" ||
          t === "view:$textProxy" ||
          t === "textProxy" ||
          t === "view:textProxy"
        );
      };
      class Ou {
        constructor(...t) {
          this._patterns = [];
          this.add(...t);
        }
        add(...t) {
          for (let e of t) {
            if (typeof e == "string" || e instanceof RegExp) {
              e = { name: e };
            }
            this._patterns.push(e);
          }
        }
        match(...t) {
          for (const e of t) {
            for (const t of this._patterns) {
              const n = Ru(e, t);
              if (n) {
                return { element: e, pattern: t, match: n };
              }
            }
          }
          return null;
        }
        matchAll(...t) {
          const e = [];
          for (const n of t) {
            for (const t of this._patterns) {
              const o = Ru(n, t);
              if (o) {
                e.push({ element: n, pattern: t, match: o });
              }
            }
          }
          return e.length > 0 ? e : null;
        }
        getElementName() {
          if (this._patterns.length !== 1) {
            return null;
          }
          const t = this._patterns[0];
          const e = t.name;
          return typeof t != "function" && e && !(e instanceof RegExp) ? e : null;
        }
      }
      function Ru(t, e) {
        if (typeof e == "function") {
          return e(t);
        }
        const n = {};
        if (e.name) {
          n.name = Iu(e.name, t.name);
          if (!n.name) {
            return null;
          }
        }
        if (e.attributes) {
          n.attributes = Vu(e.attributes, t);
          if (!n.attributes) {
            return null;
          }
        }
        if (e.classes) {
          n.classes = Lu(e.classes, t);
          if (!n.classes) {
            return null;
          }
        }
        if (e.styles) {
          n.styles = Hu(e.styles, t);
          if (!n.styles) {
            return null;
          }
        }
        return n;
      }
      function Iu(t, e) {
        if (t instanceof RegExp) {
          return !!e.match(t);
        }
        return t === e;
      }
      function zu(t, e, n) {
        const o = Fu(t);
        const i = Array.from(e);
        const r = [];
        o.forEach(([t, e]) => {
          i.forEach((o) => {
            if (Mu(t, o) && Nu(e, o, n)) {
              r.push(o);
            }
          });
        });
        if (!o.length || r.length < o.length) {
          return undefined;
        }
        return r;
      }
      function Fu(t) {
        if (Array.isArray(t)) {
          return t.map((t) => {
            if (he(t)) {
              if (t.key === undefined || t.value === undefined) {
                B("matcher-pattern-missing-key-or-value", t);
              }
              return [t.key, t.value];
            }
            return [t, true];
          });
        }
        if (he(t)) {
          return Object.entries(t);
        }
        return [[t, true]];
      }
      function Mu(t, e) {
        return t === true || t === e || (t instanceof RegExp && e.match(t));
      }
      function Nu(t, e, n) {
        if (t === true) {
          return true;
        }
        const o = n(e);
        return t === o || (t instanceof RegExp && !!String(o).match(t));
      }
      function Vu(t, e) {
        const n = new Set(e.getAttributeKeys());
        if (he(t)) {
          if (t.style !== undefined) {
            B("matcher-pattern-deprecated-attributes-style-key", t);
          }
          if (t.class !== undefined) {
            B("matcher-pattern-deprecated-attributes-class-key", t);
          }
        } else {
          n.delete("style");
          n.delete("class");
        }
        return zu(t, n, (t) => e.getAttribute(t));
      }
      function Lu(t, e) {
        return zu(t, e.getClassNames(), () => {});
      }
      function Hu(t, e) {
        return zu(t, e.getStyleNames(true), (t) => e.getStyle(t));
      }
      var ju = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        qu = /^\w*$/;
      function $u(t, e) {
        if (Kt(t)) {
          return false;
        }
        var n = typeof t;
        if (n == "number" || n == "symbol" || n == "boolean" || t == null || ih(t)) {
          return true;
        }
        return qu.test(t) || !ju.test(t) || (e != null && t in Object(e));
      }
      const Wu = $u;
      var Gu = "Expected a function";
      function Ku(t, e) {
        if (typeof t != "function" || (e != null && typeof e != "function")) {
          throw new TypeError(Gu);
        }
        var n = function () {
          var o = arguments,
            i = e ? e.apply(this, o) : o[0],
            r = n.cache;
          if (r.has(i)) {
            return r.get(i);
          }
          var s = t.apply(this, o);
          n.cache = r.set(i, s) || r;
          return s;
        };
        n.cache = new (Ku.Cache || Jn)();
        return n;
      }
      Ku.Cache = Jn;
      const Uu = Ku;
      var Zu = 500;
      function Ju(t) {
        var e = Uu(t, function (t) {
          if (n.size === Zu) {
            n.clear();
          }
          return t;
        });
        var n = e.cache;
        return e;
      }
      const Yu = Ju;
      var Qu =
        /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var Xu = /\\(\\)?/g;
      var tf = Yu(function (t) {
        var e = [];
        if (t.charCodeAt(0) === 46) {
          e.push("");
        }
        t.replace(Qu, function (t, n, o, i) {
          e.push(o ? i.replace(Xu, "$1") : n || t);
        });
        return e;
      });
      const ef = tf;
      function nf(t, e) {
        var n = -1,
          o = t == null ? 0 : t.length,
          i = Array(o);
        while (++n < o) {
          i[n] = e(t[n], n, t);
        }
        return i;
      }
      const of = nf;
      var rf = 1 / 0;
      var sf = Pt ? Pt.prototype : undefined,
        af = sf ? sf.toString : undefined;
      function cf(t) {
        if (typeof t == "string") {
          return t;
        }
        if (Kt(t)) {
          return of(t, cf) + "";
        }
        if (ih(t)) {
          return af ? af.call(t) : "";
        }
        var e = t + "";
        return e == "0" && 1 / t == -rf ? "-0" : e;
      }
      const lf = cf;
      function df(t) {
        return t == null ? "" : lf(t);
      }
      const hf = df;
      function uf(t, e) {
        if (Kt(t)) {
          return t;
        }
        return Wu(t, e) ? [t] : ef(hf(t));
      }
      const ff = uf;
      function pf(t) {
        var e = t == null ? 0 : t.length;
        return e ? t[e - 1] : undefined;
      }
      const gf = pf;
      var mf = 1 / 0;
      function kf(t) {
        if (typeof t == "string" || ih(t)) {
          return t;
        }
        var e = t + "";
        return e == "0" && 1 / t == -mf ? "-0" : e;
      }
      const bf = kf;
      function wf(t, e) {
        e = ff(e, t);
        var n = 0,
          o = e.length;
        while (t != null && n < o) {
          t = t[bf(e[n++])];
        }
        return n && n == o ? t : undefined;
      }
      const _f = wf;
      function vf(t, e, n) {
        var o = -1,
          i = t.length;
        if (e < 0) {
          e = -e > i ? 0 : i + e;
        }
        n = n > i ? i : n;
        if (n < 0) {
          n += i;
        }
        i = e > n ? 0 : (n - e) >>> 0;
        e >>>= 0;
        var r = Array(i);
        while (++o < i) {
          r[o] = t[o + e];
        }
        return r;
      }
      const Af = vf;
      function Cf(t, e) {
        return e.length < 2 ? t : _f(t, Af(e, 0, -1));
      }
      const yf = Cf;
      function xf(t, e) {
        e = ff(e, t);
        t = yf(t, e);
        return t == null || delete t[bf(gf(e))];
      }
      const Ef = xf;
      function Df(t, e) {
        return t == null ? true : Ef(t, e);
      }
      const Sf = Df;
      function Tf(t, e, n) {
        var o = t == null ? undefined : _f(t, e);
        return o === undefined ? n : o;
      }
      const Pf = Tf;
      function Bf(t, e, n) {
        if ((n !== undefined && !ge(t[e], n)) || (n === undefined && !(e in t))) {
          ao(t, e, n);
        }
      }
      const Of = Bf;
      function Rf(t) {
        return function (e, n, o) {
          var i = -1,
            r = Object(e),
            s = o(e),
            a = s.length;
          while (a--) {
            var c = s[t ? a : ++i];
            if (n(r[c], c, r) === false) {
              break;
            }
          }
          return e;
        };
      }
      const If = Rf;
      var zf = If();
      const Ff = zf;
      function Mf(t) {
        return Zt(t) && Vi(t);
      }
      const Nf = Mf;
      function Vf(t, e) {
        if (e === "constructor" && typeof t[e] === "function") {
          return;
        }
        if (e == "__proto__") {
          return;
        }
        return t[e];
      }
      const Lf = Vf;
      function Hf(t) {
        return po(t, Yi(t));
      }
      const jf = Hf;
      function qf(t, e, n, o, i, r, s) {
        var a = Lf(t, n),
          c = Lf(e, n),
          l = s.get(c);
        if (l) {
          Of(t, n, l);
          return;
        }
        var d = r ? r(a, c, n + "", t, e, s) : undefined;
        var h = d === undefined;
        if (h) {
          var u = Kt(c),
            f = !u && Ro(c),
            p = !u && !f && yi(c);
          d = c;
          if (u || f || p) {
            if (Kt(a)) {
              d = a;
            } else if (Nf(a)) {
              d = cr(a);
            } else if (f) {
              h = false;
              d = sr(c, true);
            } else if (p) {
              h = false;
              d = bs(c, true);
            } else {
              d = [];
            }
          } else if (he(c) || yo(c)) {
            d = a;
            if (yo(a)) {
              d = jf(a);
            } else if (!nt(a) || qe(a)) {
              d = $s(c);
            }
          } else {
            h = false;
          }
        }
        if (h) {
          s.set(c, d);
          i(d, c, o, r, s);
          s["delete"](c);
        }
        Of(t, n, d);
      }
      const $f = qf;
      function Wf(t, e, n, o, i) {
        if (t === e) {
          return;
        }
        Ff(
          e,
          function (r, s) {
            i || (i = new eo());
            if (nt(r)) {
              $f(t, e, s, n, Wf, o, i);
            } else {
              var a = o ? o(Lf(t, s), r, s + "", t, e, i) : undefined;
              if (a === undefined) {
                a = r;
              }
              Of(t, s, a);
            }
          },
          Yi
        );
      }
      const Gf = Wf;
      function Kf(t) {
        return t;
      }
      const Uf = Kf;
      function Zf(t, e, n) {
        switch (n.length) {
          case 0:
            return t.call(e);
          case 1:
            return t.call(e, n[0]);
          case 2:
            return t.call(e, n[0], n[1]);
          case 3:
            return t.call(e, n[0], n[1], n[2]);
        }
        return t.apply(e, n);
      }
      const Jf = Zf;
      var Yf = Math.max;
      function Qf(t, e, n) {
        e = Yf(e === undefined ? t.length - 1 : e, 0);
        return function () {
          var o = arguments,
            i = -1,
            r = Yf(o.length - e, 0),
            s = Array(r);
          while (++i < r) {
            s[i] = o[e + i];
          }
          i = -1;
          var a = Array(e + 1);
          while (++i < e) {
            a[i] = o[i];
          }
          a[e] = n(s);
          return Jf(t, this, a);
        };
      }
      const Xf = Qf;
      function tp(t) {
        return function () {
          return t;
        };
      }
      const ep = tp;
      var np = !ro
        ? Uf
        : function (t, e) {
            return ro(t, "toString", {
              configurable: true,
              enumerable: false,
              value: ep(e),
              writable: true,
            });
          };
      const op = np;
      var ip = 800,
        rp = 16;
      var sp = Date.now;
      function ap(t) {
        var e = 0,
          n = 0;
        return function () {
          var o = sp(),
            i = rp - (o - n);
          n = o;
          if (i > 0) {
            if (++e >= ip) {
              return arguments[0];
            }
          } else {
            e = 0;
          }
          return t.apply(undefined, arguments);
        };
      }
      const cp = ap;
      var lp = cp(op);
      const dp = lp;
      function hp(t, e) {
        return dp(Xf(t, e, Uf), t + "");
      }
      const up = hp;
      function fp(t, e, n) {
        if (!nt(n)) {
          return false;
        }
        var o = typeof e;
        if (o == "number" ? Vi(n) && Mo(e, n.length) : o == "string" && e in n) {
          return ge(n[e], t);
        }
        return false;
      }
      const pp = fp;
      function gp(t) {
        return up(function (e, n) {
          var o = -1,
            i = n.length,
            r = i > 1 ? n[i - 1] : undefined,
            s = i > 2 ? n[2] : undefined;
          r = t.length > 3 && typeof r == "function" ? (i--, r) : undefined;
          if (s && pp(n[0], n[1], s)) {
            r = i < 3 ? undefined : r;
            i = 1;
          }
          e = Object(e);
          while (++o < i) {
            var a = n[o];
            if (a) {
              t(e, a, o, r);
            }
          }
          return e;
        });
      }
      const mp = gp;
      var kp = mp(function (t, e, n) {
        Gf(t, e, n);
      });
      const bp = kp;
      function wp(t, e, n, o) {
        if (!nt(t)) {
          return t;
        }
        e = ff(e, t);
        var i = -1,
          r = e.length,
          s = r - 1,
          a = t;
        while (a != null && ++i < r) {
          var c = bf(e[i]),
            l = n;
          if (c === "__proto__" || c === "constructor" || c === "prototype") {
            return t;
          }
          if (i != s) {
            var d = a[c];
            l = o ? o(d, c, a) : undefined;
            if (l === undefined) {
              l = nt(d) ? d : Mo(e[i + 1]) ? [] : {};
            }
          }
          uo(a, c, l);
          a = a[c];
        }
        return t;
      }
      const _p = wp;
      function vp(t, e, n) {
        return t == null ? t : _p(t, e, n);
      }
      const Ap = vp;
      class Cp {
        constructor(t) {
          this._styles = {};
          this._styleProcessor = t;
        }
        get isEmpty() {
          const t = Object.entries(this._styles);
          const e = Array.from(t);
          return !e.length;
        }
        get size() {
          if (this.isEmpty) {
            return 0;
          }
          return this.getStyleNames().length;
        }
        setTo(t) {
          this.clear();
          const e = Array.from(xp(t).entries());
          for (const [t, n] of e) {
            this._styleProcessor.toNormalizedForm(t, n, this._styles);
          }
        }
        has(t) {
          if (this.isEmpty) {
            return false;
          }
          const e = this._styleProcessor.getReducedForm(t, this._styles);
          const n = e.find(([e]) => e === t);
          return Array.isArray(n);
        }
        set(t, e) {
          if (nt(t)) {
            for (const [e, n] of Object.entries(t)) {
              this._styleProcessor.toNormalizedForm(e, n, this._styles);
            }
          } else {
            this._styleProcessor.toNormalizedForm(t, e, this._styles);
          }
        }
        remove(t) {
          const e = Ep(t);
          Sf(this._styles, e);
          delete this._styles[t];
          this._cleanEmptyObjectsOnPath(e);
        }
        getNormalized(t) {
          return this._styleProcessor.getNormalized(t, this._styles);
        }
        toString() {
          if (this.isEmpty) {
            return "";
          }
          return (
            this._getStylesEntries()
              .map((t) => t.join(":"))
              .sort()
              .join(";") + ";"
          );
        }
        getAsString(t) {
          if (this.isEmpty) {
            return;
          }
          if (this._styles[t] && !nt(this._styles[t])) {
            return this._styles[t];
          }
          const e = this._styleProcessor.getReducedForm(t, this._styles);
          const n = e.find(([e]) => e === t);
          if (Array.isArray(n)) {
            return n[1];
          }
        }
        getStyleNames(t = false) {
          if (this.isEmpty) {
            return [];
          }
          if (t) {
            return this._styleProcessor.getStyleNames(this._styles);
          }
          const e = this._getStylesEntries();
          return e.map(([t]) => t);
        }
        clear() {
          this._styles = {};
        }
        _getStylesEntries() {
          const t = [];
          const e = Object.keys(this._styles);
          for (const n of e) {
            t.push(...this._styleProcessor.getReducedForm(n, this._styles));
          }
          return t;
        }
        _cleanEmptyObjectsOnPath(t) {
          const e = t.split(".");
          const n = e.length > 1;
          if (!n) {
            return;
          }
          const o = e.splice(0, e.length - 1).join(".");
          const i = Pf(this._styles, o);
          if (!i) {
            return;
          }
          const r = !Array.from(Object.keys(i)).length;
          if (r) {
            this.remove(o);
          }
        }
      }
      class yp {
        constructor() {
          this._normalizers = new Map();
          this._extractors = new Map();
          this._reducers = new Map();
          this._consumables = new Map();
        }
        toNormalizedForm(t, e, n) {
          if (nt(e)) {
            Dp(n, Ep(t), e);
            return;
          }
          if (this._normalizers.has(t)) {
            const o = this._normalizers.get(t);
            const { path: i, value: r } = o(e);
            Dp(n, i, r);
          } else {
            Dp(n, t, e);
          }
        }
        getNormalized(t, e) {
          if (!t) {
            return bp({}, e);
          }
          if (e[t] !== undefined) {
            return e[t];
          }
          if (this._extractors.has(t)) {
            const n = this._extractors.get(t);
            if (typeof n === "string") {
              return Pf(e, n);
            }
            const o = n(t, e);
            if (o) {
              return o;
            }
          }
          return Pf(e, Ep(t));
        }
        getReducedForm(t, e) {
          const n = this.getNormalized(t, e);
          if (n === undefined) {
            return [];
          }
          if (this._reducers.has(t)) {
            const e = this._reducers.get(t);
            return e(n);
          }
          return [[t, n]];
        }
        getStyleNames(t) {
          const e = Array.from(this._consumables.keys()).filter((e) => {
            const n = this.getNormalized(e, t);
            if (n && typeof n == "object") {
              return Object.keys(n).length;
            }
            return n;
          });
          const n = new Set([...e, ...Object.keys(t)]);
          return Array.from(n.values());
        }
        getRelatedStyles(t) {
          return this._consumables.get(t) || [];
        }
        setNormalizer(t, e) {
          this._normalizers.set(t, e);
        }
        setExtractor(t, e) {
          this._extractors.set(t, e);
        }
        setReducer(t, e) {
          this._reducers.set(t, e);
        }
        setStyleRelation(t, e) {
          this._mapStyleNames(t, e);
          for (const n of e) {
            this._mapStyleNames(n, [t]);
          }
        }
        _mapStyleNames(t, e) {
          if (!this._consumables.has(t)) {
            this._consumables.set(t, []);
          }
          this._consumables.get(t).push(...e);
        }
      }
      function xp(t) {
        let e = null;
        let n = 0;
        let o = 0;
        let i = null;
        const r = new Map();
        if (t === "") {
          return r;
        }
        if (t.charAt(t.length - 1) != ";") {
          t = t + ";";
        }
        for (let s = 0; s < t.length; s++) {
          const a = t.charAt(s);
          if (e === null) {
            switch (a) {
              case ":":
                if (!i) {
                  i = t.substr(n, s - n);
                  o = s + 1;
                }
                break;
              case '"':
              case "'":
                e = a;
                break;
              case ";": {
                const e = t.substr(o, s - o);
                if (i) {
                  r.set(i.trim(), e.trim());
                }
                i = null;
                n = s + 1;
                break;
              }
            }
          } else if (a === e) {
            e = null;
          }
        }
        return r;
      }
      function Ep(t) {
        return t.replace("-", ".");
      }
      function Dp(t, e, n) {
        let o = n;
        if (nt(n)) {
          o = bp({}, Pf(t, e), n);
        }
        Ap(t, e, o);
      }
      class Sp extends Tu {
        constructor(t, e, n, o) {
          super(t);
          this._unsafeAttributesToRender = [];
          this._customProperties = new Map();
          this.name = e;
          this._attrs = Tp(n);
          this._children = [];
          if (o) {
            this._insertChild(0, o);
          }
          this._classes = new Set();
          if (this._attrs.has("class")) {
            const t = this._attrs.get("class");
            Pp(this._classes, t);
            this._attrs.delete("class");
          }
          this._styles = new Cp(this.document.stylesProcessor);
          if (this._attrs.has("style")) {
            this._styles.setTo(this._attrs.get("style"));
            this._attrs.delete("style");
          }
        }
        get childCount() {
          return this._children.length;
        }
        get isEmpty() {
          return this._children.length === 0;
        }
        getChild(t) {
          return this._children[t];
        }
        getChildIndex(t) {
          return this._children.indexOf(t);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        *getAttributeKeys() {
          if (this._classes.size > 0) {
            yield "class";
          }
          if (!this._styles.isEmpty) {
            yield "style";
          }
          yield* this._attrs.keys();
        }
        *getAttributes() {
          yield* this._attrs.entries();
          if (this._classes.size > 0) {
            yield ["class", this.getAttribute("class")];
          }
          if (!this._styles.isEmpty) {
            yield ["style", this.getAttribute("style")];
          }
        }
        getAttribute(t) {
          if (t == "class") {
            if (this._classes.size > 0) {
              return [...this._classes].join(" ");
            }
            return undefined;
          }
          if (t == "style") {
            const t = this._styles.toString();
            return t == "" ? undefined : t;
          }
          return this._attrs.get(t);
        }
        hasAttribute(t) {
          if (t == "class") {
            return this._classes.size > 0;
          }
          if (t == "style") {
            return !this._styles.isEmpty;
          }
          return this._attrs.has(t);
        }
        isSimilar(t) {
          if (!(t instanceof Sp)) {
            return false;
          }
          if (this === t) {
            return true;
          }
          if (this.name != t.name) {
            return false;
          }
          if (
            this._attrs.size !== t._attrs.size ||
            this._classes.size !== t._classes.size ||
            this._styles.size !== t._styles.size
          ) {
            return false;
          }
          for (const [e, n] of this._attrs) {
            if (!t._attrs.has(e) || t._attrs.get(e) !== n) {
              return false;
            }
          }
          for (const e of this._classes) {
            if (!t._classes.has(e)) {
              return false;
            }
          }
          for (const e of this._styles.getStyleNames()) {
            if (!t._styles.has(e) || t._styles.getAsString(e) !== this._styles.getAsString(e)) {
              return false;
            }
          }
          return true;
        }
        hasClass(...t) {
          for (const e of t) {
            if (!this._classes.has(e)) {
              return false;
            }
          }
          return true;
        }
        getClassNames() {
          return this._classes.keys();
        }
        getStyle(t) {
          return this._styles.getAsString(t);
        }
        getNormalizedStyle(t) {
          return this._styles.getNormalized(t);
        }
        getStyleNames(t) {
          return this._styles.getStyleNames(t);
        }
        hasStyle(...t) {
          for (const e of t) {
            if (!this._styles.has(e)) {
              return false;
            }
          }
          return true;
        }
        findAncestor(...t) {
          const e = new Ou(...t);
          let n = this.parent;
          while (n && !n.is("documentFragment")) {
            if (e.match(n)) {
              return n;
            }
            n = n.parent;
          }
          return null;
        }
        getCustomProperty(t) {
          return this._customProperties.get(t);
        }
        *getCustomProperties() {
          yield* this._customProperties.entries();
        }
        getIdentity() {
          const t = Array.from(this._classes).sort().join(",");
          const e = this._styles.toString();
          const n = Array.from(this._attrs)
            .map((t) => `${t[0]}="${t[1]}"`)
            .sort()
            .join(" ");
          return (
            this.name +
            (t == "" ? "" : ` class="${t}"`) +
            (!e ? "" : ` style="${e}"`) +
            (n == "" ? "" : ` ${n}`)
          );
        }
        shouldRenderUnsafeAttribute(t) {
          return this._unsafeAttributesToRender.includes(t);
        }
        _clone(t = false) {
          const e = [];
          if (t) {
            for (const n of this.getChildren()) {
              e.push(n._clone(t));
            }
          }
          const n = new this.constructor(this.document, this.name, this._attrs, e);
          n._classes = new Set(this._classes);
          n._styles.set(this._styles.getNormalized());
          n._customProperties = new Map(this._customProperties);
          n.getFillerOffset = this.getFillerOffset;
          n._unsafeAttributesToRender = this._unsafeAttributesToRender;
          return n;
        }
        _appendChild(t) {
          return this._insertChild(this.childCount, t);
        }
        _insertChild(t, e) {
          this._fireChange("children", this);
          let n = 0;
          const o = Bp(this.document, e);
          for (const e of o) {
            if (e.parent !== null) {
              e._remove();
            }
            e.parent = this;
            e.document = this.document;
            this._children.splice(t, 0, e);
            t++;
            n++;
          }
          return n;
        }
        _removeChildren(t, e = 1) {
          this._fireChange("children", this);
          for (let n = t; n < t + e; n++) {
            this._children[n].parent = null;
          }
          return this._children.splice(t, e);
        }
        _setAttribute(t, e) {
          const n = String(e);
          this._fireChange("attributes", this);
          if (t == "class") {
            Pp(this._classes, n);
          } else if (t == "style") {
            this._styles.setTo(n);
          } else {
            this._attrs.set(t, n);
          }
        }
        _removeAttribute(t) {
          this._fireChange("attributes", this);
          if (t == "class") {
            if (this._classes.size > 0) {
              this._classes.clear();
              return true;
            }
            return false;
          }
          if (t == "style") {
            if (!this._styles.isEmpty) {
              this._styles.clear();
              return true;
            }
            return false;
          }
          return this._attrs.delete(t);
        }
        _addClass(t) {
          this._fireChange("attributes", this);
          for (const e of Xc(t)) {
            this._classes.add(e);
          }
        }
        _removeClass(t) {
          this._fireChange("attributes", this);
          for (const e of Xc(t)) {
            this._classes.delete(e);
          }
        }
        _setStyle(t, e) {
          this._fireChange("attributes", this);
          if (typeof t != "string") {
            this._styles.set(t);
          } else {
            this._styles.set(t, e);
          }
        }
        _removeStyle(t) {
          this._fireChange("attributes", this);
          for (const e of Xc(t)) {
            this._styles.remove(e);
          }
        }
        _setCustomProperty(t, e) {
          this._customProperties.set(t, e);
        }
        _removeCustomProperty(t) {
          return this._customProperties.delete(t);
        }
      }
      Sp.prototype.is = function (t, e) {
        if (!e) {
          return t === "element" || t === "view:element" || t === "node" || t === "view:node";
        } else {
          return e === this.name && (t === "element" || t === "view:element");
        }
      };
      function Tp(t) {
        const e = pl(t);
        for (const [t, n] of e) {
          if (n === null) {
            e.delete(t);
          } else if (typeof n != "string") {
            e.set(t, String(n));
          }
        }
        return e;
      }
      function Pp(t, e) {
        const n = e.split(/\s+/);
        t.clear();
        n.forEach((e) => t.add(e));
      }
      function Bp(t, e) {
        if (typeof e == "string") {
          return [new Pu(t, e)];
        }
        if (!Ct(e)) {
          e = [e];
        }
        return Array.from(e).map((e) => {
          if (typeof e == "string") {
            return new Pu(t, e);
          }
          if (e instanceof Bu) {
            return new Pu(t, e.data);
          }
          return e;
        });
      }
      class Op extends Sp {
        constructor(t, e, n, o) {
          super(t, e, n, o);
          this.getFillerOffset = Rp;
        }
      }
      Op.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === "containerElement" ||
            t === "view:containerElement" ||
            t === "element" ||
            t === "view:element" ||
            t === "node" ||
            t === "view:node"
          );
        } else {
          return (
            e === this.name &&
            (t === "containerElement" ||
              t === "view:containerElement" ||
              t === "element" ||
              t === "view:element")
          );
        }
      };
      function Rp() {
        const t = [...this.getChildren()];
        const e = t[this.childCount - 1];
        if (e && e.is("element", "br")) {
          return this.childCount;
        }
        for (const e of t) {
          if (!e.is("uiElement")) {
            return null;
          }
        }
        return this.childCount;
      }
      class Ip extends lt(Op) {
        constructor(t, e, n, o) {
          super(t, e, n, o);
          this.set("isReadOnly", false);
          this.set("isFocused", false);
          this.set("placeholder", undefined);
          this.bind("isReadOnly").to(t);
          this.bind("isFocused").to(
            t,
            "isFocused",
            (e) => e && t.selection.editableElement == this
          );
          this.listenTo(t.selection, "change", () => {
            this.isFocused = t.isFocused && t.selection.editableElement == this;
          });
        }
        destroy() {
          this.stopListening();
        }
      }
      Ip.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === "editableElement" ||
            t === "view:editableElement" ||
            t === "containerElement" ||
            t === "view:containerElement" ||
            t === "element" ||
            t === "view:element" ||
            t === "node" ||
            t === "view:node"
          );
        } else {
          return (
            e === this.name &&
            (t === "editableElement" ||
              t === "view:editableElement" ||
              t === "containerElement" ||
              t === "view:containerElement" ||
              t === "element" ||
              t === "view:element")
          );
        }
      };
      const zp = Symbol("rootName");
      class Fp extends Ip {
        constructor(t, e) {
          super(t, e);
          this.rootName = "main";
        }
        get rootName() {
          return this.getCustomProperty(zp);
        }
        set rootName(t) {
          this._setCustomProperty(zp, t);
        }
        set _name(t) {
          this.name = t;
        }
      }
      Fp.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === "rootElement" ||
            t === "view:rootElement" ||
            t === "editableElement" ||
            t === "view:editableElement" ||
            t === "containerElement" ||
            t === "view:containerElement" ||
            t === "element" ||
            t === "view:element" ||
            t === "node" ||
            t === "view:node"
          );
        } else {
          return (
            e === this.name &&
            (t === "rootElement" ||
              t === "view:rootElement" ||
              t === "editableElement" ||
              t === "view:editableElement" ||
              t === "containerElement" ||
              t === "view:containerElement" ||
              t === "element" ||
              t === "view:element")
          );
        }
      };
      class Mp {
        constructor(t = {}) {
          if (!t.boundaries && !t.startPosition) {
            throw new P("view-tree-walker-no-start-position", null);
          }
          if (t.direction && t.direction != "forward" && t.direction != "backward") {
            throw new P("view-tree-walker-unknown-direction", t.startPosition, {
              direction: t.direction,
            });
          }
          this.boundaries = t.boundaries || null;
          if (t.startPosition) {
            this._position = Np._createAt(t.startPosition);
          } else {
            this._position = Np._createAt(
              t.boundaries[t.direction == "backward" ? "end" : "start"]
            );
          }
          this.direction = t.direction || "forward";
          this.singleCharacters = !!t.singleCharacters;
          this.shallow = !!t.shallow;
          this.ignoreElementEnd = !!t.ignoreElementEnd;
          this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;
          this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;
        }
        [Symbol.iterator]() {
          return this;
        }
        get position() {
          return this._position;
        }
        skip(t) {
          let e;
          let n;
          do {
            n = this.position;
            e = this.next();
          } while (!e.done && t(e.value));
          if (!e.done) {
            this._position = n;
          }
        }
        next() {
          if (this.direction == "forward") {
            return this._next();
          } else {
            return this._previous();
          }
        }
        _next() {
          let t = this.position.clone();
          const e = this.position;
          const n = t.parent;
          if (n.parent === null && t.offset === n.childCount) {
            return { done: true, value: undefined };
          }
          if (n === this._boundaryEndParent && t.offset == this.boundaries.end.offset) {
            return { done: true, value: undefined };
          }
          let o;
          if (n instanceof Pu) {
            if (t.isAtEnd) {
              this._position = Np._createAfter(n);
              return this._next();
            }
            o = n.data[t.offset];
          } else {
            o = n.getChild(t.offset);
          }
          if (o instanceof Sp) {
            if (!this.shallow) {
              t = new Np(o, 0);
            } else {
              if (this.boundaries && this.boundaries.end.isBefore(t)) {
                return { done: true, value: undefined };
              }
              t.offset++;
            }
            this._position = t;
            return this._formatReturnValue("elementStart", o, e, t, 1);
          }
          if (o instanceof Pu) {
            if (this.singleCharacters) {
              t = new Np(o, 0);
              this._position = t;
              return this._next();
            }
            let n = o.data.length;
            let i;
            if (o == this._boundaryEndParent) {
              n = this.boundaries.end.offset;
              i = new Bu(o, 0, n);
              t = Np._createAfter(i);
            } else {
              i = new Bu(o, 0, o.data.length);
              t.offset++;
            }
            this._position = t;
            return this._formatReturnValue("text", i, e, t, n);
          }
          if (typeof o == "string") {
            let o;
            if (this.singleCharacters) {
              o = 1;
            } else {
              const e = n === this._boundaryEndParent ? this.boundaries.end.offset : n.data.length;
              o = e - t.offset;
            }
            const i = new Bu(n, t.offset, o);
            t.offset += o;
            this._position = t;
            return this._formatReturnValue("text", i, e, t, o);
          }
          t = Np._createAfter(n);
          this._position = t;
          if (this.ignoreElementEnd) {
            return this._next();
          }
          return this._formatReturnValue("elementEnd", n, e, t);
        }
        _previous() {
          let t = this.position.clone();
          const e = this.position;
          const n = t.parent;
          if (n.parent === null && t.offset === 0) {
            return { done: true, value: undefined };
          }
          if (n == this._boundaryStartParent && t.offset == this.boundaries.start.offset) {
            return { done: true, value: undefined };
          }
          let o;
          if (n instanceof Pu) {
            if (t.isAtStart) {
              this._position = Np._createBefore(n);
              return this._previous();
            }
            o = n.data[t.offset - 1];
          } else {
            o = n.getChild(t.offset - 1);
          }
          if (o instanceof Sp) {
            if (this.shallow) {
              t.offset--;
              this._position = t;
              return this._formatReturnValue("elementStart", o, e, t, 1);
            }
            t = new Np(o, o.childCount);
            this._position = t;
            if (this.ignoreElementEnd) {
              return this._previous();
            }
            return this._formatReturnValue("elementEnd", o, e, t);
          }
          if (o instanceof Pu) {
            if (this.singleCharacters) {
              t = new Np(o, o.data.length);
              this._position = t;
              return this._previous();
            }
            let n = o.data.length;
            let i;
            if (o == this._boundaryStartParent) {
              const e = this.boundaries.start.offset;
              i = new Bu(o, e, o.data.length - e);
              n = i.data.length;
              t = Np._createBefore(i);
            } else {
              i = new Bu(o, 0, o.data.length);
              t.offset--;
            }
            this._position = t;
            return this._formatReturnValue("text", i, e, t, n);
          }
          if (typeof o == "string") {
            let o;
            if (!this.singleCharacters) {
              const e = n === this._boundaryStartParent ? this.boundaries.start.offset : 0;
              o = t.offset - e;
            } else {
              o = 1;
            }
            t.offset -= o;
            const i = new Bu(n, t.offset, o);
            this._position = t;
            return this._formatReturnValue("text", i, e, t, o);
          }
          t = Np._createBefore(n);
          this._position = t;
          return this._formatReturnValue("elementStart", n, e, t, 1);
        }
        _formatReturnValue(t, e, n, o, i) {
          if (e instanceof Bu) {
            if (e.offsetInText + e.data.length == e.textNode.data.length) {
              if (
                this.direction == "forward" &&
                !(this.boundaries && this.boundaries.end.isEqual(this.position))
              ) {
                o = Np._createAfter(e.textNode);
                this._position = o;
              } else {
                n = Np._createAfter(e.textNode);
              }
            }
            if (e.offsetInText === 0) {
              if (
                this.direction == "backward" &&
                !(this.boundaries && this.boundaries.start.isEqual(this.position))
              ) {
                o = Np._createBefore(e.textNode);
                this._position = o;
              } else {
                n = Np._createBefore(e.textNode);
              }
            }
          }
          return {
            done: false,
            value: { type: t, item: e, previousPosition: n, nextPosition: o, length: i },
          };
        }
      }
      class Np extends xu {
        constructor(t, e) {
          super();
          this.parent = t;
          this.offset = e;
        }
        get nodeAfter() {
          if (this.parent.is("$text")) {
            return null;
          }
          return this.parent.getChild(this.offset) || null;
        }
        get nodeBefore() {
          if (this.parent.is("$text")) {
            return null;
          }
          return this.parent.getChild(this.offset - 1) || null;
        }
        get isAtStart() {
          return this.offset === 0;
        }
        get isAtEnd() {
          const t = this.parent.is("$text") ? this.parent.data.length : this.parent.childCount;
          return this.offset === t;
        }
        get root() {
          return this.parent.root;
        }
        get editableElement() {
          let t = this.parent;
          while (!(t instanceof Ip)) {
            if (t.parent) {
              t = t.parent;
            } else {
              return null;
            }
          }
          return t;
        }
        getShiftedBy(t) {
          const e = Np._createAt(this);
          const n = e.offset + t;
          e.offset = n < 0 ? 0 : n;
          return e;
        }
        getLastMatchingPosition(t, e = {}) {
          e.startPosition = this;
          const n = new Mp(e);
          n.skip(t);
          return n.position;
        }
        getAncestors() {
          if (this.parent.is("documentFragment")) {
            return [this.parent];
          } else {
            return this.parent.getAncestors({ includeSelf: true });
          }
        }
        getCommonAncestor(t) {
          const e = this.getAncestors();
          const n = t.getAncestors();
          let o = 0;
          while (e[o] == n[o] && e[o]) {
            o++;
          }
          return o === 0 ? null : e[o - 1];
        }
        isEqual(t) {
          return this.parent == t.parent && this.offset == t.offset;
        }
        isBefore(t) {
          return this.compareWith(t) == "before";
        }
        isAfter(t) {
          return this.compareWith(t) == "after";
        }
        compareWith(t) {
          if (this.root !== t.root) {
            return "different";
          }
          if (this.isEqual(t)) {
            return "same";
          }
          const e = this.parent.is("node") ? this.parent.getPath() : [];
          const n = t.parent.is("node") ? t.parent.getPath() : [];
          e.push(this.offset);
          n.push(t.offset);
          const o = At(e, n);
          switch (o) {
            case "prefix":
              return "before";
            case "extension":
              return "after";
            default:
              return e[o] < n[o] ? "before" : "after";
          }
        }
        getWalker(t = {}) {
          t.startPosition = this;
          return new Mp(t);
        }
        clone() {
          return new Np(this.parent, this.offset);
        }
        static _createAt(t, e) {
          if (t instanceof Np) {
            return new this(t.parent, t.offset);
          } else {
            const n = t;
            if (e == "end") {
              e = n.is("$text") ? n.data.length : n.childCount;
            } else if (e == "before") {
              return this._createBefore(n);
            } else if (e == "after") {
              return this._createAfter(n);
            } else if (e !== 0 && !e) {
              throw new P("view-createpositionat-offset-required", n);
            }
            return new Np(n, e);
          }
        }
        static _createAfter(t) {
          if (t.is("$textProxy")) {
            return new Np(t.textNode, t.offsetInText + t.data.length);
          }
          if (!t.parent) {
            throw new P("view-position-after-root", t, { root: t });
          }
          return new Np(t.parent, t.index + 1);
        }
        static _createBefore(t) {
          if (t.is("$textProxy")) {
            return new Np(t.textNode, t.offsetInText);
          }
          if (!t.parent) {
            throw new P("view-position-before-root", t, { root: t });
          }
          return new Np(t.parent, t.index);
        }
      }
      Np.prototype.is = function (t) {
        return t === "position" || t === "view:position";
      };
      class Vp extends xu {
        constructor(t, e = null) {
          super();
          this.start = t.clone();
          this.end = e ? e.clone() : t.clone();
        }
        *[Symbol.iterator]() {
          yield* new Mp({ boundaries: this, ignoreElementEnd: true });
        }
        get isCollapsed() {
          return this.start.isEqual(this.end);
        }
        get isFlat() {
          return this.start.parent === this.end.parent;
        }
        get root() {
          return this.start.root;
        }
        getEnlarged() {
          let t = this.start.getLastMatchingPosition(Lp, { direction: "backward" });
          let e = this.end.getLastMatchingPosition(Lp);
          if (t.parent.is("$text") && t.isAtStart) {
            t = Np._createBefore(t.parent);
          }
          if (e.parent.is("$text") && e.isAtEnd) {
            e = Np._createAfter(e.parent);
          }
          return new Vp(t, e);
        }
        getTrimmed() {
          let t = this.start.getLastMatchingPosition(Lp);
          if (t.isAfter(this.end) || t.isEqual(this.end)) {
            return new Vp(t, t);
          }
          let e = this.end.getLastMatchingPosition(Lp, { direction: "backward" });
          const n = t.nodeAfter;
          const o = e.nodeBefore;
          if (n && n.is("$text")) {
            t = new Np(n, 0);
          }
          if (o && o.is("$text")) {
            e = new Np(o, o.data.length);
          }
          return new Vp(t, e);
        }
        isEqual(t) {
          return this == t || (this.start.isEqual(t.start) && this.end.isEqual(t.end));
        }
        containsPosition(t) {
          return t.isAfter(this.start) && t.isBefore(this.end);
        }
        containsRange(t, e = false) {
          if (t.isCollapsed) {
            e = false;
          }
          const n = this.containsPosition(t.start) || (e && this.start.isEqual(t.start));
          const o = this.containsPosition(t.end) || (e && this.end.isEqual(t.end));
          return n && o;
        }
        getDifference(t) {
          const e = [];
          if (this.isIntersecting(t)) {
            if (this.containsPosition(t.start)) {
              e.push(new Vp(this.start, t.start));
            }
            if (this.containsPosition(t.end)) {
              e.push(new Vp(t.end, this.end));
            }
          } else {
            e.push(this.clone());
          }
          return e;
        }
        getIntersection(t) {
          if (this.isIntersecting(t)) {
            let e = this.start;
            let n = this.end;
            if (this.containsPosition(t.start)) {
              e = t.start;
            }
            if (this.containsPosition(t.end)) {
              n = t.end;
            }
            return new Vp(e, n);
          }
          return null;
        }
        getWalker(t = {}) {
          t.boundaries = this;
          return new Mp(t);
        }
        getCommonAncestor() {
          return this.start.getCommonAncestor(this.end);
        }
        getContainedElement() {
          if (this.isCollapsed) {
            return null;
          }
          let t = this.start.nodeAfter;
          let e = this.end.nodeBefore;
          if (
            this.start.parent.is("$text") &&
            this.start.isAtEnd &&
            this.start.parent.nextSibling
          ) {
            t = this.start.parent.nextSibling;
          }
          if (
            this.end.parent.is("$text") &&
            this.end.isAtStart &&
            this.end.parent.previousSibling
          ) {
            e = this.end.parent.previousSibling;
          }
          if (t && t.is("element") && t === e) {
            return t;
          }
          return null;
        }
        clone() {
          return new Vp(this.start, this.end);
        }
        *getItems(t = {}) {
          t.boundaries = this;
          t.ignoreElementEnd = true;
          const e = new Mp(t);
          for (const t of e) {
            yield t.item;
          }
        }
        *getPositions(t = {}) {
          t.boundaries = this;
          const e = new Mp(t);
          yield e.position;
          for (const t of e) {
            yield t.nextPosition;
          }
        }
        isIntersecting(t) {
          return this.start.isBefore(t.end) && this.end.isAfter(t.start);
        }
        static _createFromParentsAndOffsets(t, e, n, o) {
          return new this(new Np(t, e), new Np(n, o));
        }
        static _createFromPositionAndShift(t, e) {
          const n = t;
          const o = t.getShiftedBy(e);
          return e > 0 ? new this(n, o) : new this(o, n);
        }
        static _createIn(t) {
          return this._createFromParentsAndOffsets(t, 0, t, t.childCount);
        }
        static _createOn(t) {
          const e = t.is("$textProxy") ? t.offsetSize : 1;
          return this._createFromPositionAndShift(Np._createBefore(t), e);
        }
      }
      Vp.prototype.is = function (t) {
        return t === "range" || t === "view:range";
      };
      function Lp(t) {
        if (t.item.is("attributeElement") || t.item.is("uiElement")) {
          return true;
        }
        return false;
      }
      class Hp extends q(xu) {
        constructor(...t) {
          super();
          this._ranges = [];
          this._lastRangeBackward = false;
          this._isFake = false;
          this._fakeSelectionLabel = "";
          if (t.length) {
            this.setTo(...t);
          }
        }
        get isFake() {
          return this._isFake;
        }
        get fakeSelectionLabel() {
          return this._fakeSelectionLabel;
        }
        get anchor() {
          if (!this._ranges.length) {
            return null;
          }
          const t = this._ranges[this._ranges.length - 1];
          const e = this._lastRangeBackward ? t.end : t.start;
          return e.clone();
        }
        get focus() {
          if (!this._ranges.length) {
            return null;
          }
          const t = this._ranges[this._ranges.length - 1];
          const e = this._lastRangeBackward ? t.start : t.end;
          return e.clone();
        }
        get isCollapsed() {
          return this.rangeCount === 1 && this._ranges[0].isCollapsed;
        }
        get rangeCount() {
          return this._ranges.length;
        }
        get isBackward() {
          return !this.isCollapsed && this._lastRangeBackward;
        }
        get editableElement() {
          if (this.anchor) {
            return this.anchor.editableElement;
          }
          return null;
        }
        *getRanges() {
          for (const t of this._ranges) {
            yield t.clone();
          }
        }
        getFirstRange() {
          let t = null;
          for (const e of this._ranges) {
            if (!t || e.start.isBefore(t.start)) {
              t = e;
            }
          }
          return t ? t.clone() : null;
        }
        getLastRange() {
          let t = null;
          for (const e of this._ranges) {
            if (!t || e.end.isAfter(t.end)) {
              t = e;
            }
          }
          return t ? t.clone() : null;
        }
        getFirstPosition() {
          const t = this.getFirstRange();
          return t ? t.start.clone() : null;
        }
        getLastPosition() {
          const t = this.getLastRange();
          return t ? t.end.clone() : null;
        }
        isEqual(t) {
          if (this.isFake != t.isFake) {
            return false;
          }
          if (this.isFake && this.fakeSelectionLabel != t.fakeSelectionLabel) {
            return false;
          }
          if (this.rangeCount != t.rangeCount) {
            return false;
          } else if (this.rangeCount === 0) {
            return true;
          }
          if (!this.anchor.isEqual(t.anchor) || !this.focus.isEqual(t.focus)) {
            return false;
          }
          for (const e of this._ranges) {
            let n = false;
            for (const o of t._ranges) {
              if (e.isEqual(o)) {
                n = true;
                break;
              }
            }
            if (!n) {
              return false;
            }
          }
          return true;
        }
        isSimilar(t) {
          if (this.isBackward != t.isBackward) {
            return false;
          }
          const e = vt(this.getRanges());
          const n = vt(t.getRanges());
          if (e != n) {
            return false;
          }
          if (e == 0) {
            return true;
          }
          for (let e of this.getRanges()) {
            e = e.getTrimmed();
            let n = false;
            for (let o of t.getRanges()) {
              o = o.getTrimmed();
              if (e.start.isEqual(o.start) && e.end.isEqual(o.end)) {
                n = true;
                break;
              }
            }
            if (!n) {
              return false;
            }
          }
          return true;
        }
        getSelectedElement() {
          if (this.rangeCount !== 1) {
            return null;
          }
          return this.getFirstRange().getContainedElement();
        }
        setTo(...t) {
          let [e, n, o] = t;
          if (typeof n == "object") {
            o = n;
            n = undefined;
          }
          if (e === null) {
            this._setRanges([]);
            this._setFakeOptions(o);
          } else if (e instanceof Hp || e instanceof jp) {
            this._setRanges(e.getRanges(), e.isBackward);
            this._setFakeOptions({ fake: e.isFake, label: e.fakeSelectionLabel });
          } else if (e instanceof Vp) {
            this._setRanges([e], o && o.backward);
            this._setFakeOptions(o);
          } else if (e instanceof Np) {
            this._setRanges([new Vp(e)]);
            this._setFakeOptions(o);
          } else if (e instanceof Tu) {
            const t = !!o && !!o.backward;
            let i;
            if (n === undefined) {
              throw new P("view-selection-setto-required-second-parameter", this);
            } else if (n == "in") {
              i = Vp._createIn(e);
            } else if (n == "on") {
              i = Vp._createOn(e);
            } else {
              i = new Vp(Np._createAt(e, n));
            }
            this._setRanges([i], t);
            this._setFakeOptions(o);
          } else if (Ct(e)) {
            this._setRanges(e, o && o.backward);
            this._setFakeOptions(o);
          } else {
            throw new P("view-selection-setto-not-selectable", this);
          }
          this.fire("change");
        }
        setFocus(t, e) {
          if (this.anchor === null) {
            throw new P("view-selection-setfocus-no-ranges", this);
          }
          const n = Np._createAt(t, e);
          if (n.compareWith(this.focus) == "same") {
            return;
          }
          const o = this.anchor;
          this._ranges.pop();
          if (n.compareWith(o) == "before") {
            this._addRange(new Vp(n, o), true);
          } else {
            this._addRange(new Vp(o, n));
          }
          this.fire("change");
        }
        _setRanges(t, e = false) {
          t = Array.from(t);
          this._ranges = [];
          for (const e of t) {
            this._addRange(e);
          }
          this._lastRangeBackward = !!e;
        }
        _setFakeOptions(t = {}) {
          this._isFake = !!t.fake;
          this._fakeSelectionLabel = t.fake ? t.label || "" : "";
        }
        _addRange(t, e = false) {
          if (!(t instanceof Vp)) {
            throw new P("view-selection-add-range-not-range", this);
          }
          this._pushRange(t);
          this._lastRangeBackward = !!e;
        }
        _pushRange(t) {
          for (const e of this._ranges) {
            if (t.isIntersecting(e)) {
              throw new P("view-selection-range-intersects", this, {
                addedRange: t,
                intersectingRange: e,
              });
            }
          }
          this._ranges.push(new Vp(t.start, t.end));
        }
      }
      Hp.prototype.is = function (t) {
        return t === "selection" || t === "view:selection";
      };
      class jp extends q(xu) {
        constructor(...t) {
          super();
          this._selection = new Hp();
          this._selection.delegate("change").to(this);
          if (t.length) {
            this._selection.setTo(...t);
          }
        }
        get isFake() {
          return this._selection.isFake;
        }
        get fakeSelectionLabel() {
          return this._selection.fakeSelectionLabel;
        }
        get anchor() {
          return this._selection.anchor;
        }
        get focus() {
          return this._selection.focus;
        }
        get isCollapsed() {
          return this._selection.isCollapsed;
        }
        get rangeCount() {
          return this._selection.rangeCount;
        }
        get isBackward() {
          return this._selection.isBackward;
        }
        get editableElement() {
          return this._selection.editableElement;
        }
        get _ranges() {
          return this._selection._ranges;
        }
        *getRanges() {
          yield* this._selection.getRanges();
        }
        getFirstRange() {
          return this._selection.getFirstRange();
        }
        getLastRange() {
          return this._selection.getLastRange();
        }
        getFirstPosition() {
          return this._selection.getFirstPosition();
        }
        getLastPosition() {
          return this._selection.getLastPosition();
        }
        getSelectedElement() {
          return this._selection.getSelectedElement();
        }
        isEqual(t) {
          return this._selection.isEqual(t);
        }
        isSimilar(t) {
          return this._selection.isSimilar(t);
        }
        _setTo(...t) {
          this._selection.setTo(...t);
        }
        _setFocus(t, e) {
          this._selection.setFocus(t, e);
        }
      }
      jp.prototype.is = function (t) {
        return (
          t === "selection" ||
          t == "documentSelection" ||
          t == "view:selection" ||
          t == "view:documentSelection"
        );
      };
      class qp extends C {
        constructor(t, e, n) {
          super(t, e);
          this.startRange = n;
          this._eventPhase = "none";
          this._currentTarget = null;
        }
        get eventPhase() {
          return this._eventPhase;
        }
        get currentTarget() {
          return this._currentTarget;
        }
      }
      const $p = Symbol("bubbling contexts");
      function Wp(t) {
        class e extends t {
          fire(t, ...e) {
            try {
              const n = t instanceof C ? t : new C(this, t);
              const o = Zp(this);
              if (!o.size) {
                return;
              }
              Gp(n, "capturing", this);
              if (Kp(o, "$capture", n, ...e)) {
                return n.return;
              }
              const i = n.startRange || this.selection.getFirstRange();
              const r = i ? i.getContainedElement() : null;
              const s = r ? Boolean(Up(o, r)) : false;
              let a = r || Jp(i);
              Gp(n, "atTarget", a);
              if (!s) {
                if (Kp(o, "$text", n, ...e)) {
                  return n.return;
                }
                Gp(n, "bubbling", a);
              }
              while (a) {
                if (a.is("rootElement")) {
                  if (Kp(o, "$root", n, ...e)) {
                    return n.return;
                  }
                } else if (a.is("element")) {
                  if (Kp(o, a.name, n, ...e)) {
                    return n.return;
                  }
                }
                if (Kp(o, a, n, ...e)) {
                  return n.return;
                }
                a = a.parent;
                Gp(n, "bubbling", a);
              }
              Gp(n, "bubbling", this);
              Kp(o, "$document", n, ...e);
              return n.return;
            } catch (t) {
              P.rethrowUnexpectedError(t, this);
            }
          }
          _addEventListener(t, e, n) {
            const o = Xc(n.context || "$document");
            const i = Zp(this);
            for (const r of o) {
              let o = i.get(r);
              if (!o) {
                o = new (q())();
                i.set(r, o);
              }
              this.listenTo(o, t, e, n);
            }
          }
          _removeEventListener(t, e) {
            const n = Zp(this);
            for (const o of n.values()) {
              this.stopListening(o, t, e);
            }
          }
        }
        return e;
      }
      {
        const t = Wp(Object);
        ["fire", "_addEventListener", "_removeEventListener"].forEach((e) => {
          Wp[e] = t.prototype[e];
        });
      }
      function Gp(t, e, n) {
        if (t instanceof qp) {
          t._eventPhase = e;
          t._currentTarget = n;
        }
      }
      function Kp(t, e, n, ...o) {
        const i = typeof e == "string" ? t.get(e) : Up(t, e);
        if (!i) {
          return false;
        }
        i.fire(n, ...o);
        return n.stop.called;
      }
      function Up(t, e) {
        for (const [n, o] of t) {
          if (typeof n == "function" && n(e)) {
            return o;
          }
        }
        return null;
      }
      function Zp(t) {
        if (!t[$p]) {
          t[$p] = new Map();
        }
        return t[$p];
      }
      function Jp(t) {
        if (!t) {
          return null;
        }
        const e = t.start.parent;
        const n = t.end.parent;
        const o = e.getPath();
        const i = n.getPath();
        return o.length > i.length ? e : n;
      }
      class Yp extends Wp(lt()) {
        constructor(t) {
          super();
          this._postFixers = new Set();
          this.selection = new jp();
          this.roots = new ll({ idProperty: "rootName" });
          this.stylesProcessor = t;
          this.set("isReadOnly", false);
          this.set("isFocused", false);
          this.set("isSelecting", false);
          this.set("isComposing", false);
        }
        getRoot(t = "main") {
          return this.roots.get(t);
        }
        registerPostFixer(t) {
          this._postFixers.add(t);
        }
        destroy() {
          this.roots.map((t) => t.destroy());
          this.stopListening();
        }
        _callPostFixers(t) {
          let e = false;
          do {
            for (const n of this._postFixers) {
              e = n(t);
              if (e) {
                break;
              }
            }
          } while (e);
        }
      }
      const Qp = 10;
      class Xp extends Sp {
        constructor(t, e, n, o) {
          super(t, e, n, o);
          this._priority = Qp;
          this._id = null;
          this._clonesGroup = null;
          this.getFillerOffset = tg;
        }
        get priority() {
          return this._priority;
        }
        get id() {
          return this._id;
        }
        getElementsWithSameId() {
          if (this.id === null) {
            throw new P("attribute-element-get-elements-with-same-id-no-id", this);
          }
          return new Set(this._clonesGroup);
        }
        isSimilar(t) {
          if (this.id !== null || t.id !== null) {
            return this.id === t.id;
          }
          return super.isSimilar(t) && this.priority == t.priority;
        }
        _clone(t = false) {
          const e = super._clone(t);
          e._priority = this._priority;
          e._id = this._id;
          return e;
        }
      }
      Xp.DEFAULT_PRIORITY = Qp;
      Xp.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === "attributeElement" ||
            t === "view:attributeElement" ||
            t === "element" ||
            t === "view:element" ||
            t === "node" ||
            t === "view:node"
          );
        } else {
          return (
            e === this.name &&
            (t === "attributeElement" ||
              t === "view:attributeElement" ||
              t === "element" ||
              t === "view:element")
          );
        }
      };
      function tg() {
        if (eg(this)) {
          return null;
        }
        let t = this.parent;
        while (t && t.is("attributeElement")) {
          if (eg(t) > 1) {
            return null;
          }
          t = t.parent;
        }
        if (!t || eg(t) > 1) {
          return null;
        }
        return this.childCount;
      }
      function eg(t) {
        return Array.from(t.getChildren()).filter((t) => !t.is("uiElement")).length;
      }
      class ng extends Sp {
        constructor(t, e, n, o) {
          super(t, e, n, o);
          this.getFillerOffset = og;
        }
        _insertChild(t, e) {
          if (e && (e instanceof Tu || Array.from(e).length > 0)) {
            throw new P("view-emptyelement-cannot-add", [this, e]);
          }
          return 0;
        }
      }
      ng.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === "emptyElement" ||
            t === "view:emptyElement" ||
            t === "element" ||
            t === "view:element" ||
            t === "node" ||
            t === "view:node"
          );
        } else {
          return (
            e === this.name &&
            (t === "emptyElement" ||
              t === "view:emptyElement" ||
              t === "element" ||
              t === "view:element")
          );
        }
      };
      function og() {
        return null;
      }
      class ig extends Sp {
        constructor(t, e, n, o) {
          super(t, e, n, o);
          this.getFillerOffset = sg;
        }
        _insertChild(t, e) {
          if (e && (e instanceof Tu || Array.from(e).length > 0)) {
            throw new P("view-uielement-cannot-add", [this, e]);
          }
          return 0;
        }
        render(t, e) {
          return this.toDomElement(t);
        }
        toDomElement(t) {
          const e = t.createElement(this.name);
          for (const t of this.getAttributeKeys()) {
            e.setAttribute(t, this.getAttribute(t));
          }
          return e;
        }
      }
      ig.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === "uiElement" ||
            t === "view:uiElement" ||
            t === "element" ||
            t === "view:element" ||
            t === "node" ||
            t === "view:node"
          );
        } else {
          return (
            e === this.name &&
            (t === "uiElement" || t === "view:uiElement" || t === "element" || t === "view:element")
          );
        }
      };
      function rg(t) {
        t.document.on("arrowKey", (e, n) => ag(e, n, t.domConverter), { priority: "low" });
      }
      function sg() {
        return null;
      }
      function ag(t, e, n) {
        if (e.keyCode == jc.arrowright) {
          const t = e.domTarget.ownerDocument.defaultView.getSelection();
          const o = t.rangeCount == 1 && t.getRangeAt(0).collapsed;
          if (o || e.shiftKey) {
            const e = t.focusNode;
            const i = t.focusOffset;
            const r = n.domPositionToView(e, i);
            if (r === null) {
              return;
            }
            let s = false;
            const a = r.getLastMatchingPosition((t) => {
              if (t.item.is("uiElement")) {
                s = true;
              }
              if (t.item.is("uiElement") || t.item.is("attributeElement")) {
                return true;
              }
              return false;
            });
            if (s) {
              const e = n.viewPositionToDom(a);
              if (o) {
                t.collapse(e.parent, e.offset);
              } else {
                t.extend(e.parent, e.offset);
              }
            }
          }
        }
      }
      class cg extends Sp {
        constructor(t, e, n, o) {
          super(t, e, n, o);
          this.getFillerOffset = lg;
        }
        _insertChild(t, e) {
          if (e && (e instanceof Tu || Array.from(e).length > 0)) {
            throw new P("view-rawelement-cannot-add", [this, e]);
          }
          return 0;
        }
        render(t, e) {}
      }
      cg.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === "rawElement" ||
            t === "view:rawElement" ||
            t === this.name ||
            t === "view:" + this.name ||
            t === "element" ||
            t === "view:element" ||
            t === "node" ||
            t === "view:node"
          );
        } else {
          return (
            e === this.name &&
            (t === "rawElement" ||
              t === "view:rawElement" ||
              t === "element" ||
              t === "view:element")
          );
        }
      };
      function lg() {
        return null;
      }
      class dg extends q(xu) {
        constructor(t, e) {
          super();
          this._children = [];
          this._customProperties = new Map();
          this.document = t;
          if (e) {
            this._insertChild(0, e);
          }
        }
        [Symbol.iterator]() {
          return this._children[Symbol.iterator]();
        }
        get childCount() {
          return this._children.length;
        }
        get isEmpty() {
          return this.childCount === 0;
        }
        get root() {
          return this;
        }
        get parent() {
          return null;
        }
        get name() {
          return undefined;
        }
        getCustomProperty(t) {
          return this._customProperties.get(t);
        }
        *getCustomProperties() {
          yield* this._customProperties.entries();
        }
        _appendChild(t) {
          return this._insertChild(this.childCount, t);
        }
        getChild(t) {
          return this._children[t];
        }
        getChildIndex(t) {
          return this._children.indexOf(t);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        _insertChild(t, e) {
          this._fireChange("children", this);
          let n = 0;
          const o = hg(this.document, e);
          for (const e of o) {
            if (e.parent !== null) {
              e._remove();
            }
            e.parent = this;
            this._children.splice(t, 0, e);
            t++;
            n++;
          }
          return n;
        }
        _removeChildren(t, e = 1) {
          this._fireChange("children", this);
          for (let n = t; n < t + e; n++) {
            this._children[n].parent = null;
          }
          return this._children.splice(t, e);
        }
        _fireChange(t, e) {
          this.fire("change:" + t, e);
        }
        _setCustomProperty(t, e) {
          this._customProperties.set(t, e);
        }
        _removeCustomProperty(t) {
          return this._customProperties.delete(t);
        }
      }
      dg.prototype.is = function (t) {
        return t === "documentFragment" || t === "view:documentFragment";
      };
      function hg(t, e) {
        if (typeof e == "string") {
          return [new Pu(t, e)];
        }
        if (!Ct(e)) {
          e = [e];
        }
        return Array.from(e).map((e) => {
          if (typeof e == "string") {
            return new Pu(t, e);
          }
          if (e instanceof Bu) {
            return new Pu(t, e.data);
          }
          return e;
        });
      }
      class ug {
        constructor(t) {
          this._cloneGroups = new Map();
          this._slotFactory = null;
          this.document = t;
        }
        setSelection(...t) {
          this.document.selection._setTo(...t);
        }
        setSelectionFocus(t, e) {
          this.document.selection._setFocus(t, e);
        }
        createDocumentFragment(t) {
          return new dg(this.document, t);
        }
        createText(t) {
          return new Pu(this.document, t);
        }
        createAttributeElement(t, e, n = {}) {
          const o = new Xp(this.document, t, e);
          if (typeof n.priority === "number") {
            o._priority = n.priority;
          }
          if (n.id) {
            o._id = n.id;
          }
          if (n.renderUnsafeAttributes) {
            o._unsafeAttributesToRender.push(...n.renderUnsafeAttributes);
          }
          return o;
        }
        createContainerElement(t, e, n = {}, o = {}) {
          let i = null;
          if (he(n)) {
            o = n;
          } else {
            i = n;
          }
          const r = new Op(this.document, t, e, i);
          if (o.renderUnsafeAttributes) {
            r._unsafeAttributesToRender.push(...o.renderUnsafeAttributes);
          }
          return r;
        }
        createEditableElement(t, e, n = {}) {
          const o = new Ip(this.document, t, e);
          if (n.renderUnsafeAttributes) {
            o._unsafeAttributesToRender.push(...n.renderUnsafeAttributes);
          }
          return o;
        }
        createEmptyElement(t, e, n = {}) {
          const o = new ng(this.document, t, e);
          if (n.renderUnsafeAttributes) {
            o._unsafeAttributesToRender.push(...n.renderUnsafeAttributes);
          }
          return o;
        }
        createUIElement(t, e, n) {
          const o = new ig(this.document, t, e);
          if (n) {
            o.render = n;
          }
          return o;
        }
        createRawElement(t, e, n, o = {}) {
          const i = new cg(this.document, t, e);
          if (n) {
            i.render = n;
          }
          if (o.renderUnsafeAttributes) {
            i._unsafeAttributesToRender.push(...o.renderUnsafeAttributes);
          }
          return i;
        }
        setAttribute(t, e, n) {
          n._setAttribute(t, e);
        }
        removeAttribute(t, e) {
          e._removeAttribute(t);
        }
        addClass(t, e) {
          e._addClass(t);
        }
        removeClass(t, e) {
          e._removeClass(t);
        }
        setStyle(t, e, n) {
          if (he(t) && n === undefined) {
            e._setStyle(t);
          } else {
            n._setStyle(t, e);
          }
        }
        removeStyle(t, e) {
          e._removeStyle(t);
        }
        setCustomProperty(t, e, n) {
          n._setCustomProperty(t, e);
        }
        removeCustomProperty(t, e) {
          return e._removeCustomProperty(t);
        }
        breakAttributes(t) {
          if (t instanceof Np) {
            return this._breakAttributes(t);
          } else {
            return this._breakAttributesRange(t);
          }
        }
        breakContainer(t) {
          const e = t.parent;
          if (!e.is("containerElement")) {
            throw new P("view-writer-break-non-container-element", this.document);
          }
          if (!e.parent) {
            throw new P("view-writer-break-root", this.document);
          }
          if (t.isAtStart) {
            return Np._createBefore(e);
          } else if (!t.isAtEnd) {
            const n = e._clone(false);
            this.insert(Np._createAfter(e), n);
            const o = new Vp(t, Np._createAt(e, "end"));
            const i = new Np(n, 0);
            this.move(o, i);
          }
          return Np._createAfter(e);
        }
        mergeAttributes(t) {
          const e = t.offset;
          const n = t.parent;
          if (n.is("$text")) {
            return t;
          }
          if (n.is("attributeElement") && n.childCount === 0) {
            const t = n.parent;
            const e = n.index;
            n._remove();
            this._removeFromClonedElementsGroup(n);
            return this.mergeAttributes(new Np(t, e));
          }
          const o = n.getChild(e - 1);
          const i = n.getChild(e);
          if (!o || !i) {
            return t;
          }
          if (o.is("$text") && i.is("$text")) {
            return bg(o, i);
          } else if (o.is("attributeElement") && i.is("attributeElement") && o.isSimilar(i)) {
            const t = o.childCount;
            o._appendChild(i.getChildren());
            i._remove();
            this._removeFromClonedElementsGroup(i);
            return this.mergeAttributes(new Np(o, t));
          }
          return t;
        }
        mergeContainers(t) {
          const e = t.nodeBefore;
          const n = t.nodeAfter;
          if (!e || !n || !e.is("containerElement") || !n.is("containerElement")) {
            throw new P("view-writer-merge-containers-invalid-position", this.document);
          }
          const o = e.getChild(e.childCount - 1);
          const i = o instanceof Pu ? Np._createAt(o, "end") : Np._createAt(e, "end");
          this.move(Vp._createIn(n), Np._createAt(e, "end"));
          this.remove(Vp._createOn(n));
          return i;
        }
        insert(t, e) {
          e = Ct(e) ? [...e] : [e];
          _g(e, this.document);
          const n = e.reduce((t, e) => {
            const n = t[t.length - 1];
            const o = !e.is("uiElement");
            if (!n || n.breakAttributes != o) {
              t.push({ breakAttributes: o, nodes: [e] });
            } else {
              n.nodes.push(e);
            }
            return t;
          }, []);
          let o = null;
          let i = t;
          for (const { nodes: t, breakAttributes: e } of n) {
            const n = this._insertNodes(i, t, e);
            if (!o) {
              o = n.start;
            }
            i = n.end;
          }
          if (!o) {
            return new Vp(t);
          }
          return new Vp(o, i);
        }
        remove(t) {
          const e = t instanceof Vp ? t : Vp._createOn(t);
          Ag(e, this.document);
          if (e.isCollapsed) {
            return new dg(this.document);
          }
          const { start: n, end: o } = this._breakAttributesRange(e, true);
          const i = n.parent;
          const r = o.offset - n.offset;
          const s = i._removeChildren(n.offset, r);
          for (const t of s) {
            this._removeFromClonedElementsGroup(t);
          }
          const a = this.mergeAttributes(n);
          e.start = a;
          e.end = a.clone();
          return new dg(this.document, s);
        }
        clear(t, e) {
          Ag(t, this.document);
          const n = t.getWalker({ direction: "backward", ignoreElementEnd: true });
          for (const o of n) {
            const n = o.item;
            let i;
            if (n.is("element") && e.isSimilar(n)) {
              i = Vp._createOn(n);
            } else if (!o.nextPosition.isAfter(t.start) && n.is("$textProxy")) {
              const t = n.getAncestors().find((t) => t.is("element") && e.isSimilar(t));
              if (t) {
                i = Vp._createIn(t);
              }
            }
            if (i) {
              if (i.end.isAfter(t.end)) {
                i.end = t.end;
              }
              if (i.start.isBefore(t.start)) {
                i.start = t.start;
              }
              this.remove(i);
            }
          }
        }
        move(t, e) {
          let n;
          if (e.isAfter(t.end)) {
            e = this._breakAttributes(e, true);
            const o = e.parent;
            const i = o.childCount;
            t = this._breakAttributesRange(t, true);
            n = this.remove(t);
            e.offset += o.childCount - i;
          } else {
            n = this.remove(t);
          }
          return this.insert(e, n);
        }
        wrap(t, e) {
          if (!(e instanceof Xp)) {
            throw new P("view-writer-wrap-invalid-attribute", this.document);
          }
          Ag(t, this.document);
          if (!t.isCollapsed) {
            return this._wrapRange(t, e);
          } else {
            let n = t.start;
            if (n.parent.is("element") && !fg(n.parent)) {
              n = n.getLastMatchingPosition((t) => t.item.is("uiElement"));
            }
            n = this._wrapPosition(n, e);
            const o = this.document.selection;
            if (o.isCollapsed && o.getFirstPosition().isEqual(t.start)) {
              this.setSelection(n);
            }
            return new Vp(n);
          }
        }
        unwrap(t, e) {
          if (!(e instanceof Xp)) {
            throw new P("view-writer-unwrap-invalid-attribute", this.document);
          }
          Ag(t, this.document);
          if (t.isCollapsed) {
            return t;
          }
          const { start: n, end: o } = this._breakAttributesRange(t, true);
          const i = n.parent;
          const r = this._unwrapChildren(i, n.offset, o.offset, e);
          const s = this.mergeAttributes(r.start);
          if (!s.isEqual(r.start)) {
            r.end.offset--;
          }
          const a = this.mergeAttributes(r.end);
          return new Vp(s, a);
        }
        rename(t, e) {
          const n = new Op(this.document, t, e.getAttributes());
          this.insert(Np._createAfter(e), n);
          this.move(Vp._createIn(e), Np._createAt(n, 0));
          this.remove(Vp._createOn(e));
          return n;
        }
        clearClonedElementsGroup(t) {
          this._cloneGroups.delete(t);
        }
        createPositionAt(t, e) {
          return Np._createAt(t, e);
        }
        createPositionAfter(t) {
          return Np._createAfter(t);
        }
        createPositionBefore(t) {
          return Np._createBefore(t);
        }
        createRange(t, e) {
          return new Vp(t, e);
        }
        createRangeOn(t) {
          return Vp._createOn(t);
        }
        createRangeIn(t) {
          return Vp._createIn(t);
        }
        createSelection(...t) {
          return new Hp(...t);
        }
        createSlot(t = "children") {
          if (!this._slotFactory) {
            throw new P("view-writer-invalid-create-slot-context", this.document);
          }
          return this._slotFactory(this, t);
        }
        _registerSlotFactory(t) {
          this._slotFactory = t;
        }
        _clearSlotFactory() {
          this._slotFactory = null;
        }
        _insertNodes(t, e, n) {
          let o;
          if (n) {
            o = pg(t);
          } else {
            o = t.parent.is("$text") ? t.parent.parent : t.parent;
          }
          if (!o) {
            throw new P("view-writer-invalid-position-container", this.document);
          }
          let i;
          if (n) {
            i = this._breakAttributes(t, true);
          } else {
            i = t.parent.is("$text") ? kg(t) : t;
          }
          const r = o._insertChild(i.offset, e);
          for (const t of e) {
            this._addToClonedElementsGroup(t);
          }
          const s = i.getShiftedBy(r);
          const a = this.mergeAttributes(i);
          if (!a.isEqual(i)) {
            s.offset--;
          }
          const c = this.mergeAttributes(s);
          return new Vp(a, c);
        }
        _wrapChildren(t, e, n, o) {
          let i = e;
          const r = [];
          while (i < n) {
            const e = t.getChild(i);
            const n = e.is("$text");
            const s = e.is("attributeElement");
            if (s && this._wrapAttributeElement(o, e)) {
              r.push(new Np(t, i));
            } else if (n || !s || gg(o, e)) {
              const n = o._clone();
              e._remove();
              n._appendChild(e);
              t._insertChild(i, n);
              this._addToClonedElementsGroup(n);
              r.push(new Np(t, i));
            } else {
              this._wrapChildren(e, 0, e.childCount, o);
            }
            i++;
          }
          let s = 0;
          for (const t of r) {
            t.offset -= s;
            if (t.offset == e) {
              continue;
            }
            const o = this.mergeAttributes(t);
            if (!o.isEqual(t)) {
              s++;
              n--;
            }
          }
          return Vp._createFromParentsAndOffsets(t, e, t, n);
        }
        _unwrapChildren(t, e, n, o) {
          let i = e;
          const r = [];
          while (i < n) {
            const e = t.getChild(i);
            if (!e.is("attributeElement")) {
              i++;
              continue;
            }
            if (e.isSimilar(o)) {
              const o = e.getChildren();
              const s = e.childCount;
              e._remove();
              t._insertChild(i, o);
              this._removeFromClonedElementsGroup(e);
              r.push(new Np(t, i), new Np(t, i + s));
              i += s;
              n += s - 1;
              continue;
            }
            if (this._unwrapAttributeElement(o, e)) {
              r.push(new Np(t, i), new Np(t, i + 1));
              i++;
              continue;
            }
            this._unwrapChildren(e, 0, e.childCount, o);
            i++;
          }
          let s = 0;
          for (const t of r) {
            t.offset -= s;
            if (t.offset == e || t.offset == n) {
              continue;
            }
            const o = this.mergeAttributes(t);
            if (!o.isEqual(t)) {
              s++;
              n--;
            }
          }
          return Vp._createFromParentsAndOffsets(t, e, t, n);
        }
        _wrapRange(t, e) {
          const { start: n, end: o } = this._breakAttributesRange(t, true);
          const i = n.parent;
          const r = this._wrapChildren(i, n.offset, o.offset, e);
          const s = this.mergeAttributes(r.start);
          if (!s.isEqual(r.start)) {
            r.end.offset--;
          }
          const a = this.mergeAttributes(r.end);
          return new Vp(s, a);
        }
        _wrapPosition(t, e) {
          if (e.isSimilar(t.parent)) {
            return mg(t.clone());
          }
          if (t.parent.is("$text")) {
            t = kg(t);
          }
          const n = this.createAttributeElement("_wrapPosition-fake-element");
          n._priority = Number.POSITIVE_INFINITY;
          n.isSimilar = () => false;
          t.parent._insertChild(t.offset, n);
          const o = new Vp(t, t.getShiftedBy(1));
          this.wrap(o, e);
          const i = new Np(n.parent, n.index);
          n._remove();
          const r = i.nodeBefore;
          const s = i.nodeAfter;
          if (r instanceof Pu && s instanceof Pu) {
            return bg(r, s);
          }
          return mg(i);
        }
        _wrapAttributeElement(t, e) {
          if (!Cg(t, e)) {
            return false;
          }
          if (t.name !== e.name || t.priority !== e.priority) {
            return false;
          }
          for (const n of t.getAttributeKeys()) {
            if (n === "class" || n === "style") {
              continue;
            }
            if (e.hasAttribute(n) && e.getAttribute(n) !== t.getAttribute(n)) {
              return false;
            }
          }
          for (const n of t.getStyleNames()) {
            if (e.hasStyle(n) && e.getStyle(n) !== t.getStyle(n)) {
              return false;
            }
          }
          for (const n of t.getAttributeKeys()) {
            if (n === "class" || n === "style") {
              continue;
            }
            if (!e.hasAttribute(n)) {
              this.setAttribute(n, t.getAttribute(n), e);
            }
          }
          for (const n of t.getStyleNames()) {
            if (!e.hasStyle(n)) {
              this.setStyle(n, t.getStyle(n), e);
            }
          }
          for (const n of t.getClassNames()) {
            if (!e.hasClass(n)) {
              this.addClass(n, e);
            }
          }
          return true;
        }
        _unwrapAttributeElement(t, e) {
          if (!Cg(t, e)) {
            return false;
          }
          if (t.name !== e.name || t.priority !== e.priority) {
            return false;
          }
          for (const n of t.getAttributeKeys()) {
            if (n === "class" || n === "style") {
              continue;
            }
            if (!e.hasAttribute(n) || e.getAttribute(n) !== t.getAttribute(n)) {
              return false;
            }
          }
          if (!e.hasClass(...t.getClassNames())) {
            return false;
          }
          for (const n of t.getStyleNames()) {
            if (!e.hasStyle(n) || e.getStyle(n) !== t.getStyle(n)) {
              return false;
            }
          }
          for (const n of t.getAttributeKeys()) {
            if (n === "class" || n === "style") {
              continue;
            }
            this.removeAttribute(n, e);
          }
          this.removeClass(Array.from(t.getClassNames()), e);
          this.removeStyle(Array.from(t.getStyleNames()), e);
          return true;
        }
        _breakAttributesRange(t, e = false) {
          const n = t.start;
          const o = t.end;
          Ag(t, this.document);
          if (t.isCollapsed) {
            const n = this._breakAttributes(t.start, e);
            return new Vp(n, n);
          }
          const i = this._breakAttributes(o, e);
          const r = i.parent.childCount;
          const s = this._breakAttributes(n, e);
          i.offset += i.parent.childCount - r;
          return new Vp(s, i);
        }
        _breakAttributes(t, e = false) {
          const n = t.offset;
          const o = t.parent;
          if (t.parent.is("emptyElement")) {
            throw new P("view-writer-cannot-break-empty-element", this.document);
          }
          if (t.parent.is("uiElement")) {
            throw new P("view-writer-cannot-break-ui-element", this.document);
          }
          if (t.parent.is("rawElement")) {
            throw new P("view-writer-cannot-break-raw-element", this.document);
          }
          if (!e && o.is("$text") && vg(o.parent)) {
            return t.clone();
          }
          if (vg(o)) {
            return t.clone();
          }
          if (o.is("$text")) {
            return this._breakAttributes(kg(t), e);
          }
          const i = o.childCount;
          if (n == i) {
            const t = new Np(o.parent, o.index + 1);
            return this._breakAttributes(t, e);
          } else {
            if (n === 0) {
              const t = new Np(o.parent, o.index);
              return this._breakAttributes(t, e);
            } else {
              const t = o.index + 1;
              const i = o._clone();
              o.parent._insertChild(t, i);
              this._addToClonedElementsGroup(i);
              const r = o.childCount - n;
              const s = o._removeChildren(n, r);
              i._appendChild(s);
              const a = new Np(o.parent, t);
              return this._breakAttributes(a, e);
            }
          }
        }
        _addToClonedElementsGroup(t) {
          if (!t.root.is("rootElement")) {
            return;
          }
          if (t.is("element")) {
            for (const e of t.getChildren()) {
              this._addToClonedElementsGroup(e);
            }
          }
          const e = t.id;
          if (!e) {
            return;
          }
          let n = this._cloneGroups.get(e);
          if (!n) {
            n = new Set();
            this._cloneGroups.set(e, n);
          }
          n.add(t);
          t._clonesGroup = n;
        }
        _removeFromClonedElementsGroup(t) {
          if (t.is("element")) {
            for (const e of t.getChildren()) {
              this._removeFromClonedElementsGroup(e);
            }
          }
          const e = t.id;
          if (!e) {
            return;
          }
          const n = this._cloneGroups.get(e);
          if (!n) {
            return;
          }
          n.delete(t);
        }
      }
      function fg(t) {
        return Array.from(t.getChildren()).some((t) => !t.is("uiElement"));
      }
      function pg(t) {
        let e = t.parent;
        while (!vg(e)) {
          if (!e) {
            return undefined;
          }
          e = e.parent;
        }
        return e;
      }
      function gg(t, e) {
        if (t.priority < e.priority) {
          return true;
        } else if (t.priority > e.priority) {
          return false;
        }
        return t.getIdentity() < e.getIdentity();
      }
      function mg(t) {
        const e = t.nodeBefore;
        if (e && e.is("$text")) {
          return new Np(e, e.data.length);
        }
        const n = t.nodeAfter;
        if (n && n.is("$text")) {
          return new Np(n, 0);
        }
        return t;
      }
      function kg(t) {
        if (t.offset == t.parent.data.length) {
          return new Np(t.parent.parent, t.parent.index + 1);
        }
        if (t.offset === 0) {
          return new Np(t.parent.parent, t.parent.index);
        }
        const e = t.parent.data.slice(t.offset);
        t.parent._data = t.parent.data.slice(0, t.offset);
        t.parent.parent._insertChild(t.parent.index + 1, new Pu(t.root.document, e));
        return new Np(t.parent.parent, t.parent.index + 1);
      }
      function bg(t, e) {
        const n = t.data.length;
        t._data += e.data;
        e._remove();
        return new Np(t, n);
      }
      const wg = [Pu, Xp, Op, ng, cg, ig];
      function _g(t, e) {
        for (const n of t) {
          if (!wg.some((t) => n instanceof t)) {
            throw new P("view-writer-insert-invalid-node-type", e);
          }
          if (!n.is("$text")) {
            _g(n.getChildren(), e);
          }
        }
      }
      function vg(t) {
        return t && (t.is("containerElement") || t.is("documentFragment"));
      }
      function Ag(t, e) {
        const n = pg(t.start);
        const o = pg(t.end);
        if (!n || !o || n !== o) {
          throw new P("view-writer-invalid-range-container", e);
        }
      }
      function Cg(t, e) {
        return t.id === null && e.id === null;
      }
      const yg = (t) => t.createTextNode(" ");
      const xg = (t) => {
        const e = t.createElement("span");
        e.dataset.ckeFiller = "true";
        e.innerText = " ";
        return e;
      };
      const Eg = (t) => {
        const e = t.createElement("br");
        e.dataset.ckeFiller = "true";
        return e;
      };
      const Dg = 7;
      const Sg = "⁠".repeat(Dg);
      function Tg(t) {
        if (typeof t == "string") {
          return t.substr(0, Dg) === Sg;
        }
        return nc(t) && t.data.substr(0, Dg) === Sg;
      }
      function Pg(t) {
        return t.data.length == Dg && Tg(t);
      }
      function Bg(t) {
        const e = typeof t == "string" ? t : t.data;
        if (Tg(t)) {
          return e.slice(Dg);
        }
        return e;
      }
      function Og(t) {
        t.document.on("arrowKey", Rg, { priority: "low" });
      }
      function Rg(t, e) {
        if (e.keyCode == jc.arrowleft) {
          const t = e.domTarget.ownerDocument.defaultView.getSelection();
          if (t.rangeCount == 1 && t.getRangeAt(0).collapsed) {
            const e = t.getRangeAt(0).startContainer;
            const n = t.getRangeAt(0).startOffset;
            if (Tg(e) && n <= Dg) {
              t.collapse(e, 0);
            }
          }
        }
      }
      var Ig = n(37);
      var zg = { injectType: "singletonStyleTag", attributes: { "data-cke": true } };
      zg.insert = "head";
      zg.singleton = true;
      var Fg = Pl()(Ig.Z, zg);
      const Mg = Ig.Z.locals || {};
      class Ng extends lt() {
        constructor(t, e) {
          super();
          this.domDocuments = new Set();
          this.markedAttributes = new Set();
          this.markedChildren = new Set();
          this.markedTexts = new Set();
          this._inlineFiller = null;
          this._fakeSelectionContainer = null;
          this.domConverter = t;
          this.selection = e;
          this.set("isFocused", false);
          this.set("isSelecting", false);
          if (r.isBlink && !r.isAndroid) {
            this.on("change:isSelecting", () => {
              if (!this.isSelecting) {
                this.render();
              }
            });
          }
          this.set("isComposing", false);
          this.on("change:isComposing", () => {
            if (!this.isComposing) {
              this.render();
            }
          });
        }
        markToSync(t, e) {
          if (t === "text") {
            if (this.domConverter.mapViewToDom(e.parent)) {
              this.markedTexts.add(e);
            }
          } else {
            if (!this.domConverter.mapViewToDom(e)) {
              return;
            }
            if (t === "attributes") {
              this.markedAttributes.add(e);
            } else if (t === "children") {
              this.markedChildren.add(e);
            } else {
              const e = t;
              throw new P("view-renderer-unknown-type", this);
            }
          }
        }
        render() {
          if (this.isComposing && !r.isAndroid) {
            return;
          }
          let t = null;
          const e = r.isBlink && !r.isAndroid ? !this.isSelecting : true;
          for (const t of this.markedChildren) {
            this._updateChildrenMappings(t);
          }
          if (e) {
            if (this._inlineFiller && !this._isSelectionInInlineFiller()) {
              this._removeInlineFiller();
            }
            if (this._inlineFiller) {
              t = this._getInlineFillerPosition();
            } else if (this._needsInlineFillerAtSelection()) {
              t = this.selection.getFirstPosition();
              this.markedChildren.add(t.parent);
            }
          } else if (this._inlineFiller && this._inlineFiller.parentNode) {
            t = this.domConverter.domPositionToView(this._inlineFiller);
            if (t && t.parent.is("$text")) {
              t = Np._createBefore(t.parent);
            }
          }
          for (const t of this.markedAttributes) {
            this._updateAttrs(t);
          }
          for (const e of this.markedChildren) {
            this._updateChildren(e, { inlineFillerPosition: t });
          }
          for (const e of this.markedTexts) {
            if (!this.markedChildren.has(e.parent) && this.domConverter.mapViewToDom(e.parent)) {
              this._updateText(e, { inlineFillerPosition: t });
            }
          }
          if (e) {
            if (t) {
              const e = this.domConverter.viewPositionToDom(t);
              const n = e.parent.ownerDocument;
              if (!Tg(e.parent)) {
                this._inlineFiller = Lg(n, e.parent, e.offset);
              } else {
                this._inlineFiller = e.parent;
              }
            } else {
              this._inlineFiller = null;
            }
          }
          this._updateFocus();
          this._updateSelection();
          this.markedTexts.clear();
          this.markedAttributes.clear();
          this.markedChildren.clear();
        }
        _updateChildrenMappings(t) {
          const e = this.domConverter.mapViewToDom(t);
          if (!e) {
            return;
          }
          const n = Array.from(e.childNodes);
          const o = Array.from(this.domConverter.viewChildrenToDom(t, { withChildren: false }));
          const i = this._diffNodeLists(n, o);
          const r = this._findUpdateActions(i, n, o, Hg);
          if (r.indexOf("update") !== -1) {
            const e = { equal: 0, insert: 0, delete: 0 };
            for (const i of r) {
              if (i === "update") {
                const i = e.equal + e.insert;
                const r = e.equal + e.delete;
                const s = t.getChild(i);
                if (s && !(s.is("uiElement") || s.is("rawElement"))) {
                  this._updateElementMappings(s, n[r]);
                }
                Dc(o[i]);
                e.equal++;
              } else {
                e[i]++;
              }
            }
          }
        }
        _updateElementMappings(t, e) {
          this.domConverter.unbindDomElement(e);
          this.domConverter.bindElements(e, t);
          this.markedChildren.add(t);
          this.markedAttributes.add(t);
        }
        _getInlineFillerPosition() {
          const t = this.selection.getFirstPosition();
          if (t.parent.is("$text")) {
            return Np._createBefore(t.parent);
          } else {
            return t;
          }
        }
        _isSelectionInInlineFiller() {
          if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {
            return false;
          }
          const t = this.selection.getFirstPosition();
          const e = this.domConverter.viewPositionToDom(t);
          if (e && nc(e.parent) && Tg(e.parent)) {
            return true;
          }
          return false;
        }
        _removeInlineFiller() {
          const t = this._inlineFiller;
          if (!Tg(t)) {
            throw new P("view-renderer-filler-was-lost", this);
          }
          if (Pg(t)) {
            t.remove();
          } else {
            t.data = t.data.substr(Dg);
          }
          this._inlineFiller = null;
        }
        _needsInlineFillerAtSelection() {
          if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {
            return false;
          }
          const t = this.selection.getFirstPosition();
          const e = t.parent;
          const n = t.offset;
          if (!this.domConverter.mapViewToDom(e.root)) {
            return false;
          }
          if (!e.is("element")) {
            return false;
          }
          if (!Vg(e)) {
            return false;
          }
          if (n === e.getFillerOffset()) {
            return false;
          }
          const o = t.nodeBefore;
          const i = t.nodeAfter;
          if (o instanceof Pu || i instanceof Pu) {
            return false;
          }
          if (r.isAndroid && (o || i)) {
            return false;
          }
          return true;
        }
        _updateText(t, e) {
          const n = this.domConverter.findCorrespondingDomText(t);
          const o = this.domConverter.viewToDom(t);
          let i = o.data;
          const r = e.inlineFillerPosition;
          if (r && r.parent == t.parent && r.offset == t.index) {
            i = Sg + i;
          }
          Kg(n, i);
        }
        _updateAttrs(t) {
          const e = this.domConverter.mapViewToDom(t);
          if (!e) {
            return;
          }
          const n = Array.from(e.attributes).map((t) => t.name);
          const o = t.getAttributeKeys();
          for (const n of o) {
            this.domConverter.setDomElementAttribute(e, n, t.getAttribute(n), t);
          }
          for (const o of n) {
            if (!t.hasAttribute(o)) {
              this.domConverter.removeDomElementAttribute(e, o);
            }
          }
        }
        _updateChildren(t, e) {
          const n = this.domConverter.mapViewToDom(t);
          if (!n) {
            return;
          }
          if (r.isAndroid) {
            let t = null;
            for (const e of Array.from(n.childNodes)) {
              if (t && nc(t) && nc(e)) {
                n.normalize();
                break;
              }
              t = e;
            }
          }
          const o = e.inlineFillerPosition;
          const i = n.childNodes;
          const s = Array.from(this.domConverter.viewChildrenToDom(t, { bind: true }));
          if (o && o.parent === t) {
            Lg(n.ownerDocument, s, o.offset);
          }
          const a = this._diffNodeLists(i, s);
          const c = this._findUpdateActions(a, i, s, jg);
          let l = 0;
          const d = new Set();
          for (const t of c) {
            if (t === "delete") {
              d.add(i[l]);
              Dc(i[l]);
            } else if (t === "equal" || t === "update") {
              l++;
            }
          }
          l = 0;
          for (const t of c) {
            if (t === "insert") {
              bc(n, l, s[l]);
              l++;
            } else if (t === "update") {
              Kg(i[l], s[l].data);
              l++;
            } else if (t === "equal") {
              this._markDescendantTextToSync(this.domConverter.domToView(s[l]));
              l++;
            }
          }
          for (const t of d) {
            if (!t.parentNode) {
              this.domConverter.unbindDomElement(t);
            }
          }
        }
        _diffNodeLists(t, e) {
          t = Wg(t, this._fakeSelectionContainer);
          return _(t, e, qg.bind(null, this.domConverter));
        }
        _findUpdateActions(t, e, n, o) {
          if (t.indexOf("insert") === -1 || t.indexOf("delete") === -1) {
            return t;
          }
          let i = [];
          let r = [];
          let s = [];
          const a = { equal: 0, insert: 0, delete: 0 };
          for (const c of t) {
            if (c === "insert") {
              s.push(n[a.equal + a.insert]);
            } else if (c === "delete") {
              r.push(e[a.equal + a.delete]);
            } else {
              i = i.concat(_(r, s, o).map((t) => (t === "equal" ? "update" : t)));
              i.push("equal");
              r = [];
              s = [];
            }
            a[c]++;
          }
          return i.concat(_(r, s, o).map((t) => (t === "equal" ? "update" : t)));
        }
        _markDescendantTextToSync(t) {
          if (!t) {
            return;
          }
          if (t.is("$text")) {
            this.markedTexts.add(t);
          } else if (t.is("element")) {
            for (const e of t.getChildren()) {
              this._markDescendantTextToSync(e);
            }
          }
        }
        _updateSelection() {
          if (r.isBlink && !r.isAndroid && this.isSelecting && !this.markedChildren.size) {
            return;
          }
          if (this.selection.rangeCount === 0) {
            this._removeDomSelection();
            this._removeFakeSelection();
            return;
          }
          const t = this.domConverter.mapViewToDom(this.selection.editableElement);
          if (!this.isFocused || !t) {
            return;
          }
          if (this.selection.isFake) {
            this._updateFakeSelection(t);
          } else if (this._fakeSelectionContainer && this._fakeSelectionContainer.isConnected) {
            this._removeFakeSelection();
            this._updateDomSelection(t);
          } else if (!(this.isComposing && r.isAndroid)) {
            this._updateDomSelection(t);
          }
        }
        _updateFakeSelection(t) {
          const e = t.ownerDocument;
          if (!this._fakeSelectionContainer) {
            this._fakeSelectionContainer = Gg(e);
          }
          const n = this._fakeSelectionContainer;
          this.domConverter.bindFakeSelection(n, this.selection);
          if (!this._fakeSelectionNeedsUpdate(t)) {
            return;
          }
          if (!n.parentElement || n.parentElement != t) {
            t.appendChild(n);
          }
          n.textContent = this.selection.fakeSelectionLabel || " ";
          const o = e.getSelection();
          const i = e.createRange();
          o.removeAllRanges();
          i.selectNodeContents(n);
          o.addRange(i);
        }
        _updateDomSelection(t) {
          const e = t.ownerDocument.defaultView.getSelection();
          if (!this._domSelectionNeedsUpdate(e)) {
            return;
          }
          const n = this.domConverter.viewPositionToDom(this.selection.anchor);
          const o = this.domConverter.viewPositionToDom(this.selection.focus);
          e.setBaseAndExtent(n.parent, n.offset, o.parent, o.offset);
          if (r.isGecko) {
            $g(o, e);
          }
        }
        _domSelectionNeedsUpdate(t) {
          if (!this.domConverter.isDomSelectionCorrect(t)) {
            return true;
          }
          const e = t && this.domConverter.domSelectionToView(t);
          if (e && this.selection.isEqual(e)) {
            return false;
          }
          if (!this.selection.isCollapsed && this.selection.isSimilar(e)) {
            return false;
          }
          return true;
        }
        _fakeSelectionNeedsUpdate(t) {
          const e = this._fakeSelectionContainer;
          const n = t.ownerDocument.getSelection();
          if (!e || e.parentElement !== t) {
            return true;
          }
          if (n.anchorNode !== e && !e.contains(n.anchorNode)) {
            return true;
          }
          return e.textContent !== this.selection.fakeSelectionLabel;
        }
        _removeDomSelection() {
          for (const t of this.domDocuments) {
            const e = t.getSelection();
            if (e.rangeCount) {
              const n = t.activeElement;
              const o = this.domConverter.mapDomToView(n);
              if (n && o) {
                e.removeAllRanges();
              }
            }
          }
        }
        _removeFakeSelection() {
          const t = this._fakeSelectionContainer;
          if (t) {
            t.remove();
          }
        }
        _updateFocus() {
          if (this.isFocused) {
            const t = this.selection.editableElement;
            if (t) {
              this.domConverter.focus(t);
            }
          }
        }
      }
      function Vg(t) {
        if (t.getAttribute("contenteditable") == "false") {
          return false;
        }
        const e = t.findAncestor((t) => t.hasAttribute("contenteditable"));
        return !e || e.getAttribute("contenteditable") == "true";
      }
      function Lg(t, e, n) {
        const o = e instanceof Array ? e : e.childNodes;
        const i = o[n];
        if (nc(i)) {
          i.data = Sg + i.data;
          return i;
        } else {
          const i = t.createTextNode(Sg);
          if (Array.isArray(e)) {
            o.splice(n, 0, i);
          } else {
            bc(e, n, i);
          }
          return i;
        }
      }
      function Hg(t, e) {
        return (
          $a(t) &&
          $a(e) &&
          !nc(t) &&
          !nc(e) &&
          !wc(t) &&
          !wc(e) &&
          t.tagName.toLowerCase() === e.tagName.toLowerCase()
        );
      }
      function jg(t, e) {
        return $a(t) && $a(e) && nc(t) && nc(e);
      }
      function qg(t, e, n) {
        if (e === n) {
          return true;
        } else if (nc(e) && nc(n)) {
          return e.data === n.data;
        } else if (t.isBlockFiller(e) && t.isBlockFiller(n)) {
          return true;
        }
        return false;
      }
      function $g(t, e) {
        const n = t.parent;
        if (n.nodeType != Node.ELEMENT_NODE || t.offset != n.childNodes.length - 1) {
          return;
        }
        const o = n.childNodes[t.offset];
        if (o && o.tagName == "BR") {
          e.addRange(e.getRangeAt(0));
        }
      }
      function Wg(t, e) {
        const n = Array.from(t);
        if (n.length == 0 || !e) {
          return n;
        }
        const o = n[n.length - 1];
        if (o == e) {
          n.pop();
        }
        return n;
      }
      function Gg(t) {
        const e = t.createElement("div");
        e.className = "ck-fake-selection-container";
        Object.assign(e.style, { position: "fixed", top: 0, left: "-9999px", width: "42px" });
        e.textContent = " ";
        return e;
      }
      function Kg(t, e) {
        const n = t.data;
        if (n == e) {
          return;
        }
        const o = p(n, e);
        for (const e of o) {
          if (e.type === "insert") {
            t.insertData(e.index, e.values.join(""));
          } else {
            t.deleteData(e.index, e.howMany);
          }
        }
      }
      const Ug = Eg(Qa.document);
      const Zg = yg(Qa.document);
      const Jg = xg(Qa.document);
      const Yg = "data-ck-unsafe-attribute-";
      const Qg = "data-ck-unsafe-element";
      class Xg {
        constructor(t, { blockFillerMode: e, renderingMode: n = "editing" } = {}) {
          this._domToViewMapping = new WeakMap();
          this._viewToDomMapping = new WeakMap();
          this._fakeSelectionMapping = new WeakMap();
          this._rawContentElementMatcher = new Ou();
          this._inlineObjectElementMatcher = new Ou();
          this.document = t;
          this.renderingMode = n;
          this.blockFillerMode = e || (n === "editing" ? "br" : "nbsp");
          this.preElements = ["pre"];
          this.blockElements = [
            "address",
            "article",
            "aside",
            "blockquote",
            "caption",
            "center",
            "dd",
            "details",
            "dir",
            "div",
            "dl",
            "dt",
            "fieldset",
            "figcaption",
            "figure",
            "footer",
            "form",
            "h1",
            "h2",
            "h3",
            "h4",
            "h5",
            "h6",
            "header",
            "hgroup",
            "legend",
            "li",
            "main",
            "menu",
            "nav",
            "ol",
            "p",
            "pre",
            "section",
            "summary",
            "table",
            "tbody",
            "td",
            "tfoot",
            "th",
            "thead",
            "tr",
            "ul",
          ];
          this.inlineObjectElements = [
            "object",
            "iframe",
            "input",
            "button",
            "textarea",
            "select",
            "option",
            "video",
            "embed",
            "audio",
            "img",
            "canvas",
          ];
          this.unsafeElements = ["script", "style"];
          this._domDocument =
            this.renderingMode === "editing"
              ? Qa.document
              : Qa.document.implementation.createHTMLDocument("");
        }
        bindFakeSelection(t, e) {
          this._fakeSelectionMapping.set(t, new Hp(e));
        }
        fakeSelectionToView(t) {
          return this._fakeSelectionMapping.get(t);
        }
        bindElements(t, e) {
          this._domToViewMapping.set(t, e);
          this._viewToDomMapping.set(e, t);
        }
        unbindDomElement(t) {
          const e = this._domToViewMapping.get(t);
          if (e) {
            this._domToViewMapping.delete(t);
            this._viewToDomMapping.delete(e);
            for (const e of Array.from(t.children)) {
              this.unbindDomElement(e);
            }
          }
        }
        bindDocumentFragments(t, e) {
          this._domToViewMapping.set(t, e);
          this._viewToDomMapping.set(e, t);
        }
        shouldRenderAttribute(t, e, n) {
          if (this.renderingMode === "data") {
            return true;
          }
          t = t.toLowerCase();
          if (t.startsWith("on")) {
            return false;
          }
          if (t === "srcdoc" && e.match(/\bon\S+\s*=|javascript:|<\s*\/*script/i)) {
            return false;
          }
          if (n === "img" && (t === "src" || t === "srcset")) {
            return true;
          }
          if (n === "source" && t === "srcset") {
            return true;
          }
          if (e.match(/^\s*(javascript:|data:(image\/svg|text\/x?html))/i)) {
            return false;
          }
          return true;
        }
        setContentOf(t, e) {
          if (this.renderingMode === "data") {
            t.innerHTML = e;
            return;
          }
          const n = new DOMParser().parseFromString(e, "text/html");
          const o = n.createDocumentFragment();
          const i = n.body.childNodes;
          while (i.length > 0) {
            o.appendChild(i[0]);
          }
          const r = n.createTreeWalker(o, NodeFilter.SHOW_ELEMENT);
          const s = [];
          let a;
          while ((a = r.nextNode())) {
            s.push(a);
          }
          for (const t of s) {
            for (const e of t.getAttributeNames()) {
              this.setDomElementAttribute(t, e, t.getAttribute(e));
            }
            const e = t.tagName.toLowerCase();
            if (this._shouldRenameElement(e)) {
              im(e);
              t.replaceWith(this._createReplacementDomElement(e, t));
            }
          }
          while (t.firstChild) {
            t.firstChild.remove();
          }
          t.append(o);
        }
        viewToDom(t, e = {}) {
          if (t.is("$text")) {
            const e = this._processDataFromViewText(t);
            return this._domDocument.createTextNode(e);
          } else {
            if (this.mapViewToDom(t)) {
              return this.mapViewToDom(t);
            }
            let n;
            if (t.is("documentFragment")) {
              n = this._domDocument.createDocumentFragment();
              if (e.bind) {
                this.bindDocumentFragments(n, t);
              }
            } else if (t.is("uiElement")) {
              if (t.name === "$comment") {
                n = this._domDocument.createComment(t.getCustomProperty("$rawContent"));
              } else {
                n = t.render(this._domDocument, this);
              }
              if (e.bind) {
                this.bindElements(n, t);
              }
              return n;
            } else {
              if (this._shouldRenameElement(t.name)) {
                im(t.name);
                n = this._createReplacementDomElement(t.name);
              } else if (t.hasAttribute("xmlns")) {
                n = this._domDocument.createElementNS(t.getAttribute("xmlns"), t.name);
              } else {
                n = this._domDocument.createElement(t.name);
              }
              if (t.is("rawElement")) {
                t.render(n, this);
              }
              if (e.bind) {
                this.bindElements(n, t);
              }
              for (const e of t.getAttributeKeys()) {
                this.setDomElementAttribute(n, e, t.getAttribute(e), t);
              }
            }
            if (e.withChildren !== false) {
              for (const o of this.viewChildrenToDom(t, e)) {
                n.appendChild(o);
              }
            }
            return n;
          }
        }
        setDomElementAttribute(t, e, n, o) {
          const i =
            this.shouldRenderAttribute(e, n, t.tagName.toLowerCase()) ||
            (o && o.shouldRenderUnsafeAttribute(e));
          if (!i) {
            B("domconverter-unsafe-attribute-detected", { domElement: t, key: e, value: n });
          }
          if (!_c(e)) {
            B("domconverter-invalid-attribute-detected", { domElement: t, key: e, value: n });
            return;
          }
          if (t.hasAttribute(e) && !i) {
            t.removeAttribute(e);
          } else if (t.hasAttribute(Yg + e) && i) {
            t.removeAttribute(Yg + e);
          }
          t.setAttribute(i ? e : Yg + e, n);
        }
        removeDomElementAttribute(t, e) {
          if (e == Qg) {
            return;
          }
          t.removeAttribute(e);
          t.removeAttribute(Yg + e);
        }
        *viewChildrenToDom(t, e = {}) {
          const n = t.getFillerOffset && t.getFillerOffset();
          let o = 0;
          for (const i of t.getChildren()) {
            if (n === o) {
              yield this._getBlockFiller();
            }
            const t =
              i.is("element") &&
              !!i.getCustomProperty("dataPipeline:transparentRendering") &&
              !dl(i.getAttributes());
            if (t && this.renderingMode == "data") {
              yield* this.viewChildrenToDom(i, e);
            } else {
              if (t) {
                B("domconverter-transparent-rendering-unsupported-in-editing-pipeline", {
                  viewElement: i,
                });
              }
              yield this.viewToDom(i, e);
            }
            o++;
          }
          if (n === o) {
            yield this._getBlockFiller();
          }
        }
        viewRangeToDom(t) {
          const e = this.viewPositionToDom(t.start);
          const n = this.viewPositionToDom(t.end);
          const o = this._domDocument.createRange();
          o.setStart(e.parent, e.offset);
          o.setEnd(n.parent, n.offset);
          return o;
        }
        viewPositionToDom(t) {
          const e = t.parent;
          if (e.is("$text")) {
            const n = this.findCorrespondingDomText(e);
            if (!n) {
              return null;
            }
            let o = t.offset;
            if (Tg(n)) {
              o += Dg;
            }
            return { parent: n, offset: o };
          } else {
            let n, o, i;
            if (t.offset === 0) {
              n = this.mapViewToDom(e);
              if (!n) {
                return null;
              }
              i = n.childNodes[0];
            } else {
              const e = t.nodeBefore;
              o = e.is("$text") ? this.findCorrespondingDomText(e) : this.mapViewToDom(e);
              if (!o) {
                return null;
              }
              n = o.parentNode;
              i = o.nextSibling;
            }
            if (nc(i) && Tg(i)) {
              return { parent: i, offset: Dg };
            }
            const r = o ? kc(o) + 1 : 0;
            return { parent: n, offset: r };
          }
        }
        domToView(t, e = {}) {
          const n = [];
          const o = this._domToView(t, e, n);
          const i = o.next().value;
          if (!i) {
            return null;
          }
          o.next();
          this._processDomInlineNodes(null, n, e);
          if (i.is("$text") && i.data.length == 0) {
            return null;
          }
          return i;
        }
        *domChildrenToView(t, e = {}, n = []) {
          for (let o = 0; o < t.childNodes.length; o++) {
            const i = t.childNodes[o];
            const r = this._domToView(i, e, n);
            const s = r.next().value;
            if (s !== null) {
              if (this._isBlockViewElement(s)) {
                this._processDomInlineNodes(t, n, e);
              }
              yield s;
              r.next();
            }
          }
          this._processDomInlineNodes(t, n, e);
        }
        domSelectionToView(t) {
          if (rm(t)) {
            return new Hp([]);
          }
          if (t.rangeCount === 1) {
            let e = t.getRangeAt(0).startContainer;
            if (nc(e)) {
              e = e.parentNode;
            }
            const n = this.fakeSelectionToView(e);
            if (n) {
              return n;
            }
          }
          const e = this.isDomSelectionBackward(t);
          const n = [];
          for (let e = 0; e < t.rangeCount; e++) {
            const o = t.getRangeAt(e);
            const i = this.domRangeToView(o);
            if (i) {
              n.push(i);
            }
          }
          return new Hp(n, { backward: e });
        }
        domRangeToView(t) {
          const e = this.domPositionToView(t.startContainer, t.startOffset);
          const n = this.domPositionToView(t.endContainer, t.endOffset);
          if (e && n) {
            return new Vp(e, n);
          }
          return null;
        }
        domPositionToView(t, e = 0) {
          if (this.isBlockFiller(t)) {
            return this.domPositionToView(t.parentNode, kc(t));
          }
          const n = this.mapDomToView(t);
          if (n && (n.is("uiElement") || n.is("rawElement"))) {
            return Np._createBefore(n);
          }
          if (nc(t)) {
            if (Pg(t)) {
              return this.domPositionToView(t.parentNode, kc(t));
            }
            const n = this.findCorrespondingViewText(t);
            let o = e;
            if (!n) {
              return null;
            }
            if (Tg(t)) {
              o -= Dg;
              o = o < 0 ? 0 : o;
            }
            return new Np(n, o);
          } else {
            if (e === 0) {
              const e = this.mapDomToView(t);
              if (e) {
                return new Np(e, 0);
              }
            } else {
              const n = t.childNodes[e - 1];
              if ((nc(n) && Pg(n)) || (n && this.isBlockFiller(n))) {
                return this.domPositionToView(n.parentNode, kc(n));
              }
              const o = nc(n) ? this.findCorrespondingViewText(n) : this.mapDomToView(n);
              if (o && o.parent) {
                return new Np(o.parent, o.index + 1);
              }
            }
            return null;
          }
        }
        mapDomToView(t) {
          const e = this.getHostViewElement(t);
          return e || this._domToViewMapping.get(t);
        }
        findCorrespondingViewText(t) {
          if (Pg(t)) {
            return null;
          }
          const e = this.getHostViewElement(t);
          if (e) {
            return e;
          }
          const n = t.previousSibling;
          if (n) {
            if (!this.isElement(n)) {
              return null;
            }
            const t = this.mapDomToView(n);
            if (t) {
              const e = t.nextSibling;
              if (e instanceof Pu) {
                return e;
              } else {
                return null;
              }
            }
          } else {
            const e = this.mapDomToView(t.parentNode);
            if (e) {
              const t = e.getChild(0);
              if (t instanceof Pu) {
                return t;
              } else {
                return null;
              }
            }
          }
          return null;
        }
        mapViewToDom(t) {
          return this._viewToDomMapping.get(t);
        }
        findCorrespondingDomText(t) {
          const e = t.previousSibling;
          if (e && this.mapViewToDom(e)) {
            return this.mapViewToDom(e).nextSibling;
          }
          if (!e && t.parent && this.mapViewToDom(t.parent)) {
            return this.mapViewToDom(t.parent).childNodes[0];
          }
          return null;
        }
        focus(t) {
          const e = this.mapViewToDom(t);
          if (e && e.ownerDocument.activeElement !== e) {
            const { scrollX: t, scrollY: n } = Qa.window;
            const o = [];
            em(e, (t) => {
              const { scrollLeft: e, scrollTop: n } = t;
              o.push([e, n]);
            });
            e.focus();
            em(e, (t) => {
              const [e, n] = o.shift();
              t.scrollLeft = e;
              t.scrollTop = n;
            });
            Qa.window.scrollTo(t, n);
          }
        }
        _clearDomSelection() {
          const t = this.mapViewToDom(this.document.selection.editableElement);
          if (!t) {
            return;
          }
          const e = t.ownerDocument.defaultView.getSelection();
          const n = this.domSelectionToView(e);
          const o = n && n.rangeCount > 0;
          if (o) {
            e.removeAllRanges();
          }
        }
        isElement(t) {
          return t && t.nodeType == Node.ELEMENT_NODE;
        }
        isDocumentFragment(t) {
          return t && t.nodeType == Node.DOCUMENT_FRAGMENT_NODE;
        }
        isBlockFiller(t) {
          if (this.blockFillerMode == "br") {
            return t.isEqualNode(Ug);
          }
          if (
            t.tagName === "BR" &&
            om(t, this.blockElements) &&
            t.parentNode.childNodes.length === 1
          ) {
            return true;
          }
          return t.isEqualNode(Jg) || nm(t, this.blockElements);
        }
        isDomSelectionBackward(t) {
          if (t.isCollapsed) {
            return false;
          }
          const e = this._domDocument.createRange();
          try {
            e.setStart(t.anchorNode, t.anchorOffset);
            e.setEnd(t.focusNode, t.focusOffset);
          } catch (t) {
            return false;
          }
          const n = e.collapsed;
          e.detach();
          return n;
        }
        getHostViewElement(t) {
          const e = tc(t);
          e.pop();
          while (e.length) {
            const t = e.pop();
            const n = this._domToViewMapping.get(t);
            if (n && (n.is("uiElement") || n.is("rawElement"))) {
              return n;
            }
          }
          return null;
        }
        isDomSelectionCorrect(t) {
          return (
            this._isDomSelectionPositionCorrect(t.anchorNode, t.anchorOffset) &&
            this._isDomSelectionPositionCorrect(t.focusNode, t.focusOffset)
          );
        }
        registerRawContentMatcher(t) {
          this._rawContentElementMatcher.add(t);
        }
        registerInlineObjectMatcher(t) {
          this._inlineObjectElementMatcher.add(t);
        }
        _getBlockFiller() {
          switch (this.blockFillerMode) {
            case "nbsp":
              return yg(this._domDocument);
            case "markedNbsp":
              return xg(this._domDocument);
            case "br":
              return Eg(this._domDocument);
          }
        }
        _isDomSelectionPositionCorrect(t, e) {
          if (nc(t) && Tg(t) && e < Dg) {
            return false;
          }
          if (this.isElement(t) && Tg(t.childNodes[e])) {
            return false;
          }
          const n = this.mapDomToView(t);
          if (n && (n.is("uiElement") || n.is("rawElement"))) {
            return false;
          }
          return true;
        }
        *_domToView(t, e, n) {
          if (this.isBlockFiller(t)) {
            return null;
          }
          const o = this.getHostViewElement(t);
          if (o) {
            return o;
          }
          if (wc(t) && e.skipComments) {
            return null;
          }
          if (nc(t)) {
            if (Pg(t)) {
              return null;
            } else {
              const e = t.data;
              if (e === "") {
                return null;
              }
              const o = new Pu(this.document, e);
              n.push(o);
              return o;
            }
          } else {
            let o = this.mapDomToView(t);
            if (o) {
              if (this._isInlineObjectElement(o)) {
                n.push(o);
              }
              return o;
            }
            if (this.isDocumentFragment(t)) {
              o = new dg(this.document);
              if (e.bind) {
                this.bindDocumentFragments(t, o);
              }
            } else {
              o = this._createViewElement(t, e);
              if (e.bind) {
                this.bindElements(t, o);
              }
              const i = t.attributes;
              if (i) {
                for (let t = i.length, e = 0; e < t; e++) {
                  o._setAttribute(i[e].name, i[e].value);
                }
              }
              if (this._isViewElementWithRawContent(o, e)) {
                o._setCustomProperty("$rawContent", t.innerHTML);
                if (!this._isBlockViewElement(o)) {
                  n.push(o);
                }
                return o;
              }
              if (wc(t)) {
                o._setCustomProperty("$rawContent", t.data);
                return o;
              }
            }
            yield o;
            const i = [];
            if (e.withChildren !== false) {
              for (const n of this.domChildrenToView(t, e, i)) {
                o._appendChild(n);
              }
            }
            if (this._isInlineObjectElement(o)) {
              n.push(o);
            } else {
              for (const t of i) {
                n.push(t);
              }
            }
          }
        }
        _processDomInlineNodes(t, e, n) {
          if (!e.length) {
            return;
          }
          if (t && !this.isDocumentFragment(t) && !this._isBlockDomElement(t)) {
            return;
          }
          let o = false;
          for (let t = 0; t < e.length; t++) {
            const i = e[t];
            if (!i.is("$text")) {
              o = false;
              continue;
            }
            let r;
            let s = false;
            if (tm(i, this.preElements)) {
              r = Bg(i.data);
            } else {
              r = i.data.replace(/[ \n\t\r]{1,}/g, " ");
              s = /[^\S\u00A0]/.test(r.charAt(r.length - 1));
              const a = t > 0 ? e[t - 1] : null;
              const c = t + 1 < e.length ? e[t + 1] : null;
              const l = !a || (a.is("element") && a.name == "br") || o;
              const d = c ? false : !Tg(i.data);
              if (n.withChildren !== false) {
                if (l) {
                  r = r.replace(/^ /, "");
                }
                if (d) {
                  r = r.replace(/ $/, "");
                }
              }
              r = Bg(r);
              r = r.replace(/ \u00A0/g, "  ");
              const h = c && c.is("element") && c.name != "br";
              const u = c && c.is("$text") && c.data.charAt(0) == " ";
              if (/[ \u00A0]\u00A0$/.test(r) || !c || h || u) {
                r = r.replace(/\u00A0$/, " ");
              }
              if (l || (a && a.is("element") && a.name != "br")) {
                r = r.replace(/^\u00A0/, " ");
              }
            }
            if (r.length == 0 && i.parent) {
              i._remove();
              e.splice(t, 1);
              t--;
            } else {
              i._data = r;
              o = s;
            }
          }
          e.length = 0;
        }
        _processDataFromViewText(t) {
          let e = t.data;
          if (t.getAncestors().some((t) => this.preElements.includes(t.name))) {
            return e;
          }
          if (e.charAt(0) == " ") {
            const n = this._getTouchingInlineViewNode(t, false);
            const o = n && n.is("$textProxy") && this._nodeEndsWithSpace(n);
            if (o || !n) {
              e = " " + e.substr(1);
            }
          }
          if (e.charAt(e.length - 1) == " ") {
            const n = this._getTouchingInlineViewNode(t, true);
            const o = n && n.is("$textProxy") && n.data.charAt(0) == " ";
            if (e.charAt(e.length - 2) == " " || !n || o) {
              e = e.substr(0, e.length - 1) + " ";
            }
          }
          return e.replace(/ {2}/g, "  ");
        }
        _nodeEndsWithSpace(t) {
          if (t.getAncestors().some((t) => this.preElements.includes(t.name))) {
            return false;
          }
          const e = this._processDataFromViewText(t);
          return e.charAt(e.length - 1) == " ";
        }
        _getTouchingInlineViewNode(t, e) {
          const n = new Mp({
            startPosition: e ? Np._createAfter(t) : Np._createBefore(t),
            direction: e ? "forward" : "backward",
          });
          for (const t of n) {
            if (t.item.is("element", "br")) {
              return null;
            } else if (this._isInlineObjectElement(t.item)) {
              return t.item;
            } else if (t.item.is("containerElement")) {
              return null;
            } else if (t.item.is("$textProxy")) {
              return t.item;
            }
          }
          return null;
        }
        _isBlockDomElement(t) {
          return this.isElement(t) && this.blockElements.includes(t.tagName.toLowerCase());
        }
        _isBlockViewElement(t) {
          return t.is("element") && this.blockElements.includes(t.name);
        }
        _isInlineObjectElement(t) {
          if (!t.is("element")) {
            return false;
          }
          return (
            t.name == "br" ||
            this.inlineObjectElements.includes(t.name) ||
            !!this._inlineObjectElementMatcher.match(t)
          );
        }
        _createViewElement(t, e) {
          if (wc(t)) {
            return new ig(this.document, "$comment");
          }
          const n = e.keepOriginalCase ? t.tagName : t.tagName.toLowerCase();
          return new Sp(this.document, n);
        }
        _isViewElementWithRawContent(t, e) {
          return (
            e.withChildren !== false && t.is("element") && !!this._rawContentElementMatcher.match(t)
          );
        }
        _shouldRenameElement(t) {
          const e = t.toLowerCase();
          return this.renderingMode === "editing" && this.unsafeElements.includes(e);
        }
        _createReplacementDomElement(t, e) {
          const n = this._domDocument.createElement("span");
          n.setAttribute(Qg, t);
          if (e) {
            while (e.firstChild) {
              n.appendChild(e.firstChild);
            }
            for (const t of e.getAttributeNames()) {
              n.setAttribute(t, e.getAttribute(t));
            }
          }
          return n;
        }
      }
      function tm(t, e) {
        return t.getAncestors().some((t) => t.is("element") && e.includes(t.name));
      }
      function em(t, e) {
        let n = t;
        while (n) {
          e(n);
          n = n.parentElement;
        }
      }
      function nm(t, e) {
        const n = t.isEqualNode(Zg);
        return n && om(t, e) && t.parentNode.childNodes.length === 1;
      }
      function om(t, e) {
        const n = t.parentNode;
        return !!n && !!n.tagName && e.includes(n.tagName.toLowerCase());
      }
      function im(t) {
        if (t === "script") {
          B("domconverter-unsafe-script-element-detected");
        }
        if (t === "style") {
          B("domconverter-unsafe-style-element-detected");
        }
      }
      function rm(t) {
        if (!r.isGecko) {
          return false;
        }
        if (!t.rangeCount) {
          return false;
        }
        const e = t.getRangeAt(0).startContainer;
        try {
          Object.prototype.toString.call(e);
        } catch (t) {
          return true;
        }
        return false;
      }
      class sm extends Ka() {
        constructor(t) {
          super();
          this._isEnabled = false;
          this.view = t;
          this.document = t.document;
        }
        get isEnabled() {
          return this._isEnabled;
        }
        enable() {
          this._isEnabled = true;
        }
        disable() {
          this._isEnabled = false;
        }
        destroy() {
          this.disable();
          this.stopListening();
        }
        checkShouldIgnoreEventFromTarget(t) {
          if (t && t.nodeType === 3) {
            t = t.parentNode;
          }
          if (!t || t.nodeType !== 1) {
            return false;
          }
          return t.matches("[data-cke-ignore-events], [data-cke-ignore-events] *");
        }
      }
      var am = mp(function (t, e) {
        po(e, Yi(e), t);
      });
      const cm = am;
      class lm {
        constructor(t, e, n) {
          this.view = t;
          this.document = t.document;
          this.domEvent = e;
          this.domTarget = e.target;
          cm(this, n);
        }
        get target() {
          return this.view.domConverter.mapDomToView(this.domTarget);
        }
        preventDefault() {
          this.domEvent.preventDefault();
        }
        stopPropagation() {
          this.domEvent.stopPropagation();
        }
      }
      class dm extends sm {
        constructor() {
          super(...arguments);
          this.useCapture = false;
        }
        observe(t) {
          const e = typeof this.domEventType == "string" ? [this.domEventType] : this.domEventType;
          e.forEach((e) => {
            this.listenTo(
              t,
              e,
              (t, e) => {
                if (this.isEnabled && !this.checkShouldIgnoreEventFromTarget(e.target)) {
                  this.onDomEvent(e);
                }
              },
              { useCapture: this.useCapture }
            );
          });
        }
        stopObserving(t) {
          this.stopListening(t);
        }
        fire(t, e, n) {
          if (this.isEnabled) {
            this.document.fire(t, new lm(this.view, e, n));
          }
        }
      }
      class hm extends dm {
        constructor() {
          super(...arguments);
          this.domEventType = ["keydown", "keyup"];
        }
        onDomEvent(t) {
          const e = {
            keyCode: t.keyCode,
            altKey: t.altKey,
            ctrlKey: t.ctrlKey,
            shiftKey: t.shiftKey,
            metaKey: t.metaKey,
            get keystroke() {
              return $c(this);
            },
          };
          this.fire(t.type, t, e);
        }
      }
      class um extends sm {
        constructor(t) {
          super(t);
          this._fireSelectionChangeDoneDebounced = mh((t) => {
            this.document.fire("selectionChangeDone", t);
          }, 200);
        }
        observe() {
          const t = this.document;
          t.on(
            "arrowKey",
            (e, n) => {
              const o = t.selection;
              if (o.isFake && this.isEnabled) {
                n.preventDefault();
              }
            },
            { context: "$capture" }
          );
          t.on(
            "arrowKey",
            (e, n) => {
              const o = t.selection;
              if (o.isFake && this.isEnabled) {
                this._handleSelectionMove(n.keyCode);
              }
            },
            { priority: "lowest" }
          );
        }
        stopObserving() {}
        destroy() {
          super.destroy();
          this._fireSelectionChangeDoneDebounced.cancel();
        }
        _handleSelectionMove(t) {
          const e = this.document.selection;
          const n = new Hp(e.getRanges(), { backward: e.isBackward, fake: false });
          if (t == jc.arrowleft || t == jc.arrowup) {
            n.setTo(n.getFirstPosition());
          }
          if (t == jc.arrowright || t == jc.arrowdown) {
            n.setTo(n.getLastPosition());
          }
          const o = { oldSelection: e, newSelection: n, domSelection: null };
          this.document.fire("selectionChange", o);
          this._fireSelectionChangeDoneDebounced(o);
        }
      }
      var fm = "__lodash_hash_undefined__";
      function pm(t) {
        this.__data__.set(t, fm);
        return this;
      }
      const gm = pm;
      function mm(t) {
        return this.__data__.has(t);
      }
      const km = mm;
      function bm(t) {
        var e = -1,
          n = t == null ? 0 : t.length;
        this.__data__ = new Jn();
        while (++e < n) {
          this.add(t[e]);
        }
      }
      bm.prototype.add = bm.prototype.push = gm;
      bm.prototype.has = km;
      const wm = bm;
      function _m(t, e) {
        var n = -1,
          o = t == null ? 0 : t.length;
        while (++n < o) {
          if (e(t[n], n, t)) {
            return true;
          }
        }
        return false;
      }
      const vm = _m;
      function Am(t, e) {
        return t.has(e);
      }
      const Cm = Am;
      var ym = 1,
        xm = 2;
      function Em(t, e, n, o, i, r) {
        var s = n & ym,
          a = t.length,
          c = e.length;
        if (a != c && !(s && c > a)) {
          return false;
        }
        var l = r.get(t);
        var d = r.get(e);
        if (l && d) {
          return l == e && d == t;
        }
        var h = -1,
          u = true,
          f = n & xm ? new wm() : undefined;
        r.set(t, e);
        r.set(e, t);
        while (++h < a) {
          var p = t[h],
            g = e[h];
          if (o) {
            var m = s ? o(g, p, h, e, t, r) : o(p, g, h, t, e, r);
          }
          if (m !== undefined) {
            if (m) {
              continue;
            }
            u = false;
            break;
          }
          if (f) {
            if (
              !vm(e, function (t, e) {
                if (!Cm(f, e) && (p === t || i(p, t, n, o, r))) {
                  return f.push(e);
                }
              })
            ) {
              u = false;
              break;
            }
          } else if (!(p === g || i(p, g, n, o, r))) {
            u = false;
            break;
          }
        }
        r["delete"](t);
        r["delete"](e);
        return u;
      }
      const Dm = Em;
      function Sm(t) {
        var e = -1,
          n = Array(t.size);
        t.forEach(function (t, o) {
          n[++e] = [o, t];
        });
        return n;
      }
      const Tm = Sm;
      function Pm(t) {
        var e = -1,
          n = Array(t.size);
        t.forEach(function (t) {
          n[++e] = t;
        });
        return n;
      }
      const Bm = Pm;
      var Om = 1,
        Rm = 2;
      var Im = "[object Boolean]",
        zm = "[object Date]",
        Fm = "[object Error]",
        Mm = "[object Map]",
        Nm = "[object Number]",
        Vm = "[object RegExp]",
        Lm = "[object Set]",
        Hm = "[object String]",
        jm = "[object Symbol]";
      var qm = "[object ArrayBuffer]",
        $m = "[object DataView]";
      var Wm = Pt ? Pt.prototype : undefined,
        Gm = Wm ? Wm.valueOf : undefined;
      function Km(t, e, n, o, i, r, s) {
        switch (n) {
          case $m:
            if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset) {
              return false;
            }
            t = t.buffer;
            e = e.buffer;
          case qm:
            if (t.byteLength != e.byteLength || !r(new rs(t), new rs(e))) {
              return false;
            }
            return true;
          case Im:
          case zm:
          case Nm:
            return ge(+t, +e);
          case Fm:
            return t.name == e.name && t.message == e.message;
          case Vm:
          case Hm:
            return t == e + "";
          case Mm:
            var a = Tm;
          case Lm:
            var c = o & Om;
            a || (a = Bm);
            if (t.size != e.size && !c) {
              return false;
            }
            var l = s.get(t);
            if (l) {
              return l == e;
            }
            o |= Rm;
            s.set(t, e);
            var d = Dm(a(t), a(e), o, i, r, s);
            s["delete"](t);
            return d;
          case jm:
            if (Gm) {
              return Gm.call(t) == Gm.call(e);
            }
        }
        return false;
      }
      const Um = Km;
      var Zm = 1;
      var Jm = Object.prototype;
      var Ym = Jm.hasOwnProperty;
      function Qm(t, e, n, o, i, r) {
        var s = n & Zm,
          a = Pr(t),
          c = a.length,
          l = Pr(e),
          d = l.length;
        if (c != d && !s) {
          return false;
        }
        var h = c;
        while (h--) {
          var u = a[h];
          if (!(s ? u in e : Ym.call(e, u))) {
            return false;
          }
        }
        var f = r.get(t);
        var p = r.get(e);
        if (f && p) {
          return f == e && p == t;
        }
        var g = true;
        r.set(t, e);
        r.set(e, t);
        var m = s;
        while (++h < c) {
          u = a[h];
          var k = t[u],
            b = e[u];
          if (o) {
            var w = s ? o(b, k, u, e, t, r) : o(k, b, u, t, e, r);
          }
          if (!(w === undefined ? k === b || i(k, b, n, o, r) : w)) {
            g = false;
            break;
          }
          m || (m = u == "constructor");
        }
        if (g && !m) {
          var _ = t.constructor,
            v = e.constructor;
          if (
            _ != v &&
            "constructor" in t &&
            "constructor" in e &&
            !(typeof _ == "function" && _ instanceof _ && typeof v == "function" && v instanceof v)
          ) {
            g = false;
          }
        }
        r["delete"](t);
        r["delete"](e);
        return g;
      }
      const Xm = Qm;
      var tk = 1;
      var ek = "[object Arguments]",
        nk = "[object Array]",
        ok = "[object Object]";
      var ik = Object.prototype;
      var rk = ik.hasOwnProperty;
      function sk(t, e, n, o, i, r) {
        var s = Kt(t),
          a = Kt(e),
          c = s ? nk : Xr(t),
          l = a ? nk : Xr(e);
        c = c == ek ? ok : c;
        l = l == ek ? ok : l;
        var d = c == ok,
          h = l == ok,
          u = c == l;
        if (u && Ro(t)) {
          if (!Ro(e)) {
            return false;
          }
          s = true;
          d = false;
        }
        if (u && !d) {
          r || (r = new eo());
          return s || yi(t) ? Dm(t, e, n, o, i, r) : Um(t, e, c, n, o, i, r);
        }
        if (!(n & tk)) {
          var f = d && rk.call(t, "__wrapped__"),
            p = h && rk.call(e, "__wrapped__");
          if (f || p) {
            var g = f ? t.value() : t,
              m = p ? e.value() : e;
            r || (r = new eo());
            return i(g, m, n, o, r);
          }
        }
        if (!u) {
          return false;
        }
        r || (r = new eo());
        return Xm(t, e, n, o, i, r);
      }
      const ak = sk;
      function ck(t, e, n, o, i) {
        if (t === e) {
          return true;
        }
        if (t == null || e == null || (!Zt(t) && !Zt(e))) {
          return t !== t && e !== e;
        }
        return ak(t, e, n, o, ck, i);
      }
      const lk = ck;
      function dk(t, e, n) {
        n = typeof n == "function" ? n : undefined;
        var o = n ? n(t, e) : undefined;
        return o === undefined ? lk(t, e, undefined, n) : !!o;
      }
      const hk = dk;
      class uk extends sm {
        constructor(t) {
          super(t);
          this._config = { childList: true, characterData: true, subtree: true };
          this.domConverter = t.domConverter;
          this.renderer = t._renderer;
          this._domElements = new Set();
          this._mutationObserver = new window.MutationObserver(this._onMutations.bind(this));
        }
        flush() {
          this._onMutations(this._mutationObserver.takeRecords());
        }
        observe(t) {
          this._domElements.add(t);
          if (this.isEnabled) {
            this._mutationObserver.observe(t, this._config);
          }
        }
        stopObserving(t) {
          this._domElements.delete(t);
          if (this.isEnabled) {
            this._mutationObserver.disconnect();
            for (const t of this._domElements) {
              this._mutationObserver.observe(t, this._config);
            }
          }
        }
        enable() {
          super.enable();
          for (const t of this._domElements) {
            this._mutationObserver.observe(t, this._config);
          }
        }
        disable() {
          super.disable();
          this._mutationObserver.disconnect();
        }
        destroy() {
          super.destroy();
          this._mutationObserver.disconnect();
        }
        _onMutations(t) {
          if (t.length === 0) {
            return;
          }
          const e = this.domConverter;
          const n = new Set();
          const o = new Set();
          for (const n of t) {
            const t = e.mapDomToView(n.target);
            if (!t) {
              continue;
            }
            if (t.is("uiElement") || t.is("rawElement")) {
              continue;
            }
            if (n.type === "childList" && !this._isBogusBrMutation(n)) {
              o.add(t);
            }
          }
          for (const i of t) {
            const t = e.mapDomToView(i.target);
            if (t && (t.is("uiElement") || t.is("rawElement"))) {
              continue;
            }
            if (i.type === "characterData") {
              const t = e.findCorrespondingViewText(i.target);
              if (t && !o.has(t.parent)) {
                n.add(t);
              } else if (!t && Tg(i.target)) {
                o.add(e.mapDomToView(i.target.parentNode));
              }
            }
          }
          let i = false;
          for (const t of n) {
            i = true;
            this.renderer.markToSync("text", t);
          }
          for (const t of o) {
            const n = e.mapViewToDom(t);
            const o = Array.from(t.getChildren());
            const r = Array.from(e.domChildrenToView(n, { withChildren: false }));
            if (!hk(o, r, fk)) {
              i = true;
              this.renderer.markToSync("children", t);
            }
          }
          if (i) {
            this.view.forceRender();
          }
        }
        _isBogusBrMutation(t) {
          let e = null;
          if (t.nextSibling === null && t.removedNodes.length === 0 && t.addedNodes.length == 1) {
            e = this.domConverter.domToView(t.addedNodes[0], { withChildren: false });
          }
          return e && e.is("element", "br");
        }
      }
      function fk(t, e) {
        if (Array.isArray(t)) {
          return;
        }
        if (t === e) {
          return true;
        } else if (t.is("$text") && e.is("$text")) {
          return t.data === e.data;
        }
        return false;
      }
      class pk extends dm {
        constructor(t) {
          super(t);
          this._isFocusChanging = false;
          this.domEventType = ["focus", "blur"];
          this.useCapture = true;
          const e = this.document;
          e.on("focus", () => {
            this._isFocusChanging = true;
            this._renderTimeoutId = setTimeout(() => {
              this.flush();
              t.change(() => {});
            }, 50);
          });
          e.on("blur", (n, o) => {
            const i = e.selection.editableElement;
            if (i === null || i === o.target) {
              e.isFocused = false;
              this._isFocusChanging = false;
              t.change(() => {});
            }
          });
        }
        flush() {
          if (this._isFocusChanging) {
            this._isFocusChanging = false;
            this.document.isFocused = true;
          }
        }
        onDomEvent(t) {
          this.fire(t.type, t);
        }
        destroy() {
          if (this._renderTimeoutId) {
            clearTimeout(this._renderTimeoutId);
          }
          super.destroy();
        }
      }
      class gk extends sm {
        constructor(t) {
          super(t);
          this.mutationObserver = t.getObserver(uk);
          this.focusObserver = t.getObserver(pk);
          this.selection = this.document.selection;
          this.domConverter = t.domConverter;
          this._documents = new WeakSet();
          this._fireSelectionChangeDoneDebounced = mh((t) => {
            this.document.fire("selectionChangeDone", t);
          }, 200);
          this._clearInfiniteLoopInterval = setInterval(() => this._clearInfiniteLoop(), 1e3);
          this._documentIsSelectingInactivityTimeoutDebounced = mh(
            () => (this.document.isSelecting = false),
            5e3
          );
          this._loopbackCounter = 0;
        }
        observe(t) {
          const e = t.ownerDocument;
          const n = () => {
            this.document.isSelecting = true;
            this._documentIsSelectingInactivityTimeoutDebounced();
          };
          const o = () => {
            if (!this.document.isSelecting) {
              return;
            }
            this._handleSelectionChange(null, e);
            this.document.isSelecting = false;
            this._documentIsSelectingInactivityTimeoutDebounced.cancel();
          };
          this.listenTo(t, "selectstart", n, { priority: "highest" });
          this.listenTo(t, "keydown", o, { priority: "highest", useCapture: true });
          this.listenTo(t, "keyup", o, { priority: "highest", useCapture: true });
          if (this._documents.has(e)) {
            return;
          }
          this.listenTo(e, "mouseup", o, { priority: "highest", useCapture: true });
          this.listenTo(e, "selectionchange", (t, n) => {
            if (this.document.isComposing && !r.isAndroid) {
              return;
            }
            this._handleSelectionChange(n, e);
            this._documentIsSelectingInactivityTimeoutDebounced();
          });
          this._documents.add(e);
        }
        stopObserving(t) {
          this.stopListening(t);
        }
        destroy() {
          super.destroy();
          clearInterval(this._clearInfiniteLoopInterval);
          this._fireSelectionChangeDoneDebounced.cancel();
          this._documentIsSelectingInactivityTimeoutDebounced.cancel();
        }
        _reportInfiniteLoop() {}
        _handleSelectionChange(t, e) {
          if (!this.isEnabled) {
            return;
          }
          const n = e.defaultView.getSelection();
          if (this.checkShouldIgnoreEventFromTarget(n.anchorNode)) {
            return;
          }
          this.mutationObserver.flush();
          const o = this.domConverter.domSelectionToView(n);
          if (o.rangeCount == 0) {
            this.view.hasDomSelection = false;
            return;
          }
          this.view.hasDomSelection = true;
          this.focusObserver.flush();
          if (this.selection.isEqual(o) && this.domConverter.isDomSelectionCorrect(n)) {
            return;
          }
          if (++this._loopbackCounter > 60) {
            this._reportInfiniteLoop();
            return;
          }
          if (this.selection.isSimilar(o)) {
            this.view.forceRender();
          } else {
            const t = { oldSelection: this.selection, newSelection: o, domSelection: n };
            this.document.fire("selectionChange", t);
            this._fireSelectionChangeDoneDebounced(t);
          }
        }
        _clearInfiniteLoop() {
          this._loopbackCounter = 0;
        }
      }
      class mk extends dm {
        constructor(t) {
          super(t);
          this.domEventType = ["compositionstart", "compositionupdate", "compositionend"];
          const e = this.document;
          e.on(
            "compositionstart",
            () => {
              e.isComposing = true;
            },
            { priority: "low" }
          );
          e.on(
            "compositionend",
            () => {
              e.isComposing = false;
            },
            { priority: "low" }
          );
        }
        onDomEvent(t) {
          this.fire(t.type, t, { data: t.data });
        }
      }
      class kk {
        constructor(t, e = {}) {
          this._files = e.cacheFiles ? bk(t) : null;
          this._native = t;
        }
        get files() {
          if (!this._files) {
            this._files = bk(this._native);
          }
          return this._files;
        }
        get types() {
          return this._native.types;
        }
        getData(t) {
          return this._native.getData(t);
        }
        setData(t, e) {
          this._native.setData(t, e);
        }
        set effectAllowed(t) {
          this._native.effectAllowed = t;
        }
        get effectAllowed() {
          return this._native.effectAllowed;
        }
        set dropEffect(t) {
          this._native.dropEffect = t;
        }
        get dropEffect() {
          return this._native.dropEffect;
        }
        setDragImage(t, e, n) {
          this._native.setDragImage(t, e, n);
        }
        get isCanceled() {
          return this._native.dropEffect == "none" || !!this._native.mozUserCancelled;
        }
      }
      function bk(t) {
        const e = Array.from(t.files || []);
        const n = Array.from(t.items || []);
        if (e.length) {
          return e;
        }
        return n.filter((t) => t.kind === "file").map((t) => t.getAsFile());
      }
      class wk extends dm {
        constructor() {
          super(...arguments);
          this.domEventType = "beforeinput";
        }
        onDomEvent(t) {
          const e = t.getTargetRanges();
          const n = this.view;
          const o = n.document;
          let i = null;
          let s = null;
          let a = [];
          if (t.dataTransfer) {
            i = new kk(t.dataTransfer);
          }
          if (t.data !== null) {
            s = t.data;
          } else if (i) {
            s = i.getData("text/plain");
          }
          if (o.selection.isFake) {
            a = Array.from(o.selection.getRanges());
          } else if (e.length) {
            a = e
              .map((t) => {
                const e = n.domConverter.domPositionToView(t.startContainer, t.startOffset);
                const o = n.domConverter.domPositionToView(t.endContainer, t.endOffset);
                if (e) {
                  return n.createRange(e, o);
                } else if (o) {
                  return n.createRange(o);
                }
              })
              .filter((t) => !!t);
          } else if (r.isAndroid) {
            const e = t.target.ownerDocument.defaultView.getSelection();
            a = Array.from(n.domConverter.domSelectionToView(e).getRanges());
          }
          if (r.isAndroid && t.inputType == "insertCompositionText" && s && s.endsWith("\n")) {
            this.fire(t.type, t, {
              inputType: "insertParagraph",
              targetRanges: [n.createRange(a[0].end)],
            });
            return;
          }
          if (t.inputType == "insertText" && s && s.includes("\n")) {
            const e = s.split(/\n{1,2}/g);
            let n = a;
            for (let r = 0; r < e.length; r++) {
              const s = e[r];
              if (s != "") {
                this.fire(t.type, t, {
                  data: s,
                  dataTransfer: i,
                  targetRanges: n,
                  inputType: t.inputType,
                  isComposing: t.isComposing,
                });
                n = [o.selection.getFirstRange()];
              }
              if (r + 1 < e.length) {
                this.fire(t.type, t, { inputType: "insertParagraph", targetRanges: n });
                n = [o.selection.getFirstRange()];
              }
            }
            return;
          }
          this.fire(t.type, t, {
            data: s,
            dataTransfer: i,
            targetRanges: a,
            inputType: t.inputType,
            isComposing: t.isComposing,
          });
        }
      }
      class _k extends sm {
        constructor(t) {
          super(t);
          this.document.on("keydown", (t, e) => {
            if (this.isEnabled && Kc(e.keyCode)) {
              const n = new qp(this.document, "arrowKey", this.document.selection.getFirstRange());
              this.document.fire(n, e);
              if (n.stop.called) {
                t.stop();
              }
            }
          });
        }
        observe() {}
        stopObserving() {}
      }
      class vk extends sm {
        constructor(t) {
          super(t);
          const e = this.document;
          e.on("keydown", (t, n) => {
            if (!this.isEnabled || n.keyCode != jc.tab || n.ctrlKey) {
              return;
            }
            const o = new qp(e, "tab", e.selection.getFirstRange());
            e.fire(o, n);
            if (o.stop.called) {
              t.stop();
            }
          });
        }
        observe() {}
        stopObserving() {}
      }
      var Ak = 1,
        Ck = 4;
      function yk(t) {
        return Ia(t, Ak | Ck);
      }
      const xk = yk;
      class Ek extends lt() {
        constructor(t) {
          super();
          this.domRoots = new Map();
          this._initialDomRootAttributes = new WeakMap();
          this._observers = new Map();
          this._ongoingChange = false;
          this._postFixersInProgress = false;
          this._renderingDisabled = false;
          this._hasChangedSinceTheLastRendering = false;
          this.document = new Yp(t);
          this.domConverter = new Xg(this.document);
          this.set("isRenderingInProgress", false);
          this.set("hasDomSelection", false);
          this._renderer = new Ng(this.domConverter, this.document.selection);
          this._renderer
            .bind("isFocused", "isSelecting", "isComposing")
            .to(this.document, "isFocused", "isSelecting", "isComposing");
          this._writer = new ug(this.document);
          this.addObserver(uk);
          this.addObserver(pk);
          this.addObserver(gk);
          this.addObserver(hm);
          this.addObserver(um);
          this.addObserver(mk);
          this.addObserver(_k);
          this.addObserver(wk);
          this.addObserver(vk);
          Og(this);
          rg(this);
          this.on("render", () => {
            this._render();
            this.document.fire("layoutChanged");
            this._hasChangedSinceTheLastRendering = false;
          });
          this.listenTo(this.document.selection, "change", () => {
            this._hasChangedSinceTheLastRendering = true;
          });
          this.listenTo(this.document, "change:isFocused", () => {
            this._hasChangedSinceTheLastRendering = true;
          });
          if (r.isiOS) {
            this.listenTo(this.document, "blur", (t, e) => {
              const n = this.domConverter.mapDomToView(e.domEvent.relatedTarget);
              if (!n) {
                this.domConverter._clearDomSelection();
              }
            });
          }
        }
        attachDomRoot(t, e = "main") {
          const n = this.document.getRoot(e);
          n._name = t.tagName.toLowerCase();
          const o = {};
          for (const { name: e, value: i } of Array.from(t.attributes)) {
            o[e] = i;
            if (e === "class") {
              this._writer.addClass(i.split(" "), n);
            } else {
              this._writer.setAttribute(e, i, n);
            }
          }
          this._initialDomRootAttributes.set(t, o);
          const i = () => {
            this._writer.setAttribute("contenteditable", (!n.isReadOnly).toString(), n);
            if (n.isReadOnly) {
              this._writer.addClass("ck-read-only", n);
            } else {
              this._writer.removeClass("ck-read-only", n);
            }
          };
          i();
          this.domRoots.set(e, t);
          this.domConverter.bindElements(t, n);
          this._renderer.markToSync("children", n);
          this._renderer.markToSync("attributes", n);
          this._renderer.domDocuments.add(t.ownerDocument);
          n.on("change:children", (t, e) => this._renderer.markToSync("children", e));
          n.on("change:attributes", (t, e) => this._renderer.markToSync("attributes", e));
          n.on("change:text", (t, e) => this._renderer.markToSync("text", e));
          n.on("change:isReadOnly", () => this.change(i));
          n.on("change", () => {
            this._hasChangedSinceTheLastRendering = true;
          });
          for (const n of this._observers.values()) {
            n.observe(t, e);
          }
        }
        detachDomRoot(t) {
          const e = this.domRoots.get(t);
          Array.from(e.attributes).forEach(({ name: t }) => e.removeAttribute(t));
          const n = this._initialDomRootAttributes.get(e);
          for (const t in n) {
            e.setAttribute(t, n[t]);
          }
          this.domRoots.delete(t);
          this.domConverter.unbindDomElement(e);
          for (const t of this._observers.values()) {
            t.stopObserving(e);
          }
        }
        getDomRoot(t = "main") {
          return this.domRoots.get(t);
        }
        addObserver(t) {
          let e = this._observers.get(t);
          if (e) {
            return e;
          }
          e = new t(this);
          this._observers.set(t, e);
          for (const [t, n] of this.domRoots) {
            e.observe(n, t);
          }
          e.enable();
          return e;
        }
        getObserver(t) {
          return this._observers.get(t);
        }
        disableObservers() {
          for (const t of this._observers.values()) {
            t.disable();
          }
        }
        enableObservers() {
          for (const t of this._observers.values()) {
            t.enable();
          }
        }
        scrollToTheSelection({
          alignToTop: t,
          forceScroll: e,
          viewportOffset: n = 20,
          ancestorOffset: o = 20,
        } = {}) {
          const i = this.document.selection.getFirstRange();
          if (!i) {
            return;
          }
          const r = xk({ alignToTop: t, forceScroll: e, viewportOffset: n, ancestorOffset: o });
          if (typeof n === "number") {
            n = { top: n, bottom: n, left: n, right: n };
          }
          const s = {
            target: this.domConverter.viewRangeToDom(i),
            viewportOffset: n,
            ancestorOffset: o,
            alignToTop: t,
            forceScroll: e,
          };
          this.fire("scrollToTheSelection", s, r);
          Sc(s);
        }
        focus() {
          if (!this.document.isFocused) {
            const t = this.document.selection.editableElement;
            if (t) {
              this.domConverter.focus(t);
              this.forceRender();
            } else {
            }
          }
        }
        change(t) {
          if (this.isRenderingInProgress || this._postFixersInProgress) {
            throw new P("cannot-change-view-tree", this);
          }
          try {
            if (this._ongoingChange) {
              return t(this._writer);
            }
            this._ongoingChange = true;
            const e = t(this._writer);
            this._ongoingChange = false;
            if (!this._renderingDisabled && this._hasChangedSinceTheLastRendering) {
              this._postFixersInProgress = true;
              this.document._callPostFixers(this._writer);
              this._postFixersInProgress = false;
              this.fire("render");
            }
            return e;
          } catch (t) {
            P.rethrowUnexpectedError(t, this);
          }
        }
        forceRender() {
          this._hasChangedSinceTheLastRendering = true;
          this.getObserver(pk).flush();
          this.change(() => {});
        }
        destroy() {
          for (const t of this._observers.values()) {
            t.destroy();
          }
          this.document.destroy();
          this.stopListening();
        }
        createPositionAt(t, e) {
          return Np._createAt(t, e);
        }
        createPositionAfter(t) {
          return Np._createAfter(t);
        }
        createPositionBefore(t) {
          return Np._createBefore(t);
        }
        createRange(t, e) {
          return new Vp(t, e);
        }
        createRangeOn(t) {
          return Vp._createOn(t);
        }
        createRangeIn(t) {
          return Vp._createIn(t);
        }
        createSelection(...t) {
          return new Hp(...t);
        }
        _disableRendering(t) {
          this._renderingDisabled = t;
          if (t == false) {
            this.change(() => {});
          }
        }
        _render() {
          this.isRenderingInProgress = true;
          this.disableObservers();
          this._renderer.render();
          this.enableObservers();
          this.isRenderingInProgress = false;
        }
      }
      class Dk {
        is() {
          throw new Error("is() method is abstract");
        }
      }
      class Sk extends Dk {
        constructor(t) {
          super();
          this.parent = null;
          this._attrs = pl(t);
        }
        get document() {
          return null;
        }
        get index() {
          let t;
          if (!this.parent) {
            return null;
          }
          if ((t = this.parent.getChildIndex(this)) === null) {
            throw new P("model-node-not-found-in-parent", this);
          }
          return t;
        }
        get startOffset() {
          let t;
          if (!this.parent) {
            return null;
          }
          if ((t = this.parent.getChildStartOffset(this)) === null) {
            throw new P("model-node-not-found-in-parent", this);
          }
          return t;
        }
        get offsetSize() {
          return 1;
        }
        get endOffset() {
          if (!this.parent) {
            return null;
          }
          return this.startOffset + this.offsetSize;
        }
        get nextSibling() {
          const t = this.index;
          return (t !== null && this.parent.getChild(t + 1)) || null;
        }
        get previousSibling() {
          const t = this.index;
          return (t !== null && this.parent.getChild(t - 1)) || null;
        }
        get root() {
          let t = this;
          while (t.parent) {
            t = t.parent;
          }
          return t;
        }
        isAttached() {
          return this.parent === null ? false : this.root.isAttached();
        }
        getPath() {
          const t = [];
          let e = this;
          while (e.parent) {
            t.unshift(e.startOffset);
            e = e.parent;
          }
          return t;
        }
        getAncestors(t = {}) {
          const e = [];
          let n = t.includeSelf ? this : this.parent;
          while (n) {
            e[t.parentFirst ? "push" : "unshift"](n);
            n = n.parent;
          }
          return e;
        }
        getCommonAncestor(t, e = {}) {
          const n = this.getAncestors(e);
          const o = t.getAncestors(e);
          let i = 0;
          while (n[i] == o[i] && n[i]) {
            i++;
          }
          return i === 0 ? null : n[i - 1];
        }
        isBefore(t) {
          if (this == t) {
            return false;
          }
          if (this.root !== t.root) {
            return false;
          }
          const e = this.getPath();
          const n = t.getPath();
          const o = At(e, n);
          switch (o) {
            case "prefix":
              return true;
            case "extension":
              return false;
            default:
              return e[o] < n[o];
          }
        }
        isAfter(t) {
          if (this == t) {
            return false;
          }
          if (this.root !== t.root) {
            return false;
          }
          return !this.isBefore(t);
        }
        hasAttribute(t) {
          return this._attrs.has(t);
        }
        getAttribute(t) {
          return this._attrs.get(t);
        }
        getAttributes() {
          return this._attrs.entries();
        }
        getAttributeKeys() {
          return this._attrs.keys();
        }
        toJSON() {
          const t = {};
          if (this._attrs.size) {
            t.attributes = Array.from(this._attrs).reduce((t, e) => {
              t[e[0]] = e[1];
              return t;
            }, {});
          }
          return t;
        }
        _clone(t) {
          return new this.constructor(this._attrs);
        }
        _remove() {
          this.parent._removeChildren(this.index);
        }
        _setAttribute(t, e) {
          this._attrs.set(t, e);
        }
        _setAttributesTo(t) {
          this._attrs = pl(t);
        }
        _removeAttribute(t) {
          return this._attrs.delete(t);
        }
        _clearAttributes() {
          this._attrs.clear();
        }
      }
      Sk.prototype.is = function (t) {
        return t === "node" || t === "model:node";
      };
      class Tk {
        constructor(t) {
          this._nodes = [];
          if (t) {
            this._insertNodes(0, t);
          }
        }
        [Symbol.iterator]() {
          return this._nodes[Symbol.iterator]();
        }
        get length() {
          return this._nodes.length;
        }
        get maxOffset() {
          return this._nodes.reduce((t, e) => t + e.offsetSize, 0);
        }
        getNode(t) {
          return this._nodes[t] || null;
        }
        getNodeIndex(t) {
          const e = this._nodes.indexOf(t);
          return e == -1 ? null : e;
        }
        getNodeStartOffset(t) {
          const e = this.getNodeIndex(t);
          return e === null ? null : this._nodes.slice(0, e).reduce((t, e) => t + e.offsetSize, 0);
        }
        indexToOffset(t) {
          if (t == this._nodes.length) {
            return this.maxOffset;
          }
          const e = this._nodes[t];
          if (!e) {
            throw new P("model-nodelist-index-out-of-bounds", this);
          }
          return this.getNodeStartOffset(e);
        }
        offsetToIndex(t) {
          let e = 0;
          for (const n of this._nodes) {
            if (t >= e && t < e + n.offsetSize) {
              return this.getNodeIndex(n);
            }
            e += n.offsetSize;
          }
          if (e != t) {
            throw new P("model-nodelist-offset-out-of-bounds", this, { offset: t, nodeList: this });
          }
          return this.length;
        }
        _insertNodes(t, e) {
          for (const t of e) {
            if (!(t instanceof Sk)) {
              throw new P("model-nodelist-insertnodes-not-node", this);
            }
          }
          this._nodes = ml(this._nodes, Array.from(e), t, 0);
        }
        _removeNodes(t, e = 1) {
          return this._nodes.splice(t, e);
        }
        toJSON() {
          return this._nodes.map((t) => t.toJSON());
        }
      }
      class Pk extends Sk {
        constructor(t, e) {
          super(e);
          this._data = t || "";
        }
        get offsetSize() {
          return this.data.length;
        }
        get data() {
          return this._data;
        }
        toJSON() {
          const t = super.toJSON();
          t.data = this.data;
          return t;
        }
        _clone() {
          return new Pk(this.data, this.getAttributes());
        }
        static fromJSON(t) {
          return new Pk(t.data, t.attributes);
        }
      }
      Pk.prototype.is = function (t) {
        return (
          t === "$text" ||
          t === "model:$text" ||
          t === "text" ||
          t === "model:text" ||
          t === "node" ||
          t === "model:node"
        );
      };
      class Bk extends Dk {
        constructor(t, e, n) {
          super();
          this.textNode = t;
          if (e < 0 || e > t.offsetSize) {
            throw new P("model-textproxy-wrong-offsetintext", this);
          }
          if (n < 0 || e + n > t.offsetSize) {
            throw new P("model-textproxy-wrong-length", this);
          }
          this.data = t.data.substring(e, e + n);
          this.offsetInText = e;
        }
        get startOffset() {
          return this.textNode.startOffset !== null
            ? this.textNode.startOffset + this.offsetInText
            : null;
        }
        get offsetSize() {
          return this.data.length;
        }
        get endOffset() {
          return this.startOffset !== null ? this.startOffset + this.offsetSize : null;
        }
        get isPartial() {
          return this.offsetSize !== this.textNode.offsetSize;
        }
        get parent() {
          return this.textNode.parent;
        }
        get root() {
          return this.textNode.root;
        }
        getPath() {
          const t = this.textNode.getPath();
          if (t.length > 0) {
            t[t.length - 1] += this.offsetInText;
          }
          return t;
        }
        getAncestors(t = {}) {
          const e = [];
          let n = t.includeSelf ? this : this.parent;
          while (n) {
            e[t.parentFirst ? "push" : "unshift"](n);
            n = n.parent;
          }
          return e;
        }
        hasAttribute(t) {
          return this.textNode.hasAttribute(t);
        }
        getAttribute(t) {
          return this.textNode.getAttribute(t);
        }
        getAttributes() {
          return this.textNode.getAttributes();
        }
        getAttributeKeys() {
          return this.textNode.getAttributeKeys();
        }
      }
      Bk.prototype.is = function (t) {
        return (
          t === "$textProxy" ||
          t === "model:$textProxy" ||
          t === "textProxy" ||
          t === "model:textProxy"
        );
      };
      class Ok extends Sk {
        constructor(t, e, n) {
          super(e);
          this._children = new Tk();
          this.name = t;
          if (n) {
            this._insertChild(0, n);
          }
        }
        get childCount() {
          return this._children.length;
        }
        get maxOffset() {
          return this._children.maxOffset;
        }
        get isEmpty() {
          return this.childCount === 0;
        }
        getChild(t) {
          return this._children.getNode(t);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        getChildIndex(t) {
          return this._children.getNodeIndex(t);
        }
        getChildStartOffset(t) {
          return this._children.getNodeStartOffset(t);
        }
        offsetToIndex(t) {
          return this._children.offsetToIndex(t);
        }
        getNodeByPath(t) {
          let e = this;
          for (const n of t) {
            e = e.getChild(e.offsetToIndex(n));
          }
          return e;
        }
        findAncestor(t, e = {}) {
          let n = e.includeSelf ? this : this.parent;
          while (n) {
            if (n.name === t) {
              return n;
            }
            n = n.parent;
          }
          return null;
        }
        toJSON() {
          const t = super.toJSON();
          t.name = this.name;
          if (this._children.length > 0) {
            t.children = [];
            for (const e of this._children) {
              t.children.push(e.toJSON());
            }
          }
          return t;
        }
        _clone(t = false) {
          const e = t ? Array.from(this._children).map((t) => t._clone(true)) : undefined;
          return new Ok(this.name, this.getAttributes(), e);
        }
        _appendChild(t) {
          this._insertChild(this.childCount, t);
        }
        _insertChild(t, e) {
          const n = Rk(e);
          for (const t of n) {
            if (t.parent !== null) {
              t._remove();
            }
            t.parent = this;
          }
          this._children._insertNodes(t, n);
        }
        _removeChildren(t, e = 1) {
          const n = this._children._removeNodes(t, e);
          for (const t of n) {
            t.parent = null;
          }
          return n;
        }
        static fromJSON(t) {
          let e;
          if (t.children) {
            e = [];
            for (const n of t.children) {
              if (n.name) {
                e.push(Ok.fromJSON(n));
              } else {
                e.push(Pk.fromJSON(n));
              }
            }
          }
          return new Ok(t.name, t.attributes, e);
        }
      }
      Ok.prototype.is = function (t, e) {
        if (!e) {
          return t === "element" || t === "model:element" || t === "node" || t === "model:node";
        }
        return e === this.name && (t === "element" || t === "model:element");
      };
      function Rk(t) {
        if (typeof t == "string") {
          return [new Pk(t)];
        }
        if (!Ct(t)) {
          t = [t];
        }
        return Array.from(t).map((t) => {
          if (typeof t == "string") {
            return new Pk(t);
          }
          if (t instanceof Bk) {
            return new Pk(t.data, t.getAttributes());
          }
          return t;
        });
      }
      class Ik {
        constructor(t) {
          if (!t || (!t.boundaries && !t.startPosition)) {
            throw new P("model-tree-walker-no-start-position", null);
          }
          const e = t.direction || "forward";
          if (e != "forward" && e != "backward") {
            throw new P("model-tree-walker-unknown-direction", t, { direction: e });
          }
          this.direction = e;
          this.boundaries = t.boundaries || null;
          if (t.startPosition) {
            this._position = t.startPosition.clone();
          } else {
            this._position = Fk._createAt(
              this.boundaries[this.direction == "backward" ? "end" : "start"]
            );
          }
          this.position.stickiness = "toNone";
          this.singleCharacters = !!t.singleCharacters;
          this.shallow = !!t.shallow;
          this.ignoreElementEnd = !!t.ignoreElementEnd;
          this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;
          this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;
          this._visitedParent = this.position.parent;
        }
        [Symbol.iterator]() {
          return this;
        }
        get position() {
          return this._position;
        }
        skip(t) {
          let e, n, o, i;
          do {
            o = this.position;
            i = this._visitedParent;
            ({ done: e, value: n } = this.next());
          } while (!e && t(n));
          if (!e) {
            this._position = o;
            this._visitedParent = i;
          }
        }
        next() {
          if (this.direction == "forward") {
            return this._next();
          } else {
            return this._previous();
          }
        }
        _next() {
          const t = this.position;
          const e = this.position.clone();
          const n = this._visitedParent;
          if (n.parent === null && e.offset === n.maxOffset) {
            return { done: true, value: undefined };
          }
          if (n === this._boundaryEndParent && e.offset == this.boundaries.end.offset) {
            return { done: true, value: undefined };
          }
          const o = Mk(e, n);
          const i = o || Nk(e, n, o);
          if (i instanceof Ok) {
            if (!this.shallow) {
              e.path.push(0);
              this._visitedParent = i;
            } else {
              if (this.boundaries && this.boundaries.end.isBefore(e)) {
                return { done: true, value: undefined };
              }
              e.offset++;
            }
            this._position = e;
            return zk("elementStart", i, t, e, 1);
          }
          if (i instanceof Pk) {
            let o;
            if (this.singleCharacters) {
              o = 1;
            } else {
              let t = i.endOffset;
              if (this._boundaryEndParent == n && this.boundaries.end.offset < t) {
                t = this.boundaries.end.offset;
              }
              o = t - e.offset;
            }
            const r = e.offset - i.startOffset;
            const s = new Bk(i, r, o);
            e.offset += o;
            this._position = e;
            return zk("text", s, t, e, o);
          }
          e.path.pop();
          e.offset++;
          this._position = e;
          this._visitedParent = n.parent;
          if (this.ignoreElementEnd) {
            return this._next();
          }
          return zk("elementEnd", n, t, e);
        }
        _previous() {
          const t = this.position;
          const e = this.position.clone();
          const n = this._visitedParent;
          if (n.parent === null && e.offset === 0) {
            return { done: true, value: undefined };
          }
          if (n == this._boundaryStartParent && e.offset == this.boundaries.start.offset) {
            return { done: true, value: undefined };
          }
          const o = e.parent;
          const i = Mk(e, o);
          const r = i || Vk(e, o, i);
          if (r instanceof Ok) {
            e.offset--;
            if (this.shallow) {
              this._position = e;
              return zk("elementStart", r, t, e, 1);
            }
            e.path.push(r.maxOffset);
            this._position = e;
            this._visitedParent = r;
            if (this.ignoreElementEnd) {
              return this._previous();
            }
            return zk("elementEnd", r, t, e);
          }
          if (r instanceof Pk) {
            let o;
            if (this.singleCharacters) {
              o = 1;
            } else {
              let t = r.startOffset;
              if (this._boundaryStartParent == n && this.boundaries.start.offset > t) {
                t = this.boundaries.start.offset;
              }
              o = e.offset - t;
            }
            const i = e.offset - r.startOffset;
            const s = new Bk(r, i - o, o);
            e.offset -= o;
            this._position = e;
            return zk("text", s, t, e, o);
          }
          e.path.pop();
          this._position = e;
          this._visitedParent = n.parent;
          return zk("elementStart", n, t, e, 1);
        }
      }
      function zk(t, e, n, o, i) {
        return {
          done: false,
          value: { type: t, item: e, previousPosition: n, nextPosition: o, length: i },
        };
      }
      class Fk extends Dk {
        constructor(t, e, n = "toNone") {
          super();
          if (!t.is("element") && !t.is("documentFragment")) {
            throw new P("model-position-root-invalid", t);
          }
          if (!(e instanceof Array) || e.length === 0) {
            throw new P("model-position-path-incorrect-format", t, { path: e });
          }
          if (t.is("rootElement")) {
            e = e.slice();
          } else {
            e = [...t.getPath(), ...e];
            t = t.root;
          }
          this.root = t;
          this.path = e;
          this.stickiness = n;
        }
        get offset() {
          return this.path[this.path.length - 1];
        }
        set offset(t) {
          this.path[this.path.length - 1] = t;
        }
        get parent() {
          let t = this.root;
          for (let e = 0; e < this.path.length - 1; e++) {
            t = t.getChild(t.offsetToIndex(this.path[e]));
            if (!t) {
              throw new P("model-position-path-incorrect", this, { position: this });
            }
          }
          if (t.is("$text")) {
            throw new P("model-position-path-incorrect", this, { position: this });
          }
          return t;
        }
        get index() {
          return this.parent.offsetToIndex(this.offset);
        }
        get textNode() {
          return Mk(this, this.parent);
        }
        get nodeAfter() {
          const t = this.parent;
          return Nk(this, t, Mk(this, t));
        }
        get nodeBefore() {
          const t = this.parent;
          return Vk(this, t, Mk(this, t));
        }
        get isAtStart() {
          return this.offset === 0;
        }
        get isAtEnd() {
          return this.offset == this.parent.maxOffset;
        }
        compareWith(t) {
          if (this.root != t.root) {
            return "different";
          }
          const e = At(this.path, t.path);
          switch (e) {
            case "same":
              return "same";
            case "prefix":
              return "before";
            case "extension":
              return "after";
            default:
              return this.path[e] < t.path[e] ? "before" : "after";
          }
        }
        getLastMatchingPosition(t, e = {}) {
          e.startPosition = this;
          const n = new Ik(e);
          n.skip(t);
          return n.position;
        }
        getParentPath() {
          return this.path.slice(0, -1);
        }
        getAncestors() {
          const t = this.parent;
          if (t.is("documentFragment")) {
            return [t];
          } else {
            return t.getAncestors({ includeSelf: true });
          }
        }
        findAncestor(t) {
          const e = this.parent;
          if (e.is("element")) {
            return e.findAncestor(t, { includeSelf: true });
          }
          return null;
        }
        getCommonPath(t) {
          if (this.root != t.root) {
            return [];
          }
          const e = At(this.path, t.path);
          const n = typeof e == "string" ? Math.min(this.path.length, t.path.length) : e;
          return this.path.slice(0, n);
        }
        getCommonAncestor(t) {
          const e = this.getAncestors();
          const n = t.getAncestors();
          let o = 0;
          while (e[o] == n[o] && e[o]) {
            o++;
          }
          return o === 0 ? null : e[o - 1];
        }
        getShiftedBy(t) {
          const e = this.clone();
          const n = e.offset + t;
          e.offset = n < 0 ? 0 : n;
          return e;
        }
        isAfter(t) {
          return this.compareWith(t) == "after";
        }
        isBefore(t) {
          return this.compareWith(t) == "before";
        }
        isEqual(t) {
          return this.compareWith(t) == "same";
        }
        isTouching(t) {
          if (this.root !== t.root) {
            return false;
          }
          const e = Math.min(this.path.length, t.path.length);
          for (let n = 0; n < e; n++) {
            const e = this.path[n] - t.path[n];
            if (e < -1 || e > 1) {
              return false;
            } else if (e === 1) {
              return Lk(t, this, n);
            } else if (e === -1) {
              return Lk(this, t, n);
            }
          }
          if (this.path.length === t.path.length) {
            return true;
          } else if (this.path.length > t.path.length) {
            return Hk(this.path, e);
          } else {
            return Hk(t.path, e);
          }
        }
        hasSameParentAs(t) {
          if (this.root !== t.root) {
            return false;
          }
          const e = this.getParentPath();
          const n = t.getParentPath();
          return At(e, n) == "same";
        }
        getTransformedByOperation(t) {
          let e;
          switch (t.type) {
            case "insert":
              e = this._getTransformedByInsertOperation(t);
              break;
            case "move":
            case "remove":
            case "reinsert":
              e = this._getTransformedByMoveOperation(t);
              break;
            case "split":
              e = this._getTransformedBySplitOperation(t);
              break;
            case "merge":
              e = this._getTransformedByMergeOperation(t);
              break;
            default:
              e = Fk._createAt(this);
              break;
          }
          return e;
        }
        _getTransformedByInsertOperation(t) {
          return this._getTransformedByInsertion(t.position, t.howMany);
        }
        _getTransformedByMoveOperation(t) {
          return this._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany);
        }
        _getTransformedBySplitOperation(t) {
          const e = t.movedRange;
          const n =
            e.containsPosition(this) || (e.start.isEqual(this) && this.stickiness == "toNext");
          if (n) {
            return this._getCombined(t.splitPosition, t.moveTargetPosition);
          } else {
            if (t.graveyardPosition) {
              return this._getTransformedByMove(t.graveyardPosition, t.insertionPosition, 1);
            } else {
              return this._getTransformedByInsertion(t.insertionPosition, 1);
            }
          }
        }
        _getTransformedByMergeOperation(t) {
          const e = t.movedRange;
          const n = e.containsPosition(this) || e.start.isEqual(this);
          let o;
          if (n) {
            o = this._getCombined(t.sourcePosition, t.targetPosition);
            if (t.sourcePosition.isBefore(t.targetPosition)) {
              o = o._getTransformedByDeletion(t.deletionPosition, 1);
            }
          } else if (this.isEqual(t.deletionPosition)) {
            o = Fk._createAt(t.deletionPosition);
          } else {
            o = this._getTransformedByMove(t.deletionPosition, t.graveyardPosition, 1);
          }
          return o;
        }
        _getTransformedByDeletion(t, e) {
          const n = Fk._createAt(this);
          if (this.root != t.root) {
            return n;
          }
          if (At(t.getParentPath(), this.getParentPath()) == "same") {
            if (t.offset < this.offset) {
              if (t.offset + e > this.offset) {
                return null;
              } else {
                n.offset -= e;
              }
            }
          } else if (At(t.getParentPath(), this.getParentPath()) == "prefix") {
            const o = t.path.length - 1;
            if (t.offset <= this.path[o]) {
              if (t.offset + e > this.path[o]) {
                return null;
              } else {
                n.path[o] -= e;
              }
            }
          }
          return n;
        }
        _getTransformedByInsertion(t, e) {
          const n = Fk._createAt(this);
          if (this.root != t.root) {
            return n;
          }
          if (At(t.getParentPath(), this.getParentPath()) == "same") {
            if (
              t.offset < this.offset ||
              (t.offset == this.offset && this.stickiness != "toPrevious")
            ) {
              n.offset += e;
            }
          } else if (At(t.getParentPath(), this.getParentPath()) == "prefix") {
            const o = t.path.length - 1;
            if (t.offset <= this.path[o]) {
              n.path[o] += e;
            }
          }
          return n;
        }
        _getTransformedByMove(t, e, n) {
          e = e._getTransformedByDeletion(t, n);
          if (t.isEqual(e)) {
            return Fk._createAt(this);
          }
          const o = this._getTransformedByDeletion(t, n);
          const i =
            o === null ||
            (t.isEqual(this) && this.stickiness == "toNext") ||
            (t.getShiftedBy(n).isEqual(this) && this.stickiness == "toPrevious");
          if (i) {
            return this._getCombined(t, e);
          } else {
            return o._getTransformedByInsertion(e, n);
          }
        }
        _getCombined(t, e) {
          const n = t.path.length - 1;
          const o = Fk._createAt(e);
          o.stickiness = this.stickiness;
          o.offset = o.offset + this.path[n] - t.offset;
          o.path = [...o.path, ...this.path.slice(n + 1)];
          return o;
        }
        toJSON() {
          return {
            root: this.root.toJSON(),
            path: Array.from(this.path),
            stickiness: this.stickiness,
          };
        }
        clone() {
          return new this.constructor(this.root, this.path, this.stickiness);
        }
        static _createAt(t, e, n = "toNone") {
          if (t instanceof Fk) {
            return new Fk(t.root, t.path, t.stickiness);
          } else {
            const o = t;
            if (e == "end") {
              e = o.maxOffset;
            } else if (e == "before") {
              return this._createBefore(o, n);
            } else if (e == "after") {
              return this._createAfter(o, n);
            } else if (e !== 0 && !e) {
              throw new P("model-createpositionat-offset-required", [this, t]);
            }
            if (!o.is("element") && !o.is("documentFragment")) {
              throw new P("model-position-parent-incorrect", [this, t]);
            }
            const i = o.getPath();
            i.push(e);
            return new this(o.root, i, n);
          }
        }
        static _createAfter(t, e) {
          if (!t.parent) {
            throw new P("model-position-after-root", [this, t], { root: t });
          }
          return this._createAt(t.parent, t.endOffset, e);
        }
        static _createBefore(t, e) {
          if (!t.parent) {
            throw new P("model-position-before-root", t, { root: t });
          }
          return this._createAt(t.parent, t.startOffset, e);
        }
        static fromJSON(t, e) {
          if (t.root === "$graveyard") {
            const n = new Fk(e.graveyard, t.path);
            n.stickiness = t.stickiness;
            return n;
          }
          if (!e.getRoot(t.root)) {
            throw new P("model-position-fromjson-no-root", e, { rootName: t.root });
          }
          return new Fk(e.getRoot(t.root), t.path, t.stickiness);
        }
      }
      Fk.prototype.is = function (t) {
        return t === "position" || t === "model:position";
      };
      function Mk(t, e) {
        const n = e.getChild(e.offsetToIndex(t.offset));
        if (n && n.is("$text") && n.startOffset < t.offset) {
          return n;
        }
        return null;
      }
      function Nk(t, e, n) {
        if (n !== null) {
          return null;
        }
        return e.getChild(e.offsetToIndex(t.offset));
      }
      function Vk(t, e, n) {
        if (n !== null) {
          return null;
        }
        return e.getChild(e.offsetToIndex(t.offset) - 1);
      }
      function Lk(t, e, n) {
        if (n + 1 === t.path.length) {
          return false;
        }
        if (!Hk(e.path, n + 1)) {
          return false;
        }
        if (!jk(t, n + 1)) {
          return false;
        }
        return true;
      }
      function Hk(t, e) {
        while (e < t.length) {
          if (t[e] !== 0) {
            return false;
          }
          e++;
        }
        return true;
      }
      function jk(t, e) {
        let n = t.parent;
        let o = t.path.length - 1;
        let i = 0;
        while (o >= e) {
          if (t.path[o] + i !== n.maxOffset) {
            return false;
          }
          i = 1;
          o--;
          n = n.parent;
        }
        return true;
      }
      class qk extends Dk {
        constructor(t, e) {
          super();
          this.start = Fk._createAt(t);
          this.end = e ? Fk._createAt(e) : Fk._createAt(t);
          this.start.stickiness = this.isCollapsed ? "toNone" : "toNext";
          this.end.stickiness = this.isCollapsed ? "toNone" : "toPrevious";
        }
        *[Symbol.iterator]() {
          yield* new Ik({ boundaries: this, ignoreElementEnd: true });
        }
        get isCollapsed() {
          return this.start.isEqual(this.end);
        }
        get isFlat() {
          const t = this.start.getParentPath();
          const e = this.end.getParentPath();
          return At(t, e) == "same";
        }
        get root() {
          return this.start.root;
        }
        containsPosition(t) {
          return t.isAfter(this.start) && t.isBefore(this.end);
        }
        containsRange(t, e = false) {
          if (t.isCollapsed) {
            e = false;
          }
          const n = this.containsPosition(t.start) || (e && this.start.isEqual(t.start));
          const o = this.containsPosition(t.end) || (e && this.end.isEqual(t.end));
          return n && o;
        }
        containsItem(t) {
          const e = Fk._createBefore(t);
          return this.containsPosition(e) || this.start.isEqual(e);
        }
        isEqual(t) {
          return this.start.isEqual(t.start) && this.end.isEqual(t.end);
        }
        isIntersecting(t) {
          return this.start.isBefore(t.end) && this.end.isAfter(t.start);
        }
        getDifference(t) {
          const e = [];
          if (this.isIntersecting(t)) {
            if (this.containsPosition(t.start)) {
              e.push(new qk(this.start, t.start));
            }
            if (this.containsPosition(t.end)) {
              e.push(new qk(t.end, this.end));
            }
          } else {
            e.push(new qk(this.start, this.end));
          }
          return e;
        }
        getIntersection(t) {
          if (this.isIntersecting(t)) {
            let e = this.start;
            let n = this.end;
            if (this.containsPosition(t.start)) {
              e = t.start;
            }
            if (this.containsPosition(t.end)) {
              n = t.end;
            }
            return new qk(e, n);
          }
          return null;
        }
        getJoined(t, e = false) {
          let n = this.isIntersecting(t);
          if (!n) {
            if (this.start.isBefore(t.start)) {
              n = e ? this.end.isTouching(t.start) : this.end.isEqual(t.start);
            } else {
              n = e ? t.end.isTouching(this.start) : t.end.isEqual(this.start);
            }
          }
          if (!n) {
            return null;
          }
          let o = this.start;
          let i = this.end;
          if (t.start.isBefore(o)) {
            o = t.start;
          }
          if (t.end.isAfter(i)) {
            i = t.end;
          }
          return new qk(o, i);
        }
        getMinimalFlatRanges() {
          const t = [];
          const e = this.start.getCommonPath(this.end).length;
          const n = Fk._createAt(this.start);
          let o = n.parent;
          while (n.path.length > e + 1) {
            const e = o.maxOffset - n.offset;
            if (e !== 0) {
              t.push(new qk(n, n.getShiftedBy(e)));
            }
            n.path = n.path.slice(0, -1);
            n.offset++;
            o = o.parent;
          }
          while (n.path.length <= this.end.path.length) {
            const e = this.end.path[n.path.length - 1];
            const o = e - n.offset;
            if (o !== 0) {
              t.push(new qk(n, n.getShiftedBy(o)));
            }
            n.offset = e;
            n.path.push(0);
          }
          return t;
        }
        getWalker(t = {}) {
          t.boundaries = this;
          return new Ik(t);
        }
        *getItems(t = {}) {
          t.boundaries = this;
          t.ignoreElementEnd = true;
          const e = new Ik(t);
          for (const t of e) {
            yield t.item;
          }
        }
        *getPositions(t = {}) {
          t.boundaries = this;
          const e = new Ik(t);
          yield e.position;
          for (const t of e) {
            yield t.nextPosition;
          }
        }
        getTransformedByOperation(t) {
          switch (t.type) {
            case "insert":
              return this._getTransformedByInsertOperation(t);
            case "move":
            case "remove":
            case "reinsert":
              return this._getTransformedByMoveOperation(t);
            case "split":
              return [this._getTransformedBySplitOperation(t)];
            case "merge":
              return [this._getTransformedByMergeOperation(t)];
          }
          return [new qk(this.start, this.end)];
        }
        getTransformedByOperations(t) {
          const e = [new qk(this.start, this.end)];
          for (const n of t) {
            for (let t = 0; t < e.length; t++) {
              const o = e[t].getTransformedByOperation(n);
              e.splice(t, 1, ...o);
              t += o.length - 1;
            }
          }
          for (let t = 0; t < e.length; t++) {
            const n = e[t];
            for (let o = t + 1; o < e.length; o++) {
              const t = e[o];
              if (n.containsRange(t) || t.containsRange(n) || n.isEqual(t)) {
                e.splice(o, 1);
              }
            }
          }
          return e;
        }
        getCommonAncestor() {
          return this.start.getCommonAncestor(this.end);
        }
        getContainedElement() {
          if (this.isCollapsed) {
            return null;
          }
          const t = this.start.nodeAfter;
          const e = this.end.nodeBefore;
          if (t && t.is("element") && t === e) {
            return t;
          }
          return null;
        }
        toJSON() {
          return { start: this.start.toJSON(), end: this.end.toJSON() };
        }
        clone() {
          return new this.constructor(this.start, this.end);
        }
        _getTransformedByInsertOperation(t, e = false) {
          return this._getTransformedByInsertion(t.position, t.howMany, e);
        }
        _getTransformedByMoveOperation(t, e = false) {
          const n = t.sourcePosition;
          const o = t.howMany;
          const i = t.targetPosition;
          return this._getTransformedByMove(n, i, o, e);
        }
        _getTransformedBySplitOperation(t) {
          const e = this.start._getTransformedBySplitOperation(t);
          let n = this.end._getTransformedBySplitOperation(t);
          if (this.end.isEqual(t.insertionPosition)) {
            n = this.end.getShiftedBy(1);
          }
          if (e.root != n.root) {
            n = this.end.getShiftedBy(-1);
          }
          return new qk(e, n);
        }
        _getTransformedByMergeOperation(t) {
          if (this.start.isEqual(t.targetPosition) && this.end.isEqual(t.deletionPosition)) {
            return new qk(this.start);
          }
          let e = this.start._getTransformedByMergeOperation(t);
          let n = this.end._getTransformedByMergeOperation(t);
          if (e.root != n.root) {
            n = this.end.getShiftedBy(-1);
          }
          if (e.isAfter(n)) {
            if (t.sourcePosition.isBefore(t.targetPosition)) {
              e = Fk._createAt(n);
              e.offset = 0;
            } else {
              if (!t.deletionPosition.isEqual(e)) {
                n = t.deletionPosition;
              }
              e = t.targetPosition;
            }
            return new qk(e, n);
          }
          return new qk(e, n);
        }
        _getTransformedByInsertion(t, e, n = false) {
          if (n && this.containsPosition(t)) {
            return [
              new qk(this.start, t),
              new qk(t.getShiftedBy(e), this.end._getTransformedByInsertion(t, e)),
            ];
          } else {
            const n = new qk(this.start, this.end);
            n.start = n.start._getTransformedByInsertion(t, e);
            n.end = n.end._getTransformedByInsertion(t, e);
            return [n];
          }
        }
        _getTransformedByMove(t, e, n, o = false) {
          if (this.isCollapsed) {
            const o = this.start._getTransformedByMove(t, e, n);
            return [new qk(o)];
          }
          const i = qk._createFromPositionAndShift(t, n);
          const r = e._getTransformedByDeletion(t, n);
          if (this.containsPosition(e) && !o) {
            if (i.containsPosition(this.start) || i.containsPosition(this.end)) {
              const o = this.start._getTransformedByMove(t, e, n);
              const i = this.end._getTransformedByMove(t, e, n);
              return [new qk(o, i)];
            }
          }
          let s;
          const a = this.getDifference(i);
          let c = null;
          const l = this.getIntersection(i);
          if (a.length == 1) {
            c = new qk(
              a[0].start._getTransformedByDeletion(t, n),
              a[0].end._getTransformedByDeletion(t, n)
            );
          } else if (a.length == 2) {
            c = new qk(this.start, this.end._getTransformedByDeletion(t, n));
          }
          if (c) {
            s = c._getTransformedByInsertion(r, n, l !== null || o);
          } else {
            s = [];
          }
          if (l) {
            const t = new qk(l.start._getCombined(i.start, r), l.end._getCombined(i.start, r));
            if (s.length == 2) {
              s.splice(1, 0, t);
            } else {
              s.push(t);
            }
          }
          return s;
        }
        _getTransformedByDeletion(t, e) {
          let n = this.start._getTransformedByDeletion(t, e);
          let o = this.end._getTransformedByDeletion(t, e);
          if (n == null && o == null) {
            return null;
          }
          if (n == null) {
            n = t;
          }
          if (o == null) {
            o = t;
          }
          return new qk(n, o);
        }
        static _createFromPositionAndShift(t, e) {
          const n = t;
          const o = t.getShiftedBy(e);
          return e > 0 ? new this(n, o) : new this(o, n);
        }
        static _createIn(t) {
          return new this(Fk._createAt(t, 0), Fk._createAt(t, t.maxOffset));
        }
        static _createOn(t) {
          return this._createFromPositionAndShift(Fk._createBefore(t), t.offsetSize);
        }
        static _createFromRanges(t) {
          if (t.length === 0) {
            throw new P("range-create-from-ranges-empty-array", null);
          } else if (t.length == 1) {
            return t[0].clone();
          }
          const e = t[0];
          t.sort((t, e) => (t.start.isAfter(e.start) ? 1 : -1));
          const n = t.indexOf(e);
          const o = new this(e.start, e.end);
          if (n > 0) {
            for (let e = n - 1; true; e++) {
              if (t[e].end.isEqual(o.start)) {
                o.start = Fk._createAt(t[e].start);
              } else {
                break;
              }
            }
          }
          for (let e = n + 1; e < t.length; e++) {
            if (t[e].start.isEqual(o.end)) {
              o.end = Fk._createAt(t[e].end);
            } else {
              break;
            }
          }
          return o;
        }
        static fromJSON(t, e) {
          return new this(Fk.fromJSON(t.start, e), Fk.fromJSON(t.end, e));
        }
      }
      qk.prototype.is = function (t) {
        return t === "range" || t === "model:range";
      };
      class $k extends q() {
        constructor() {
          super();
          this._modelToViewMapping = new WeakMap();
          this._viewToModelMapping = new WeakMap();
          this._viewToModelLengthCallbacks = new Map();
          this._markerNameToElements = new Map();
          this._elementToMarkerNames = new Map();
          this._deferredBindingRemovals = new Map();
          this._unboundMarkerNames = new Set();
          this.on(
            "modelToViewPosition",
            (t, e) => {
              if (e.viewPosition) {
                return;
              }
              const n = this._modelToViewMapping.get(e.modelPosition.parent);
              if (!n) {
                throw new P("mapping-model-position-view-parent-not-found", this, {
                  modelPosition: e.modelPosition,
                });
              }
              e.viewPosition = this.findPositionIn(n, e.modelPosition.offset);
            },
            { priority: "low" }
          );
          this.on(
            "viewToModelPosition",
            (t, e) => {
              if (e.modelPosition) {
                return;
              }
              const n = this.findMappedViewAncestor(e.viewPosition);
              const o = this._viewToModelMapping.get(n);
              const i = this._toModelOffset(e.viewPosition.parent, e.viewPosition.offset, n);
              e.modelPosition = Fk._createAt(o, i);
            },
            { priority: "low" }
          );
        }
        bindElements(t, e) {
          this._modelToViewMapping.set(t, e);
          this._viewToModelMapping.set(e, t);
        }
        unbindViewElement(t, e = {}) {
          const n = this.toModelElement(t);
          if (this._elementToMarkerNames.has(t)) {
            for (const e of this._elementToMarkerNames.get(t)) {
              this._unboundMarkerNames.add(e);
            }
          }
          if (e.defer) {
            this._deferredBindingRemovals.set(t, t.root);
          } else {
            this._viewToModelMapping.delete(t);
            if (this._modelToViewMapping.get(n) == t) {
              this._modelToViewMapping.delete(n);
            }
          }
        }
        unbindModelElement(t) {
          const e = this.toViewElement(t);
          this._modelToViewMapping.delete(t);
          if (this._viewToModelMapping.get(e) == t) {
            this._viewToModelMapping.delete(e);
          }
        }
        bindElementToMarker(t, e) {
          const n = this._markerNameToElements.get(e) || new Set();
          n.add(t);
          const o = this._elementToMarkerNames.get(t) || new Set();
          o.add(e);
          this._markerNameToElements.set(e, n);
          this._elementToMarkerNames.set(t, o);
        }
        unbindElementFromMarkerName(t, e) {
          const n = this._markerNameToElements.get(e);
          if (n) {
            n.delete(t);
            if (n.size == 0) {
              this._markerNameToElements.delete(e);
            }
          }
          const o = this._elementToMarkerNames.get(t);
          if (o) {
            o.delete(e);
            if (o.size == 0) {
              this._elementToMarkerNames.delete(t);
            }
          }
        }
        flushUnboundMarkerNames() {
          const t = Array.from(this._unboundMarkerNames);
          this._unboundMarkerNames.clear();
          return t;
        }
        flushDeferredBindings() {
          for (const [t, e] of this._deferredBindingRemovals) {
            if (t.root == e) {
              this.unbindViewElement(t);
            }
          }
          this._deferredBindingRemovals = new Map();
        }
        clearBindings() {
          this._modelToViewMapping = new WeakMap();
          this._viewToModelMapping = new WeakMap();
          this._markerNameToElements = new Map();
          this._elementToMarkerNames = new Map();
          this._unboundMarkerNames = new Set();
          this._deferredBindingRemovals = new Map();
        }
        toModelElement(t) {
          return this._viewToModelMapping.get(t);
        }
        toViewElement(t) {
          return this._modelToViewMapping.get(t);
        }
        toModelRange(t) {
          return new qk(this.toModelPosition(t.start), this.toModelPosition(t.end));
        }
        toViewRange(t) {
          return new Vp(this.toViewPosition(t.start), this.toViewPosition(t.end));
        }
        toModelPosition(t) {
          const e = { viewPosition: t, mapper: this };
          this.fire("viewToModelPosition", e);
          return e.modelPosition;
        }
        toViewPosition(t, e = {}) {
          const n = { modelPosition: t, mapper: this, isPhantom: e.isPhantom };
          this.fire("modelToViewPosition", n);
          return n.viewPosition;
        }
        markerNameToElements(t) {
          const e = this._markerNameToElements.get(t);
          if (!e) {
            return null;
          }
          const n = new Set();
          for (const t of e) {
            if (t.is("attributeElement")) {
              for (const e of t.getElementsWithSameId()) {
                n.add(e);
              }
            } else {
              n.add(t);
            }
          }
          return n;
        }
        registerViewToModelLength(t, e) {
          this._viewToModelLengthCallbacks.set(t, e);
        }
        findMappedViewAncestor(t) {
          let e = t.parent;
          while (!this._viewToModelMapping.has(e)) {
            e = e.parent;
          }
          return e;
        }
        _toModelOffset(t, e, n) {
          if (n != t) {
            const o = this._toModelOffset(t.parent, t.index, n);
            const i = this._toModelOffset(t, e, t);
            return o + i;
          }
          if (t.is("$text")) {
            return e;
          }
          let o = 0;
          for (let n = 0; n < e; n++) {
            o += this.getModelLength(t.getChild(n));
          }
          return o;
        }
        getModelLength(t) {
          if (this._viewToModelLengthCallbacks.get(t.name)) {
            const e = this._viewToModelLengthCallbacks.get(t.name);
            return e(t);
          } else if (this._viewToModelMapping.has(t)) {
            return 1;
          } else if (t.is("$text")) {
            return t.data.length;
          } else if (t.is("uiElement")) {
            return 0;
          } else {
            let e = 0;
            for (const n of t.getChildren()) {
              e += this.getModelLength(n);
            }
            return e;
          }
        }
        findPositionIn(t, e) {
          let n;
          let o = 0;
          let i = 0;
          let r = 0;
          if (t.is("$text")) {
            return new Np(t, e);
          }
          while (i < e) {
            n = t.getChild(r);
            o = this.getModelLength(n);
            i += o;
            r++;
          }
          if (i == e) {
            return this._moveViewPositionToTextNode(new Np(t, r));
          } else {
            return this.findPositionIn(n, e - (i - o));
          }
        }
        _moveViewPositionToTextNode(t) {
          const e = t.nodeBefore;
          const n = t.nodeAfter;
          if (e instanceof Pu) {
            return new Np(e, e.data.length);
          } else if (n instanceof Pu) {
            return new Np(n, 0);
          }
          return t;
        }
      }
      class Wk {
        constructor() {
          this._consumable = new Map();
          this._textProxyRegistry = new Map();
        }
        add(t, e) {
          e = Gk(e);
          if (t instanceof Bk) {
            t = this._getSymbolForTextProxy(t);
          }
          if (!this._consumable.has(t)) {
            this._consumable.set(t, new Map());
          }
          this._consumable.get(t).set(e, true);
        }
        consume(t, e) {
          e = Gk(e);
          if (t instanceof Bk) {
            t = this._getSymbolForTextProxy(t);
          }
          if (this.test(t, e)) {
            this._consumable.get(t).set(e, false);
            return true;
          } else {
            return false;
          }
        }
        test(t, e) {
          e = Gk(e);
          if (t instanceof Bk) {
            t = this._getSymbolForTextProxy(t);
          }
          const n = this._consumable.get(t);
          if (n === undefined) {
            return null;
          }
          const o = n.get(e);
          if (o === undefined) {
            return null;
          }
          return o;
        }
        revert(t, e) {
          e = Gk(e);
          if (t instanceof Bk) {
            t = this._getSymbolForTextProxy(t);
          }
          const n = this.test(t, e);
          if (n === false) {
            this._consumable.get(t).set(e, true);
            return true;
          } else if (n === true) {
            return false;
          }
          return null;
        }
        verifyAllConsumed(t) {
          const e = [];
          for (const [n, o] of this._consumable) {
            for (const [i, r] of o) {
              const o = i.split(":")[0];
              if (r && t == o) {
                e.push({ event: i, item: n.name || n.description });
              }
            }
          }
          if (e.length) {
            throw new P("conversion-model-consumable-not-consumed", null, { items: e });
          }
        }
        _getSymbolForTextProxy(t) {
          let e = null;
          const n = this._textProxyRegistry.get(t.startOffset);
          if (n) {
            const o = n.get(t.endOffset);
            if (o) {
              e = o.get(t.parent);
            }
          }
          if (!e) {
            e = this._addSymbolForTextProxy(t);
          }
          return e;
        }
        _addSymbolForTextProxy(t) {
          const e = t.startOffset;
          const n = t.endOffset;
          const o = t.parent;
          const i = Symbol("$textProxy:" + t.data);
          let r;
          let s;
          r = this._textProxyRegistry.get(e);
          if (!r) {
            r = new Map();
            this._textProxyRegistry.set(e, r);
          }
          s = r.get(n);
          if (!s) {
            s = new Map();
            r.set(n, s);
          }
          s.set(o, i);
          return i;
        }
      }
      function Gk(t) {
        const e = t.split(":");
        if (e[0] == "insert") {
          return e[0];
        }
        if (e[0] == "addMarker" || e[0] == "removeMarker") {
          return t;
        }
        return e.length > 1 ? e[0] + ":" + e[1] : e[0];
      }
      class Kk extends q() {
        constructor(t) {
          super();
          this._conversionApi = { dispatcher: this, ...t };
          this._firedEventsMap = new WeakMap();
        }
        convertChanges(t, e, n) {
          const o = this._createConversionApi(n, t.getRefreshedItems());
          for (const e of t.getMarkersToRemove()) {
            this._convertMarkerRemove(e.name, e.range, o);
          }
          const i = this._reduceChanges(t.getChanges());
          for (const t of i) {
            if (t.type === "insert") {
              this._convertInsert(qk._createFromPositionAndShift(t.position, t.length), o);
            } else if (t.type === "reinsert") {
              this._convertReinsert(qk._createFromPositionAndShift(t.position, t.length), o);
            } else if (t.type === "remove") {
              this._convertRemove(t.position, t.length, t.name, o);
            } else {
              this._convertAttribute(
                t.range,
                t.attributeKey,
                t.attributeOldValue,
                t.attributeNewValue,
                o
              );
            }
          }
          for (const t of o.mapper.flushUnboundMarkerNames()) {
            const n = e.get(t).getRange();
            this._convertMarkerRemove(t, n, o);
            this._convertMarkerAdd(t, n, o);
          }
          for (const e of t.getMarkersToAdd()) {
            this._convertMarkerAdd(e.name, e.range, o);
          }
          o.mapper.flushDeferredBindings();
          o.consumable.verifyAllConsumed("insert");
        }
        convert(t, e, n, o = {}) {
          const i = this._createConversionApi(n, undefined, o);
          this._convertInsert(t, i);
          for (const [t, n] of e) {
            this._convertMarkerAdd(t, n, i);
          }
          i.consumable.verifyAllConsumed("insert");
        }
        convertSelection(t, e, n) {
          const o = this._createConversionApi(n);
          this.fire("cleanSelection", { selection: t }, o);
          const i = t.getFirstPosition().root;
          if (!o.mapper.toViewElement(i)) {
            return;
          }
          const r = Array.from(e.getMarkersAtPosition(t.getFirstPosition()));
          this._addConsumablesForSelection(o.consumable, t, r);
          this.fire("selection", { selection: t }, o);
          if (!t.isCollapsed) {
            return;
          }
          for (const e of r) {
            if (o.consumable.test(t, "addMarker:" + e.name)) {
              const n = e.getRange();
              if (!Uk(t.getFirstPosition(), e, o.mapper)) {
                continue;
              }
              const i = { item: t, markerName: e.name, markerRange: n };
              this.fire(`addMarker:${e.name}`, i, o);
            }
          }
          for (const e of t.getAttributeKeys()) {
            if (o.consumable.test(t, "attribute:" + e)) {
              const n = {
                item: t,
                range: t.getFirstRange(),
                attributeKey: e,
                attributeOldValue: null,
                attributeNewValue: t.getAttribute(e),
              };
              this.fire(`attribute:${e}:$text`, n, o);
            }
          }
        }
        _convertInsert(t, e, n = {}) {
          if (!n.doNotAddConsumables) {
            this._addConsumablesForInsert(e.consumable, Array.from(t));
          }
          for (const n of Array.from(t.getWalker({ shallow: true })).map(Jk)) {
            this._testAndFire("insert", n, e);
          }
        }
        _convertRemove(t, e, n, o) {
          this.fire(`remove:${n}`, { position: t, length: e }, o);
        }
        _convertAttribute(t, e, n, o, i) {
          this._addConsumablesForRange(i.consumable, t, `attribute:${e}`);
          for (const r of t) {
            const t = {
              item: r.item,
              range: qk._createFromPositionAndShift(r.previousPosition, r.length),
              attributeKey: e,
              attributeOldValue: n,
              attributeNewValue: o,
            };
            this._testAndFire(`attribute:${e}`, t, i);
          }
        }
        _convertReinsert(t, e) {
          const n = Array.from(t.getWalker({ shallow: true }));
          this._addConsumablesForInsert(e.consumable, n);
          for (const t of n.map(Jk)) {
            this._testAndFire("insert", { ...t, reconversion: true }, e);
          }
        }
        _convertMarkerAdd(t, e, n) {
          if (e.root.rootName == "$graveyard") {
            return;
          }
          const o = `addMarker:${t}`;
          n.consumable.add(e, o);
          this.fire(o, { markerName: t, markerRange: e }, n);
          if (!n.consumable.consume(e, o)) {
            return;
          }
          this._addConsumablesForRange(n.consumable, e, o);
          for (const i of e.getItems()) {
            if (!n.consumable.test(i, o)) {
              continue;
            }
            const r = { item: i, range: qk._createOn(i), markerName: t, markerRange: e };
            this.fire(o, r, n);
          }
        }
        _convertMarkerRemove(t, e, n) {
          if (e.root.rootName == "$graveyard") {
            return;
          }
          this.fire(`removeMarker:${t}`, { markerName: t, markerRange: e }, n);
        }
        _reduceChanges(t) {
          const e = { changes: t };
          this.fire("reduceChanges", e);
          return e.changes;
        }
        _addConsumablesForInsert(t, e) {
          for (const n of e) {
            const e = n.item;
            if (t.test(e, "insert") === null) {
              t.add(e, "insert");
              for (const n of e.getAttributeKeys()) {
                t.add(e, "attribute:" + n);
              }
            }
          }
          return t;
        }
        _addConsumablesForRange(t, e, n) {
          for (const o of e.getItems()) {
            t.add(o, n);
          }
          return t;
        }
        _addConsumablesForSelection(t, e, n) {
          t.add(e, "selection");
          for (const o of n) {
            t.add(e, "addMarker:" + o.name);
          }
          for (const n of e.getAttributeKeys()) {
            t.add(e, "attribute:" + n);
          }
          return t;
        }
        _testAndFire(t, e, n) {
          const o = Zk(t, e);
          const i = e.item.is("$textProxy") ? n.consumable._getSymbolForTextProxy(e.item) : e.item;
          const r = this._firedEventsMap.get(n);
          const s = r.get(i);
          if (!s) {
            r.set(i, new Set([o]));
          } else if (!s.has(o)) {
            s.add(o);
          } else {
            return;
          }
          this.fire(o, e, n);
        }
        _testAndFireAddAttributes(t, e) {
          const n = { item: t, range: qk._createOn(t) };
          for (const t of n.item.getAttributeKeys()) {
            n.attributeKey = t;
            n.attributeOldValue = null;
            n.attributeNewValue = n.item.getAttribute(t);
            this._testAndFire(`attribute:${t}`, n, e);
          }
        }
        _createConversionApi(t, e = new Set(), n = {}) {
          const o = {
            ...this._conversionApi,
            consumable: new Wk(),
            writer: t,
            options: n,
            convertItem: (t) => this._convertInsert(qk._createOn(t), o),
            convertChildren: (t) =>
              this._convertInsert(qk._createIn(t), o, { doNotAddConsumables: true }),
            convertAttributes: (t) => this._testAndFireAddAttributes(t, o),
            canReuseView: (t) => !e.has(o.mapper.toModelElement(t)),
          };
          this._firedEventsMap.set(o, new Map());
          return o;
        }
      }
      function Uk(t, e, n) {
        const o = e.getRange();
        const i = Array.from(t.getAncestors());
        i.shift();
        i.reverse();
        const r = i.some((t) => {
          if (o.containsItem(t)) {
            const e = n.toViewElement(t);
            return !!e.getCustomProperty("addHighlight");
          }
        });
        return !r;
      }
      function Zk(t, e) {
        const n = e.item.is("element") ? e.item.name : "$text";
        return `${t}:${n}`;
      }
      function Jk(t) {
        const e = t.item;
        const n = qk._createFromPositionAndShift(t.previousPosition, t.length);
        return { item: e, range: n };
      }
      class Yk extends q(Dk) {
        constructor(...t) {
          super();
          this._lastRangeBackward = false;
          this._attrs = new Map();
          this._ranges = [];
          if (t.length) {
            this.setTo(...t);
          }
        }
        get anchor() {
          if (this._ranges.length > 0) {
            const t = this._ranges[this._ranges.length - 1];
            return this._lastRangeBackward ? t.end : t.start;
          }
          return null;
        }
        get focus() {
          if (this._ranges.length > 0) {
            const t = this._ranges[this._ranges.length - 1];
            return this._lastRangeBackward ? t.start : t.end;
          }
          return null;
        }
        get isCollapsed() {
          const t = this._ranges.length;
          if (t === 1) {
            return this._ranges[0].isCollapsed;
          } else {
            return false;
          }
        }
        get rangeCount() {
          return this._ranges.length;
        }
        get isBackward() {
          return !this.isCollapsed && this._lastRangeBackward;
        }
        isEqual(t) {
          if (this.rangeCount != t.rangeCount) {
            return false;
          } else if (this.rangeCount === 0) {
            return true;
          }
          if (!this.anchor.isEqual(t.anchor) || !this.focus.isEqual(t.focus)) {
            return false;
          }
          for (const e of this._ranges) {
            let n = false;
            for (const o of t._ranges) {
              if (e.isEqual(o)) {
                n = true;
                break;
              }
            }
            if (!n) {
              return false;
            }
          }
          return true;
        }
        *getRanges() {
          for (const t of this._ranges) {
            yield new qk(t.start, t.end);
          }
        }
        getFirstRange() {
          let t = null;
          for (const e of this._ranges) {
            if (!t || e.start.isBefore(t.start)) {
              t = e;
            }
          }
          return t ? new qk(t.start, t.end) : null;
        }
        getLastRange() {
          let t = null;
          for (const e of this._ranges) {
            if (!t || e.end.isAfter(t.end)) {
              t = e;
            }
          }
          return t ? new qk(t.start, t.end) : null;
        }
        getFirstPosition() {
          const t = this.getFirstRange();
          return t ? t.start.clone() : null;
        }
        getLastPosition() {
          const t = this.getLastRange();
          return t ? t.end.clone() : null;
        }
        setTo(...t) {
          let [e, n, o] = t;
          if (typeof n == "object") {
            o = n;
            n = undefined;
          }
          if (e === null) {
            this._setRanges([]);
          } else if (e instanceof Yk) {
            this._setRanges(e.getRanges(), e.isBackward);
          } else if (e && typeof e.getRanges == "function") {
            this._setRanges(e.getRanges(), e.isBackward);
          } else if (e instanceof qk) {
            this._setRanges([e], !!o && !!o.backward);
          } else if (e instanceof Fk) {
            this._setRanges([new qk(e)]);
          } else if (e instanceof Sk) {
            const t = !!o && !!o.backward;
            let i;
            if (n == "in") {
              i = qk._createIn(e);
            } else if (n == "on") {
              i = qk._createOn(e);
            } else if (n !== undefined) {
              i = new qk(Fk._createAt(e, n));
            } else {
              throw new P("model-selection-setto-required-second-parameter", [this, e]);
            }
            this._setRanges([i], t);
          } else if (Ct(e)) {
            this._setRanges(e, o && !!o.backward);
          } else {
            throw new P("model-selection-setto-not-selectable", [this, e]);
          }
        }
        _setRanges(t, e = false) {
          const n = Array.from(t);
          const o = n.some((e) => {
            if (!(e instanceof qk)) {
              throw new P("model-selection-set-ranges-not-range", [this, t]);
            }
            return this._ranges.every((t) => !t.isEqual(e));
          });
          if (n.length === this._ranges.length && !o) {
            return;
          }
          this._replaceAllRanges(n);
          this._lastRangeBackward = !!e;
          this.fire("change:range", { directChange: true });
        }
        setFocus(t, e) {
          if (this.anchor === null) {
            throw new P("model-selection-setfocus-no-ranges", [this, t]);
          }
          const n = Fk._createAt(t, e);
          if (n.compareWith(this.focus) == "same") {
            return;
          }
          const o = this.anchor;
          if (this._ranges.length) {
            this._popRange();
          }
          if (n.compareWith(o) == "before") {
            this._pushRange(new qk(n, o));
            this._lastRangeBackward = true;
          } else {
            this._pushRange(new qk(o, n));
            this._lastRangeBackward = false;
          }
          this.fire("change:range", { directChange: true });
        }
        getAttribute(t) {
          return this._attrs.get(t);
        }
        getAttributes() {
          return this._attrs.entries();
        }
        getAttributeKeys() {
          return this._attrs.keys();
        }
        hasAttribute(t) {
          return this._attrs.has(t);
        }
        removeAttribute(t) {
          if (this.hasAttribute(t)) {
            this._attrs.delete(t);
            this.fire("change:attribute", { attributeKeys: [t], directChange: true });
          }
        }
        setAttribute(t, e) {
          if (this.getAttribute(t) !== e) {
            this._attrs.set(t, e);
            this.fire("change:attribute", { attributeKeys: [t], directChange: true });
          }
        }
        getSelectedElement() {
          if (this.rangeCount !== 1) {
            return null;
          }
          return this.getFirstRange().getContainedElement();
        }
        *getSelectedBlocks() {
          const t = new WeakSet();
          for (const e of this.getRanges()) {
            const n = tb(e.start, t);
            if (nb(n, e)) {
              yield n;
            }
            for (const n of e.getWalker()) {
              const o = n.item;
              if (n.type == "elementEnd" && Xk(o, t, e)) {
                yield o;
              }
            }
            const o = tb(e.end, t);
            if (ob(o, e)) {
              yield o;
            }
          }
        }
        containsEntireContent(t = this.anchor.root) {
          const e = Fk._createAt(t, 0);
          const n = Fk._createAt(t, "end");
          return e.isTouching(this.getFirstPosition()) && n.isTouching(this.getLastPosition());
        }
        _pushRange(t) {
          this._checkRange(t);
          this._ranges.push(new qk(t.start, t.end));
        }
        _checkRange(t) {
          for (let e = 0; e < this._ranges.length; e++) {
            if (t.isIntersecting(this._ranges[e])) {
              throw new P("model-selection-range-intersects", [this, t], {
                addedRange: t,
                intersectingRange: this._ranges[e],
              });
            }
          }
        }
        _replaceAllRanges(t) {
          this._removeAllRanges();
          for (const e of t) {
            this._pushRange(e);
          }
        }
        _removeAllRanges() {
          while (this._ranges.length > 0) {
            this._popRange();
          }
        }
        _popRange() {
          this._ranges.pop();
        }
      }
      Yk.prototype.is = function (t) {
        return t === "selection" || t === "model:selection";
      };
      function Qk(t, e) {
        if (e.has(t)) {
          return false;
        }
        e.add(t);
        return t.root.document.model.schema.isBlock(t) && !!t.parent;
      }
      function Xk(t, e, n) {
        return Qk(t, e) && eb(t, n);
      }
      function tb(t, e) {
        const n = t.parent;
        const o = n.root.document.model.schema;
        const i = t.parent.getAncestors({ parentFirst: true, includeSelf: true });
        let r = false;
        const s = i.find((t) => {
          if (r) {
            return false;
          }
          r = o.isLimit(t);
          return !r && Qk(t, e);
        });
        i.forEach((t) => e.add(t));
        return s;
      }
      function eb(t, e) {
        const n = ib(t);
        if (!n) {
          return true;
        }
        const o = e.containsRange(qk._createOn(n), true);
        return !o;
      }
      function nb(t, e) {
        if (!t) {
          return false;
        }
        if (e.isCollapsed || t.isEmpty) {
          return true;
        }
        if (e.start.isTouching(Fk._createAt(t, t.maxOffset))) {
          return false;
        }
        return eb(t, e);
      }
      function ob(t, e) {
        if (!t) {
          return false;
        }
        if (e.isCollapsed || t.isEmpty) {
          return true;
        }
        if (e.end.isTouching(Fk._createAt(t, 0))) {
          return false;
        }
        return eb(t, e);
      }
      function ib(t) {
        const e = t.root.document.model.schema;
        let n = t.parent;
        while (n) {
          if (e.isBlock(n)) {
            return n;
          }
          n = n.parent;
        }
      }
      class rb extends q(qk) {
        constructor(t, e) {
          super(t, e);
          sb.call(this);
        }
        detach() {
          this.stopListening();
        }
        toRange() {
          return new qk(this.start, this.end);
        }
        static fromRange(t) {
          return new rb(t.start, t.end);
        }
      }
      rb.prototype.is = function (t) {
        return t === "liveRange" || t === "model:liveRange" || t == "range" || t === "model:range";
      };
      function sb() {
        this.listenTo(
          this.root.document.model,
          "applyOperation",
          (t, e) => {
            const n = e[0];
            if (!n.isDocumentOperation) {
              return;
            }
            ab.call(this, n);
          },
          { priority: "low" }
        );
      }
      function ab(t) {
        const e = this.getTransformedByOperation(t);
        const n = qk._createFromRanges(e);
        const o = !n.isEqual(this);
        const i = cb(this, t);
        let r = null;
        if (o) {
          if (n.root.rootName == "$graveyard") {
            if (t.type == "remove") {
              r = t.sourcePosition;
            } else {
              r = t.deletionPosition;
            }
          }
          const e = this.toRange();
          this.start = n.start;
          this.end = n.end;
          this.fire("change:range", e, { deletionPosition: r });
        } else if (i) {
          this.fire("change:content", this.toRange(), { deletionPosition: r });
        }
      }
      function cb(t, e) {
        switch (e.type) {
          case "insert":
            return t.containsPosition(e.position);
          case "move":
          case "remove":
          case "reinsert":
          case "merge":
            return (
              t.containsPosition(e.sourcePosition) ||
              t.start.isEqual(e.sourcePosition) ||
              t.containsPosition(e.targetPosition)
            );
          case "split":
            return t.containsPosition(e.splitPosition) || t.containsPosition(e.insertionPosition);
        }
        return false;
      }
      const lb = "selection:";
      class db extends q(Dk) {
        constructor(t) {
          super();
          this._selection = new hb(t);
          this._selection.delegate("change:range").to(this);
          this._selection.delegate("change:attribute").to(this);
          this._selection.delegate("change:marker").to(this);
        }
        get isCollapsed() {
          return this._selection.isCollapsed;
        }
        get anchor() {
          return this._selection.anchor;
        }
        get focus() {
          return this._selection.focus;
        }
        get rangeCount() {
          return this._selection.rangeCount;
        }
        get hasOwnRange() {
          return this._selection.hasOwnRange;
        }
        get isBackward() {
          return this._selection.isBackward;
        }
        get isGravityOverridden() {
          return this._selection.isGravityOverridden;
        }
        get markers() {
          return this._selection.markers;
        }
        get _ranges() {
          return this._selection._ranges;
        }
        getRanges() {
          return this._selection.getRanges();
        }
        getFirstPosition() {
          return this._selection.getFirstPosition();
        }
        getLastPosition() {
          return this._selection.getLastPosition();
        }
        getFirstRange() {
          return this._selection.getFirstRange();
        }
        getLastRange() {
          return this._selection.getLastRange();
        }
        getSelectedBlocks() {
          return this._selection.getSelectedBlocks();
        }
        getSelectedElement() {
          return this._selection.getSelectedElement();
        }
        containsEntireContent(t) {
          return this._selection.containsEntireContent(t);
        }
        destroy() {
          this._selection.destroy();
        }
        getAttributeKeys() {
          return this._selection.getAttributeKeys();
        }
        getAttributes() {
          return this._selection.getAttributes();
        }
        getAttribute(t) {
          return this._selection.getAttribute(t);
        }
        hasAttribute(t) {
          return this._selection.hasAttribute(t);
        }
        refresh() {
          this._selection.updateMarkers();
          this._selection._updateAttributes(false);
        }
        observeMarkers(t) {
          this._selection.observeMarkers(t);
        }
        _setFocus(t, e) {
          this._selection.setFocus(t, e);
        }
        _setTo(...t) {
          this._selection.setTo(...t);
        }
        _setAttribute(t, e) {
          this._selection.setAttribute(t, e);
        }
        _removeAttribute(t) {
          this._selection.removeAttribute(t);
        }
        _getStoredAttributes() {
          return this._selection.getStoredAttributes();
        }
        _overrideGravity() {
          return this._selection.overrideGravity();
        }
        _restoreGravity(t) {
          this._selection.restoreGravity(t);
        }
        static _getStoreAttributeKey(t) {
          return lb + t;
        }
        static _isStoreAttributeKey(t) {
          return t.startsWith(lb);
        }
      }
      db.prototype.is = function (t) {
        return (
          t === "selection" ||
          t == "model:selection" ||
          t == "documentSelection" ||
          t == "model:documentSelection"
        );
      };
      class hb extends Yk {
        constructor(t) {
          super();
          this.markers = new ll({ idProperty: "name" });
          this._attributePriority = new Map();
          this._selectionRestorePosition = null;
          this._hasChangedRange = false;
          this._overriddenGravityRegister = new Set();
          this._observedMarkers = new Set();
          this._model = t.model;
          this._document = t;
          this.listenTo(
            this._model,
            "applyOperation",
            (t, e) => {
              const n = e[0];
              if (
                !n.isDocumentOperation ||
                n.type == "marker" ||
                n.type == "rename" ||
                n.type == "noop"
              ) {
                return;
              }
              if (this._ranges.length == 0 && this._selectionRestorePosition) {
                this._fixGraveyardSelection(this._selectionRestorePosition);
              }
              this._selectionRestorePosition = null;
              if (this._hasChangedRange) {
                this._hasChangedRange = false;
                this.fire("change:range", { directChange: false });
              }
            },
            { priority: "lowest" }
          );
          this.on("change:range", () => {
            this._validateSelectionRanges(this.getRanges());
          });
          this.listenTo(this._model.markers, "update", (t, e, n, o) => {
            this._updateMarker(e, o);
          });
          this.listenTo(this._document, "change", (t, e) => {
            fb(this._model, e);
          });
        }
        get isCollapsed() {
          const t = this._ranges.length;
          return t === 0 ? this._document._getDefaultRange().isCollapsed : super.isCollapsed;
        }
        get anchor() {
          return super.anchor || this._document._getDefaultRange().start;
        }
        get focus() {
          return super.focus || this._document._getDefaultRange().end;
        }
        get rangeCount() {
          return this._ranges.length ? this._ranges.length : 1;
        }
        get hasOwnRange() {
          return this._ranges.length > 0;
        }
        get isGravityOverridden() {
          return !!this._overriddenGravityRegister.size;
        }
        destroy() {
          for (let t = 0; t < this._ranges.length; t++) {
            this._ranges[t].detach();
          }
          this.stopListening();
        }
        *getRanges() {
          if (this._ranges.length) {
            yield* super.getRanges();
          } else {
            yield this._document._getDefaultRange();
          }
        }
        getFirstRange() {
          return super.getFirstRange() || this._document._getDefaultRange();
        }
        getLastRange() {
          return super.getLastRange() || this._document._getDefaultRange();
        }
        setTo(...t) {
          super.setTo(...t);
          this._updateAttributes(true);
          this.updateMarkers();
        }
        setFocus(t, e) {
          super.setFocus(t, e);
          this._updateAttributes(true);
          this.updateMarkers();
        }
        setAttribute(t, e) {
          if (this._setAttribute(t, e)) {
            const e = [t];
            this.fire("change:attribute", { attributeKeys: e, directChange: true });
          }
        }
        removeAttribute(t) {
          if (this._removeAttribute(t)) {
            const e = [t];
            this.fire("change:attribute", { attributeKeys: e, directChange: true });
          }
        }
        overrideGravity() {
          const t = x();
          this._overriddenGravityRegister.add(t);
          if (this._overriddenGravityRegister.size === 1) {
            this._updateAttributes(true);
          }
          return t;
        }
        restoreGravity(t) {
          if (!this._overriddenGravityRegister.has(t)) {
            throw new P("document-selection-gravity-wrong-restore", this, { uid: t });
          }
          this._overriddenGravityRegister.delete(t);
          if (!this.isGravityOverridden) {
            this._updateAttributes(true);
          }
        }
        observeMarkers(t) {
          this._observedMarkers.add(t);
          this.updateMarkers();
        }
        _replaceAllRanges(t) {
          this._validateSelectionRanges(t);
          super._replaceAllRanges(t);
        }
        _popRange() {
          this._ranges.pop().detach();
        }
        _pushRange(t) {
          const e = this._prepareRange(t);
          if (e) {
            this._ranges.push(e);
          }
        }
        _validateSelectionRanges(t) {
          for (const e of t) {
            if (!this._document._validateSelectionRange(e)) {
              throw new P("document-selection-wrong-position", this, { range: e });
            }
          }
        }
        _prepareRange(t) {
          this._checkRange(t);
          if (t.root == this._document.graveyard) {
            return;
          }
          const e = rb.fromRange(t);
          e.on("change:range", (t, n, o) => {
            this._hasChangedRange = true;
            if (e.root == this._document.graveyard) {
              this._selectionRestorePosition = o.deletionPosition;
              const t = this._ranges.indexOf(e);
              this._ranges.splice(t, 1);
              e.detach();
            }
          });
          return e;
        }
        updateMarkers() {
          if (!this._observedMarkers.size) {
            return;
          }
          const t = [];
          let e = false;
          for (const e of this._model.markers) {
            const n = e.name.split(":", 1)[0];
            if (!this._observedMarkers.has(n)) {
              continue;
            }
            const o = e.getRange();
            for (const n of this.getRanges()) {
              if (o.containsRange(n, !n.isCollapsed)) {
                t.push(e);
              }
            }
          }
          const n = Array.from(this.markers);
          for (const n of t) {
            if (!this.markers.has(n)) {
              this.markers.add(n);
              e = true;
            }
          }
          for (const n of Array.from(this.markers)) {
            if (!t.includes(n)) {
              this.markers.remove(n);
              e = true;
            }
          }
          if (e) {
            this.fire("change:marker", { oldMarkers: n, directChange: false });
          }
        }
        _updateMarker(t, e) {
          const n = t.name.split(":", 1)[0];
          if (!this._observedMarkers.has(n)) {
            return;
          }
          let o = false;
          const i = Array.from(this.markers);
          const r = this.markers.has(t);
          if (!e) {
            if (r) {
              this.markers.remove(t);
              o = true;
            }
          } else {
            let n = false;
            for (const t of this.getRanges()) {
              if (e.containsRange(t, !t.isCollapsed)) {
                n = true;
                break;
              }
            }
            if (n && !r) {
              this.markers.add(t);
              o = true;
            } else if (!n && r) {
              this.markers.remove(t);
              o = true;
            }
          }
          if (o) {
            this.fire("change:marker", { oldMarkers: i, directChange: false });
          }
        }
        _updateAttributes(t) {
          const e = pl(this._getSurroundingAttributes());
          const n = pl(this.getAttributes());
          if (t) {
            this._attributePriority = new Map();
            this._attrs = new Map();
          } else {
            for (const [t, e] of this._attributePriority) {
              if (e == "low") {
                this._attrs.delete(t);
                this._attributePriority.delete(t);
              }
            }
          }
          this._setAttributesTo(e);
          const o = [];
          for (const [t, e] of this.getAttributes()) {
            if (!n.has(t) || n.get(t) !== e) {
              o.push(t);
            }
          }
          for (const [t] of n) {
            if (!this.hasAttribute(t)) {
              o.push(t);
            }
          }
          if (o.length > 0) {
            this.fire("change:attribute", { attributeKeys: o, directChange: false });
          }
        }
        _setAttribute(t, e, n = true) {
          const o = n ? "normal" : "low";
          if (o == "low" && this._attributePriority.get(t) == "normal") {
            return false;
          }
          const i = super.getAttribute(t);
          if (i === e) {
            return false;
          }
          this._attrs.set(t, e);
          this._attributePriority.set(t, o);
          return true;
        }
        _removeAttribute(t, e = true) {
          const n = e ? "normal" : "low";
          if (n == "low" && this._attributePriority.get(t) == "normal") {
            return false;
          }
          this._attributePriority.set(t, n);
          if (!super.hasAttribute(t)) {
            return false;
          }
          this._attrs.delete(t);
          return true;
        }
        _setAttributesTo(t) {
          const e = new Set();
          for (const [e, n] of this.getAttributes()) {
            if (t.get(e) === n) {
              continue;
            }
            this._removeAttribute(e, false);
          }
          for (const [n, o] of t) {
            const t = this._setAttribute(n, o, false);
            if (t) {
              e.add(n);
            }
          }
          return e;
        }
        *getStoredAttributes() {
          const t = this.getFirstPosition().parent;
          if (this.isCollapsed && t.isEmpty) {
            for (const e of t.getAttributeKeys()) {
              if (e.startsWith(lb)) {
                const n = e.substr(lb.length);
                yield [n, t.getAttribute(e)];
              }
            }
          }
        }
        _getSurroundingAttributes() {
          const t = this.getFirstPosition();
          const e = this._model.schema;
          if (t.root.rootName == "$graveyard") {
            return null;
          }
          let n = null;
          if (!this.isCollapsed) {
            const t = this.getFirstRange();
            for (const o of t) {
              if (o.item.is("element") && e.isObject(o.item)) {
                n = ub(o.item, e);
                break;
              }
              if (o.type == "text") {
                n = o.item.getAttributes();
                break;
              }
            }
          } else {
            const o = t.textNode ? t.textNode : t.nodeBefore;
            const i = t.textNode ? t.textNode : t.nodeAfter;
            if (!this.isGravityOverridden) {
              n = ub(o, e);
            }
            if (!n) {
              n = ub(i, e);
            }
            if (!this.isGravityOverridden && !n) {
              let t = o;
              while (t && !n) {
                t = t.previousSibling;
                n = ub(t, e);
              }
            }
            if (!n) {
              let t = i;
              while (t && !n) {
                t = t.nextSibling;
                n = ub(t, e);
              }
            }
            if (!n) {
              n = this.getStoredAttributes();
            }
          }
          return n;
        }
        _fixGraveyardSelection(t) {
          const e = this._model.schema.getNearestSelectionRange(t);
          if (e) {
            this._pushRange(e);
          }
        }
      }
      function ub(t, e) {
        if (!t) {
          return null;
        }
        if (t instanceof Bk || t instanceof Pk) {
          return t.getAttributes();
        }
        if (!e.isInline(t)) {
          return null;
        }
        if (!e.isObject(t)) {
          return [];
        }
        const n = [];
        for (const [o, i] of t.getAttributes()) {
          if (
            e.checkAttribute("$text", o) &&
            e.getAttributeProperties(o).copyFromObject !== false
          ) {
            n.push([o, i]);
          }
        }
        return n;
      }
      function fb(t, e) {
        const n = t.document.differ;
        for (const o of n.getChanges()) {
          if (o.type != "insert") {
            continue;
          }
          const n = o.position.parent;
          const i = o.length === n.maxOffset;
          if (i) {
            t.enqueueChange(e, (t) => {
              const e = Array.from(n.getAttributeKeys()).filter((t) => t.startsWith(lb));
              for (const o of e) {
                t.removeAttribute(o, n);
              }
            });
          }
        }
      }
      class pb {
        constructor(t) {
          this._dispatchers = t;
        }
        add(t) {
          for (const e of this._dispatchers) {
            t(e);
          }
          return this;
        }
      }
      class gb extends pb {
        elementToElement(t) {
          return this.add(Mb(t));
        }
        elementToStructure(t) {
          return this.add(Nb(t));
        }
        attributeToElement(t) {
          return this.add(Vb(t));
        }
        attributeToAttribute(t) {
          return this.add(Lb(t));
        }
        markerToElement(t) {
          return this.add(Hb(t));
        }
        markerToHighlight(t) {
          return this.add(qb(t));
        }
        markerToData(t) {
          return this.add(jb(t));
        }
      }
      function mb() {
        return (t, e, n) => {
          if (!n.consumable.consume(e.item, t.name)) {
            return;
          }
          const o = n.writer;
          const i = n.mapper.toViewPosition(e.range.start);
          const r = o.createText(e.item.data);
          o.insert(i, r);
        };
      }
      function kb() {
        return (t, e, n) => {
          n.convertAttributes(e.item);
          if (!e.reconversion && e.item.is("element") && !e.item.isEmpty) {
            n.convertChildren(e.item);
          }
        };
      }
      function bb() {
        return (t, e, n) => {
          const o = n.mapper.toViewPosition(e.position);
          const i = e.position.getShiftedBy(e.length);
          const r = n.mapper.toViewPosition(i, { isPhantom: true });
          const s = n.writer.createRange(o, r);
          const a = n.writer.remove(s.getTrimmed());
          for (const t of n.writer.createRangeIn(a).getItems()) {
            n.mapper.unbindViewElement(t, { defer: true });
          }
        };
      }
      function wb(t, e) {
        const n = t.createAttributeElement("span", e.attributes);
        if (e.classes) {
          n._addClass(e.classes);
        }
        if (typeof e.priority === "number") {
          n._priority = e.priority;
        }
        n._id = e.id;
        return n;
      }
      function _b() {
        return (t, e, n) => {
          const o = e.selection;
          if (o.isCollapsed) {
            return;
          }
          if (!n.consumable.consume(o, "selection")) {
            return;
          }
          const i = [];
          for (const t of o.getRanges()) {
            i.push(n.mapper.toViewRange(t));
          }
          n.writer.setSelection(i, { backward: o.isBackward });
        };
      }
      function vb() {
        return (t, e, n) => {
          const o = e.selection;
          if (!o.isCollapsed) {
            return;
          }
          if (!n.consumable.consume(o, "selection")) {
            return;
          }
          const i = n.writer;
          const r = o.getFirstPosition();
          const s = n.mapper.toViewPosition(r);
          const a = i.breakAttributes(s);
          i.setSelection(a);
        };
      }
      function Ab() {
        return (t, e, n) => {
          const o = n.writer;
          const i = o.document.selection;
          for (const t of i.getRanges()) {
            if (t.isCollapsed) {
              if (t.end.parent.isAttached()) {
                n.writer.mergeAttributes(t.start);
              }
            }
          }
          o.setSelection(null);
        };
      }
      function Cb(t) {
        return (e, n, o) => {
          if (!o.consumable.test(n.item, e.name)) {
            return;
          }
          const i = t(n.attributeOldValue, o, n);
          const r = t(n.attributeNewValue, o, n);
          if (!i && !r) {
            return;
          }
          o.consumable.consume(n.item, e.name);
          const s = o.writer;
          const a = s.document.selection;
          if (n.item instanceof Yk || n.item instanceof db) {
            s.wrap(a.getFirstRange(), r);
          } else {
            let t = o.mapper.toViewRange(n.range);
            if (n.attributeOldValue !== null && i) {
              t = s.unwrap(t, i);
            }
            if (n.attributeNewValue !== null && r) {
              s.wrap(t, r);
            }
          }
        };
      }
      function yb(t, e = iw) {
        return (n, o, i) => {
          if (!e(o.item, i.consumable, { preflight: true })) {
            return;
          }
          const r = t(o.item, i, o);
          if (!r) {
            return;
          }
          e(o.item, i.consumable);
          const s = i.mapper.toViewPosition(o.range.start);
          i.mapper.bindElements(o.item, r);
          i.writer.insert(s, r);
          i.convertAttributes(o.item);
          nw(r, o.item.getChildren(), i, { reconversion: o.reconversion });
        };
      }
      function xb(t, e) {
        return (n, o, i) => {
          if (!e(o.item, i.consumable, { preflight: true })) {
            return;
          }
          const r = new Map();
          i.writer._registerSlotFactory(Xb(o.item, r, i));
          const s = t(o.item, i, o);
          i.writer._clearSlotFactory();
          if (!s) {
            return;
          }
          tw(o.item, r, i);
          e(o.item, i.consumable);
          const a = i.mapper.toViewPosition(o.range.start);
          i.mapper.bindElements(o.item, s);
          i.writer.insert(a, s);
          i.convertAttributes(o.item);
          ew(s, r, i, { reconversion: o.reconversion });
        };
      }
      function Eb(t) {
        return (e, n, o) => {
          n.isOpening = true;
          const i = t(n, o);
          n.isOpening = false;
          const r = t(n, o);
          if (!i || !r) {
            return;
          }
          const s = n.markerRange;
          if (s.isCollapsed && !o.consumable.consume(s, e.name)) {
            return;
          }
          for (const t of s) {
            if (!o.consumable.consume(t.item, e.name)) {
              return;
            }
          }
          const a = o.mapper;
          const c = o.writer;
          c.insert(a.toViewPosition(s.start), i);
          o.mapper.bindElementToMarker(i, n.markerName);
          if (!s.isCollapsed) {
            c.insert(a.toViewPosition(s.end), r);
            o.mapper.bindElementToMarker(r, n.markerName);
          }
          e.stop();
        };
      }
      function Db() {
        return (t, e, n) => {
          const o = n.mapper.markerNameToElements(e.markerName);
          if (!o) {
            return;
          }
          for (const t of o) {
            n.mapper.unbindElementFromMarkerName(t, e.markerName);
            n.writer.clear(n.writer.createRangeOn(t), t);
          }
          n.writer.clearClonedElementsGroup(e.markerName);
          t.stop();
        };
      }
      function Sb(t) {
        return (e, n, o) => {
          const i = t(n.markerName, o);
          if (!i) {
            return;
          }
          const r = n.markerRange;
          if (!o.consumable.consume(r, e.name)) {
            return;
          }
          Tb(r, false, o, n, i);
          Tb(r, true, o, n, i);
          e.stop();
        };
      }
      function Tb(t, e, n, o, i) {
        const r = e ? t.start : t.end;
        const s = r.nodeAfter && r.nodeAfter.is("element") ? r.nodeAfter : null;
        const a = r.nodeBefore && r.nodeBefore.is("element") ? r.nodeBefore : null;
        if (s || a) {
          let t;
          let r;
          if ((e && s) || (!e && !a)) {
            t = s;
            r = true;
          } else {
            t = a;
            r = false;
          }
          const c = n.mapper.toViewElement(t);
          if (c) {
            Pb(c, e, r, n, o, i);
            return;
          }
        }
        const c = n.mapper.toViewPosition(r);
        Bb(c, e, n, o, i);
      }
      function Pb(t, e, n, o, i, r) {
        const s = `data-${r.group}-${e ? "start" : "end"}-${n ? "before" : "after"}`;
        const a = t.hasAttribute(s) ? t.getAttribute(s).split(",") : [];
        a.unshift(r.name);
        o.writer.setAttribute(s, a.join(","), t);
        o.mapper.bindElementToMarker(t, i.markerName);
      }
      function Bb(t, e, n, o, i) {
        const r = `${i.group}-${e ? "start" : "end"}`;
        const s = i.name ? { name: i.name } : null;
        const a = n.writer.createUIElement(r, s);
        n.writer.insert(t, a);
        n.mapper.bindElementToMarker(a, o.markerName);
      }
      function Ob(t) {
        return (e, n, o) => {
          const i = t(n.markerName, o);
          if (!i) {
            return;
          }
          const r = o.mapper.markerNameToElements(n.markerName);
          if (!r) {
            return;
          }
          for (const t of r) {
            o.mapper.unbindElementFromMarkerName(t, n.markerName);
            if (t.is("containerElement")) {
              s(`data-${i.group}-start-before`, t);
              s(`data-${i.group}-start-after`, t);
              s(`data-${i.group}-end-before`, t);
              s(`data-${i.group}-end-after`, t);
            } else {
              o.writer.clear(o.writer.createRangeOn(t), t);
            }
          }
          o.writer.clearClonedElementsGroup(n.markerName);
          e.stop();
          function s(t, e) {
            if (e.hasAttribute(t)) {
              const n = new Set(e.getAttribute(t).split(","));
              n.delete(i.name);
              if (n.size == 0) {
                o.writer.removeAttribute(t, e);
              } else {
                o.writer.setAttribute(t, Array.from(n).join(","), e);
              }
            }
          }
        };
      }
      function Rb(t) {
        return (e, n, o) => {
          if (!o.consumable.test(n.item, e.name)) {
            return;
          }
          const i = t(n.attributeOldValue, o, n);
          const r = t(n.attributeNewValue, o, n);
          if (!i && !r) {
            return;
          }
          o.consumable.consume(n.item, e.name);
          const s = o.mapper.toViewElement(n.item);
          const a = o.writer;
          if (!s) {
            throw new P("conversion-attribute-to-attribute-on-text", o.dispatcher, n);
          }
          if (n.attributeOldValue !== null && i) {
            if (i.key == "class") {
              const t = Xc(i.value);
              for (const e of t) {
                a.removeClass(e, s);
              }
            } else if (i.key == "style") {
              const t = Object.keys(i.value);
              for (const e of t) {
                a.removeStyle(e, s);
              }
            } else {
              a.removeAttribute(i.key, s);
            }
          }
          if (n.attributeNewValue !== null && r) {
            if (r.key == "class") {
              const t = Xc(r.value);
              for (const e of t) {
                a.addClass(e, s);
              }
            } else if (r.key == "style") {
              const t = Object.keys(r.value);
              for (const e of t) {
                a.setStyle(e, r.value[e], s);
              }
            } else {
              a.setAttribute(r.key, r.value, s);
            }
          }
        };
      }
      function Ib(t) {
        return (e, n, o) => {
          if (!n.item) {
            return;
          }
          if (!(n.item instanceof Yk || n.item instanceof db) && !n.item.is("$textProxy")) {
            return;
          }
          const i = Zb(t, n, o);
          if (!i) {
            return;
          }
          if (!o.consumable.consume(n.item, e.name)) {
            return;
          }
          const r = o.writer;
          const s = wb(r, i);
          const a = r.document.selection;
          if (n.item instanceof Yk || n.item instanceof db) {
            r.wrap(a.getFirstRange(), s);
          } else {
            const t = o.mapper.toViewRange(n.range);
            const e = r.wrap(t, s);
            for (const t of e.getItems()) {
              if (t.is("attributeElement") && t.isSimilar(s)) {
                o.mapper.bindElementToMarker(t, n.markerName);
                break;
              }
            }
          }
        };
      }
      function zb(t) {
        return (e, n, o) => {
          if (!n.item) {
            return;
          }
          if (!(n.item instanceof Ok)) {
            return;
          }
          const i = Zb(t, n, o);
          if (!i) {
            return;
          }
          if (!o.consumable.test(n.item, e.name)) {
            return;
          }
          const r = o.mapper.toViewElement(n.item);
          if (r && r.getCustomProperty("addHighlight")) {
            o.consumable.consume(n.item, e.name);
            for (const t of qk._createIn(n.item)) {
              o.consumable.consume(t.item, e.name);
            }
            const t = r.getCustomProperty("addHighlight");
            t(r, i, o.writer);
            o.mapper.bindElementToMarker(r, n.markerName);
          }
        };
      }
      function Fb(t) {
        return (e, n, o) => {
          if (n.markerRange.isCollapsed) {
            return;
          }
          const i = Zb(t, n, o);
          if (!i) {
            return;
          }
          const r = wb(o.writer, i);
          const s = o.mapper.markerNameToElements(n.markerName);
          if (!s) {
            return;
          }
          for (const t of s) {
            o.mapper.unbindElementFromMarkerName(t, n.markerName);
            if (t.is("attributeElement")) {
              o.writer.unwrap(o.writer.createRangeOn(t), r);
            } else {
              const e = t.getCustomProperty("removeHighlight");
              e(t, i.id, o.writer);
            }
          }
          o.writer.clearClonedElementsGroup(n.markerName);
          e.stop();
        };
      }
      function Mb(t) {
        const e = $b(t.model);
        const n = Wb(t.view, "container");
        if (e.attributes.length) {
          e.children = true;
        }
        return (o) => {
          o.on(`insert:${e.name}`, yb(n, Qb(e)), { priority: t.converterPriority || "normal" });
          if (e.children || e.attributes.length) {
            o.on("reduceChanges", Yb(e), { priority: "low" });
          }
        };
      }
      function Nb(t) {
        const e = $b(t.model);
        const n = Wb(t.view, "container");
        e.children = true;
        return (o) => {
          if (o._conversionApi.schema.checkChild(e.name, "$text")) {
            throw new P("conversion-element-to-structure-disallowed-text", o, {
              elementName: e.name,
            });
          }
          o.on(`insert:${e.name}`, xb(n, Qb(e)), { priority: t.converterPriority || "normal" });
          o.on("reduceChanges", Yb(e), { priority: "low" });
        };
      }
      function Vb(t) {
        t = xk(t);
        let e = t.model;
        if (typeof e == "string") {
          e = { key: e };
        }
        let n = `attribute:${e.key}`;
        if (e.name) {
          n += ":" + e.name;
        }
        if (e.values) {
          for (const n of e.values) {
            t.view[n] = Wb(t.view[n], "attribute");
          }
        } else {
          t.view = Wb(t.view, "attribute");
        }
        const o = Kb(t);
        return (e) => {
          e.on(n, Cb(o), { priority: t.converterPriority || "normal" });
        };
      }
      function Lb(t) {
        t = xk(t);
        let e = t.model;
        if (typeof e == "string") {
          e = { key: e };
        }
        let n = `attribute:${e.key}`;
        if (e.name) {
          n += ":" + e.name;
        }
        if (e.values) {
          for (const n of e.values) {
            t.view[n] = Ub(t.view[n]);
          }
        } else {
          t.view = Ub(t.view);
        }
        const o = Kb(t);
        return (e) => {
          e.on(n, Rb(o), { priority: t.converterPriority || "normal" });
        };
      }
      function Hb(t) {
        const e = Wb(t.view, "ui");
        return (n) => {
          n.on(`addMarker:${t.model}`, Eb(e), { priority: t.converterPriority || "normal" });
          n.on(`removeMarker:${t.model}`, Db(), { priority: t.converterPriority || "normal" });
        };
      }
      function jb(t) {
        t = xk(t);
        const e = t.model;
        let n = t.view;
        if (!n) {
          n = (n) => ({ group: e, name: n.substr(t.model.length + 1) });
        }
        return (o) => {
          o.on(`addMarker:${e}`, Sb(n), { priority: t.converterPriority || "normal" });
          o.on(`removeMarker:${e}`, Ob(n), { priority: t.converterPriority || "normal" });
        };
      }
      function qb(t) {
        return (e) => {
          e.on(`addMarker:${t.model}`, Ib(t.view), { priority: t.converterPriority || "normal" });
          e.on(`addMarker:${t.model}`, zb(t.view), { priority: t.converterPriority || "normal" });
          e.on(`removeMarker:${t.model}`, Fb(t.view), {
            priority: t.converterPriority || "normal",
          });
        };
      }
      function $b(t) {
        if (typeof t == "string") {
          t = { name: t };
        }
        if (!t.attributes) {
          t.attributes = [];
        } else if (!Array.isArray(t.attributes)) {
          t.attributes = [t.attributes];
        }
        t.children = !!t.children;
        return t;
      }
      function Wb(t, e) {
        if (typeof t == "function") {
          return t;
        }
        return (n, o) => Gb(t, o, e);
      }
      function Gb(t, e, n) {
        if (typeof t == "string") {
          t = { name: t };
        }
        let o;
        const i = e.writer;
        const r = Object.assign({}, t.attributes);
        if (n == "container") {
          o = i.createContainerElement(t.name, r);
        } else if (n == "attribute") {
          const e = { priority: t.priority || Xp.DEFAULT_PRIORITY };
          o = i.createAttributeElement(t.name, r, e);
        } else {
          o = i.createUIElement(t.name, r);
        }
        if (t.styles) {
          const e = Object.keys(t.styles);
          for (const n of e) {
            i.setStyle(n, t.styles[n], o);
          }
        }
        if (t.classes) {
          const e = t.classes;
          if (typeof e == "string") {
            i.addClass(e, o);
          } else {
            for (const t of e) {
              i.addClass(t, o);
            }
          }
        }
        return o;
      }
      function Kb(t) {
        if (t.model.values) {
          return (e, n, o) => {
            const i = t.view[e];
            if (i) {
              return i(e, n, o);
            }
            return null;
          };
        } else {
          return t.view;
        }
      }
      function Ub(t) {
        if (typeof t == "string") {
          return (e) => ({ key: t, value: e });
        } else if (typeof t == "object") {
          if (t.value) {
            return () => t;
          } else {
            return (e) => ({ key: t.key, value: e });
          }
        } else {
          return t;
        }
      }
      function Zb(t, e, n) {
        const o = typeof t == "function" ? t(e, n) : t;
        if (!o) {
          return null;
        }
        if (!o.priority) {
          o.priority = 10;
        }
        if (!o.id) {
          o.id = e.markerName;
        }
        return o;
      }
      function Jb(t) {
        return (e, n) => {
          if (!e.is("element", t.name)) {
            return false;
          }
          if (n.type == "attribute") {
            if (t.attributes.includes(n.attributeKey)) {
              return true;
            }
          } else {
            if (t.children) {
              return true;
            }
          }
          return false;
        };
      }
      function Yb(t) {
        const e = Jb(t);
        return (t, n) => {
          const o = [];
          if (!n.reconvertedElements) {
            n.reconvertedElements = new Set();
          }
          for (const t of n.changes) {
            const i = t.type == "attribute" ? t.range.start.nodeAfter : t.position.parent;
            if (!i || !e(i, t)) {
              o.push(t);
              continue;
            }
            if (!n.reconvertedElements.has(i)) {
              n.reconvertedElements.add(i);
              const t = Fk._createBefore(i);
              let e = o.length;
              for (let n = o.length - 1; n >= 0; n--) {
                const i = o[n];
                const r = i.type == "attribute" ? i.range.start : i.position;
                const s = r.compareWith(t);
                if (s == "before" || (i.type == "remove" && s == "same")) {
                  break;
                }
                e = n;
              }
              o.splice(
                e,
                0,
                { type: "remove", name: i.name, position: t, length: 1 },
                { type: "reinsert", name: i.name, position: t, length: 1 }
              );
            }
          }
          n.changes = o;
        };
      }
      function Qb(t) {
        return (e, n, o = {}) => {
          const i = ["insert"];
          for (const n of t.attributes) {
            if (e.hasAttribute(n)) {
              i.push(`attribute:${n}`);
            }
          }
          if (!i.every((t) => n.test(e, t))) {
            return false;
          }
          if (!o.preflight) {
            i.forEach((t) => n.consume(e, t));
          }
          return true;
        };
      }
      function Xb(t, e, n) {
        return (o, i) => {
          const r = o.createContainerElement("$slot");
          let s = null;
          if (i === "children") {
            s = Array.from(t.getChildren());
          } else if (typeof i == "function") {
            s = Array.from(t.getChildren()).filter((t) => i(t));
          } else {
            throw new P("conversion-slot-mode-unknown", n.dispatcher, { modeOrFilter: i });
          }
          e.set(r, s);
          return r;
        };
      }
      function tw(t, e, n) {
        const o = Array.from(e.values()).flat();
        const i = new Set(o);
        if (i.size != o.length) {
          throw new P("conversion-slot-filter-overlap", n.dispatcher, { element: t });
        }
        if (i.size != t.childCount) {
          throw new P("conversion-slot-filter-incomplete", n.dispatcher, { element: t });
        }
      }
      function ew(t, e, n, o) {
        n.mapper.on("modelToViewPosition", s, { priority: "highest" });
        let i = null;
        let r = null;
        for ([i, r] of e) {
          nw(t, r, n, o);
          n.writer.move(n.writer.createRangeIn(i), n.writer.createPositionBefore(i));
          n.writer.remove(i);
        }
        n.mapper.off("modelToViewPosition", s);
        function s(t, e) {
          const n = e.modelPosition.nodeAfter;
          const o = r.indexOf(n);
          if (o < 0) {
            return;
          }
          e.viewPosition = e.mapper.findPositionIn(i, o);
        }
      }
      function nw(t, e, n, o) {
        for (const i of e) {
          if (!ow(t.root, i, n, o)) {
            n.convertItem(i);
          }
        }
      }
      function ow(t, e, n, o) {
        const { writer: i, mapper: r } = n;
        if (!o.reconversion) {
          return false;
        }
        const s = r.toViewElement(e);
        if (!s || s.root == t) {
          return false;
        }
        if (!n.canReuseView(s)) {
          return false;
        }
        i.move(i.createRangeOn(s), r.toViewPosition(Fk._createBefore(e)));
        return true;
      }
      function iw(t, e, { preflight: n } = {}) {
        if (n) {
          return e.test(t, "insert");
        } else {
          return e.consume(t, "insert");
        }
      }
      function rw(t) {
        const { schema: e, document: n } = t.model;
        for (const o of n.getRoots()) {
          if (o.isEmpty && !e.checkChild(o, "$text")) {
            if (e.checkChild(o, "paragraph")) {
              t.insertElement("paragraph", o);
              return true;
            }
          }
        }
        return false;
      }
      function sw(t, e, n) {
        const o = n.createContext(t);
        if (!n.checkChild(o, "paragraph")) {
          return false;
        }
        if (!n.checkChild(o.push("paragraph"), e)) {
          return false;
        }
        return true;
      }
      function aw(t, e) {
        const n = e.createElement("paragraph");
        e.insert(n, t);
        return e.createPositionAt(n, 0);
      }
      class cw extends pb {
        elementToElement(t) {
          return this.add(uw(t));
        }
        elementToAttribute(t) {
          return this.add(fw(t));
        }
        attributeToAttribute(t) {
          return this.add(pw(t));
        }
        elementToMarker(t) {
          return this.add(gw(t));
        }
        dataToMarker(t) {
          return this.add(mw(t));
        }
      }
      function lw() {
        return (t, e, n) => {
          if (!e.modelRange && n.consumable.consume(e.viewItem, { name: true })) {
            const { modelRange: t, modelCursor: o } = n.convertChildren(e.viewItem, e.modelCursor);
            e.modelRange = t;
            e.modelCursor = o;
          }
        };
      }
      function dw() {
        return (t, e, { schema: n, consumable: o, writer: i }) => {
          let r = e.modelCursor;
          if (!o.test(e.viewItem)) {
            return;
          }
          if (!n.checkChild(r, "$text")) {
            if (!sw(r, "$text", n)) {
              return;
            }
            if (e.viewItem.data.trim().length == 0) {
              return;
            }
            const t = r.nodeBefore;
            r = aw(r, i);
            if (t && t.is("element", "$marker")) {
              i.move(i.createRangeOn(t), r);
              r = i.createPositionAfter(t);
            }
          }
          o.consume(e.viewItem);
          const s = i.createText(e.viewItem.data);
          i.insert(s, r);
          e.modelRange = i.createRange(r, r.getShiftedBy(s.offsetSize));
          e.modelCursor = e.modelRange.end;
        };
      }
      function hw(t, e) {
        return (n, o) => {
          const i = o.newSelection;
          const r = [];
          for (const t of i.getRanges()) {
            r.push(e.toModelRange(t));
          }
          const s = t.createSelection(r, { backward: i.isBackward });
          if (!s.isEqual(t.document.selection)) {
            t.change((t) => {
              t.setSelection(s);
            });
          }
        };
      }
      function uw(t) {
        t = xk(t);
        const e = ww(t);
        const n = bw(t.view);
        const o = n ? `element:${n}` : "element";
        return (n) => {
          n.on(o, e, { priority: t.converterPriority || "normal" });
        };
      }
      function fw(t) {
        t = xk(t);
        Aw(t);
        const e = Cw(t, false);
        const n = bw(t.view);
        const o = n ? `element:${n}` : "element";
        return (n) => {
          n.on(o, e, { priority: t.converterPriority || "low" });
        };
      }
      function pw(t) {
        t = xk(t);
        let e = null;
        if (typeof t.view == "string" || t.view.key) {
          e = vw(t);
        }
        Aw(t, e);
        const n = Cw(t, true);
        return (e) => {
          e.on("element", n, { priority: t.converterPriority || "low" });
        };
      }
      function gw(t) {
        const e = Ew(t.model);
        return uw({ ...t, model: e });
      }
      function mw(t) {
        t = xk(t);
        if (!t.model) {
          t.model = (e) => (e ? t.view + ":" + e : t.view);
        }
        const e = { view: t.view, model: t.model };
        const n = ww(Dw(e, "start"));
        const o = ww(Dw(e, "end"));
        return (i) => {
          i.on(`element:${t.view}-start`, n, { priority: t.converterPriority || "normal" });
          i.on(`element:${t.view}-end`, o, { priority: t.converterPriority || "normal" });
          const r = D.low;
          const s = D.highest;
          const a = D.get(t.converterPriority) / s;
          i.on("element", kw(e), { priority: r + a });
        };
      }
      function kw(t) {
        return (e, n, o) => {
          const i = `data-${t.view}`;
          if (
            !o.consumable.test(n.viewItem, { attributes: i + "-end-after" }) &&
            !o.consumable.test(n.viewItem, { attributes: i + "-start-after" }) &&
            !o.consumable.test(n.viewItem, { attributes: i + "-end-before" }) &&
            !o.consumable.test(n.viewItem, { attributes: i + "-start-before" })
          ) {
            return;
          }
          if (!n.modelRange) {
            Object.assign(n, o.convertChildren(n.viewItem, n.modelCursor));
          }
          if (o.consumable.consume(n.viewItem, { attributes: i + "-end-after" })) {
            r(n.modelRange.end, n.viewItem.getAttribute(i + "-end-after").split(","));
          }
          if (o.consumable.consume(n.viewItem, { attributes: i + "-start-after" })) {
            r(n.modelRange.end, n.viewItem.getAttribute(i + "-start-after").split(","));
          }
          if (o.consumable.consume(n.viewItem, { attributes: i + "-end-before" })) {
            r(n.modelRange.start, n.viewItem.getAttribute(i + "-end-before").split(","));
          }
          if (o.consumable.consume(n.viewItem, { attributes: i + "-start-before" })) {
            r(n.modelRange.start, n.viewItem.getAttribute(i + "-start-before").split(","));
          }
          function r(e, i) {
            for (const r of i) {
              const i = t.model(r, o);
              const s = o.writer.createElement("$marker", { "data-name": i });
              o.writer.insert(s, e);
              if (n.modelCursor.isEqual(e)) {
                n.modelCursor = n.modelCursor.getShiftedBy(1);
              } else {
                n.modelCursor = n.modelCursor._getTransformedByInsertion(e, 1);
              }
              n.modelRange = n.modelRange._getTransformedByInsertion(e, 1)[0];
            }
          }
        };
      }
      function bw(t) {
        if (typeof t == "string") {
          return t;
        }
        if (typeof t == "object" && typeof t.name == "string") {
          return t.name;
        }
        return null;
      }
      function ww(t) {
        const e = new Ou(t.view);
        return (n, o, i) => {
          const r = e.match(o.viewItem);
          if (!r) {
            return;
          }
          const s = r.match;
          s.name = true;
          if (!i.consumable.test(o.viewItem, s)) {
            return;
          }
          const a = _w(t.model, o.viewItem, i);
          if (!a) {
            return;
          }
          if (!i.safeInsert(a, o.modelCursor)) {
            return;
          }
          i.consumable.consume(o.viewItem, s);
          i.convertChildren(o.viewItem, a);
          i.updateConversionResult(a, o);
        };
      }
      function _w(t, e, n) {
        if (t instanceof Function) {
          return t(e, n);
        } else {
          return n.writer.createElement(t);
        }
      }
      function vw(t) {
        if (typeof t.view == "string") {
          t.view = { key: t.view };
        }
        const e = t.view.key;
        let n;
        if (e == "class" || e == "style") {
          const o = e == "class" ? "classes" : "styles";
          n = { [o]: t.view.value };
        } else {
          const o = typeof t.view.value == "undefined" ? /[\s\S]*/ : t.view.value;
          n = { attributes: { [e]: o } };
        }
        if (t.view.name) {
          n.name = t.view.name;
        }
        t.view = n;
        return e;
      }
      function Aw(t, e = null) {
        const n = e === null ? true : (t) => t.getAttribute(e);
        const o = typeof t.model != "object" ? t.model : t.model.key;
        const i =
          typeof t.model != "object" || typeof t.model.value == "undefined" ? n : t.model.value;
        t.model = { key: o, value: i };
      }
      function Cw(t, e) {
        const n = new Ou(t.view);
        return (o, i, r) => {
          if (!i.modelRange && e) {
            return;
          }
          const s = n.match(i.viewItem);
          if (!s) {
            return;
          }
          if (yw(t.view, i.viewItem)) {
            s.match.name = true;
          } else {
            delete s.match.name;
          }
          if (!r.consumable.test(i.viewItem, s.match)) {
            return;
          }
          const a = t.model.key;
          const c =
            typeof t.model.value == "function" ? t.model.value(i.viewItem, r) : t.model.value;
          if (c === null) {
            return;
          }
          if (!i.modelRange) {
            Object.assign(i, r.convertChildren(i.viewItem, i.modelCursor));
          }
          const l = xw(i.modelRange, { key: a, value: c }, e, r);
          if (l) {
            if (r.consumable.test(i.viewItem, { name: true })) {
              s.match.name = true;
            }
            r.consumable.consume(i.viewItem, s.match);
          }
        };
      }
      function yw(t, e) {
        const n = typeof t == "function" ? t(e) : t;
        if (typeof n == "object" && !bw(n)) {
          return false;
        }
        return !n.classes && !n.attributes && !n.styles;
      }
      function xw(t, e, n, o) {
        let i = false;
        for (const r of Array.from(t.getItems({ shallow: n }))) {
          if (!o.schema.checkAttribute(r, e.key)) {
            continue;
          }
          i = true;
          if (r.hasAttribute(e.key)) {
            continue;
          }
          o.writer.setAttribute(e.key, e.value, r);
        }
        return i;
      }
      function Ew(t) {
        return (e, n) => {
          const o = typeof t == "string" ? t : t(e, n);
          return n.writer.createElement("$marker", { "data-name": o });
        };
      }
      function Dw(t, e) {
        const n = (e, n) => {
          const o = e.getAttribute("name");
          const i = t.model(o, n);
          return n.writer.createElement("$marker", { "data-name": i });
        };
        return { view: `${t.view}-${e}`, model: n };
      }
      function Sw(t) {
        t.document.registerPostFixer((e) => Tw(e, t));
      }
      function Tw(t, e) {
        const n = e.document.selection;
        const o = e.schema;
        const i = [];
        let r = false;
        for (const t of n.getRanges()) {
          const e = Pw(t, o);
          if (e && !e.isEqual(t)) {
            i.push(e);
            r = true;
          } else {
            i.push(t);
          }
        }
        if (r) {
          t.setSelection(zw(i), { backward: n.isBackward });
        }
        return false;
      }
      function Pw(t, e) {
        if (t.isCollapsed) {
          return Bw(t, e);
        }
        return Ow(t, e);
      }
      function Bw(t, e) {
        const n = t.start;
        const o = e.getNearestSelectionRange(n);
        if (!o) {
          const t = n
            .getAncestors()
            .reverse()
            .find((t) => e.isObject(t));
          if (t) {
            return qk._createOn(t);
          }
          return null;
        }
        if (!o.isCollapsed) {
          return o;
        }
        const i = o.start;
        if (n.isEqual(i)) {
          return null;
        }
        return new qk(i);
      }
      function Ow(t, e) {
        const { start: n, end: o } = t;
        const i = e.checkChild(n, "$text");
        const r = e.checkChild(o, "$text");
        const s = e.getLimitElement(n);
        const a = e.getLimitElement(o);
        if (s === a) {
          if (i && r) {
            return null;
          }
          if (Iw(n, o, e)) {
            const t = n.nodeAfter && e.isSelectable(n.nodeAfter);
            const i = t ? null : e.getNearestSelectionRange(n, "forward");
            const r = o.nodeBefore && e.isSelectable(o.nodeBefore);
            const s = r ? null : e.getNearestSelectionRange(o, "backward");
            const a = i ? i.start : n;
            const c = s ? s.end : o;
            return new qk(a, c);
          }
        }
        const c = s && !s.is("rootElement");
        const l = a && !a.is("rootElement");
        if (c || l) {
          const t = n.nodeAfter && o.nodeBefore && n.nodeAfter.parent === o.nodeBefore.parent;
          const i = c && (!t || !Fw(n.nodeAfter, e));
          const r = l && (!t || !Fw(o.nodeBefore, e));
          let d = n;
          let h = o;
          if (i) {
            d = Fk._createBefore(Rw(s, e));
          }
          if (r) {
            h = Fk._createAfter(Rw(a, e));
          }
          return new qk(d, h);
        }
        return null;
      }
      function Rw(t, e) {
        let n = t;
        let o = n;
        while (e.isLimit(o) && o.parent) {
          n = o;
          o = o.parent;
        }
        return n;
      }
      function Iw(t, e, n) {
        const o = (t.nodeAfter && !n.isLimit(t.nodeAfter)) || n.checkChild(t, "$text");
        const i = (e.nodeBefore && !n.isLimit(e.nodeBefore)) || n.checkChild(e, "$text");
        return o || i;
      }
      function zw(t) {
        const e = [...t];
        const n = new Set();
        let o = 1;
        while (o < e.length) {
          const t = e[o];
          const i = e.slice(0, o);
          for (const [r, s] of i.entries()) {
            if (n.has(r)) {
              continue;
            }
            if (t.isEqual(s)) {
              n.add(r);
            } else if (t.isIntersecting(s)) {
              n.add(r);
              n.add(o);
              const i = t.getJoined(s);
              e.push(i);
            }
          }
          o++;
        }
        const i = e.filter((t, e) => !n.has(e));
        return i;
      }
      function Fw(t, e) {
        return t && e.isSelectable(t);
      }
      class Mw extends lt() {
        constructor(t, e) {
          super();
          this.model = t;
          this.view = new Ek(e);
          this.mapper = new $k();
          this.downcastDispatcher = new Kk({ mapper: this.mapper, schema: t.schema });
          const n = this.model.document;
          const o = n.selection;
          const i = this.model.markers;
          this.listenTo(
            this.model,
            "_beforeChanges",
            () => {
              this.view._disableRendering(true);
            },
            { priority: "highest" }
          );
          this.listenTo(
            this.model,
            "_afterChanges",
            () => {
              this.view._disableRendering(false);
            },
            { priority: "lowest" }
          );
          this.listenTo(
            n,
            "change",
            () => {
              this.view.change((t) => {
                this.downcastDispatcher.convertChanges(n.differ, i, t);
                this.downcastDispatcher.convertSelection(o, i, t);
              });
            },
            { priority: "low" }
          );
          this.listenTo(this.view.document, "selectionChange", hw(this.model, this.mapper));
          this.listenTo(
            this.view.document,
            "beforeinput",
            Nw(this.mapper, this.model.schema, this.view),
            { priority: "high" }
          );
          this.downcastDispatcher.on("insert:$text", mb(), { priority: "lowest" });
          this.downcastDispatcher.on("insert", kb(), { priority: "lowest" });
          this.downcastDispatcher.on("remove", bb(), { priority: "low" });
          this.downcastDispatcher.on("cleanSelection", Ab());
          this.downcastDispatcher.on("selection", _b(), { priority: "low" });
          this.downcastDispatcher.on("selection", vb(), { priority: "low" });
          this.view.document.roots.bindTo(this.model.document.roots).using((t) => {
            if (t.rootName == "$graveyard") {
              return null;
            }
            const e = new Fp(this.view.document, t.name);
            e.rootName = t.rootName;
            this.mapper.bindElements(t, e);
            return e;
          });
        }
        destroy() {
          this.view.destroy();
          this.stopListening();
        }
        reconvertMarker(t) {
          const e = typeof t == "string" ? t : t.name;
          const n = this.model.markers.get(e);
          if (!n) {
            throw new P("editingcontroller-reconvertmarker-marker-not-exist", this, {
              markerName: e,
            });
          }
          this.model.change(() => {
            this.model.markers._refresh(n);
          });
        }
        reconvertItem(t) {
          this.model.change(() => {
            this.model.document.differ._refreshItem(t);
          });
        }
      }
      function Nw(t, e, n) {
        return (o, i) => {
          if (n.document.isComposing && !r.isAndroid) {
            return;
          }
          for (let n = 0; n < i.targetRanges.length; n++) {
            const o = i.targetRanges[n];
            const r = t.toModelRange(o);
            const s = Pw(r, e);
            if (!s || s.isEqual(r)) {
              continue;
            }
            i.targetRanges[n] = t.toViewRange(s);
          }
        };
      }
      class Vw {
        constructor() {
          this._consumables = new Map();
        }
        add(t, e) {
          let n;
          if (t.is("$text") || t.is("documentFragment")) {
            this._consumables.set(t, true);
            return;
          }
          if (!this._consumables.has(t)) {
            n = new Hw(t);
            this._consumables.set(t, n);
          } else {
            n = this._consumables.get(t);
          }
          n.add(e);
        }
        test(t, e) {
          const n = this._consumables.get(t);
          if (n === undefined) {
            return null;
          }
          if (t.is("$text") || t.is("documentFragment")) {
            return n;
          }
          return n.test(e);
        }
        consume(t, e) {
          if (this.test(t, e)) {
            if (t.is("$text") || t.is("documentFragment")) {
              this._consumables.set(t, false);
            } else {
              this._consumables.get(t).consume(e);
            }
            return true;
          }
          return false;
        }
        revert(t, e) {
          const n = this._consumables.get(t);
          if (n !== undefined) {
            if (t.is("$text") || t.is("documentFragment")) {
              this._consumables.set(t, true);
            } else {
              n.revert(e);
            }
          }
        }
        static consumablesFromElement(t) {
          const e = { element: t, name: true, attributes: [], classes: [], styles: [] };
          const n = t.getAttributeKeys();
          for (const t of n) {
            if (t == "style" || t == "class") {
              continue;
            }
            e.attributes.push(t);
          }
          const o = t.getClassNames();
          for (const t of o) {
            e.classes.push(t);
          }
          const i = t.getStyleNames();
          for (const t of i) {
            e.styles.push(t);
          }
          return e;
        }
        static createFrom(t, e) {
          if (!e) {
            e = new Vw();
          }
          if (t.is("$text")) {
            e.add(t);
            return e;
          }
          if (t.is("element")) {
            e.add(t, Vw.consumablesFromElement(t));
          }
          if (t.is("documentFragment")) {
            e.add(t);
          }
          for (const n of t.getChildren()) {
            e = Vw.createFrom(n, e);
          }
          return e;
        }
      }
      const Lw = ["attributes", "classes", "styles"];
      class Hw {
        constructor(t) {
          this.element = t;
          this._canConsumeName = null;
          this._consumables = { attributes: new Map(), styles: new Map(), classes: new Map() };
        }
        add(t) {
          if (t.name) {
            this._canConsumeName = true;
          }
          for (const e of Lw) {
            if (e in t) {
              this._add(e, t[e]);
            }
          }
        }
        test(t) {
          if (t.name && !this._canConsumeName) {
            return this._canConsumeName;
          }
          for (const e of Lw) {
            if (e in t) {
              const n = this._test(e, t[e]);
              if (n !== true) {
                return n;
              }
            }
          }
          return true;
        }
        consume(t) {
          if (t.name) {
            this._canConsumeName = false;
          }
          for (const e of Lw) {
            if (e in t) {
              this._consume(e, t[e]);
            }
          }
        }
        revert(t) {
          if (t.name) {
            this._canConsumeName = true;
          }
          for (const e of Lw) {
            if (e in t) {
              this._revert(e, t[e]);
            }
          }
        }
        _add(t, e) {
          const n = Kt(e) ? e : [e];
          const o = this._consumables[t];
          for (const e of n) {
            if (t === "attributes" && (e === "class" || e === "style")) {
              throw new P("viewconsumable-invalid-attribute", this);
            }
            o.set(e, true);
            if (t === "styles") {
              for (const t of this.element.document.stylesProcessor.getRelatedStyles(e)) {
                o.set(t, true);
              }
            }
          }
        }
        _test(t, e) {
          const n = Kt(e) ? e : [e];
          const o = this._consumables[t];
          for (const e of n) {
            if (t === "attributes" && (e === "class" || e === "style")) {
              const t = e == "class" ? "classes" : "styles";
              const n = this._test(t, [...this._consumables[t].keys()]);
              if (n !== true) {
                return n;
              }
            } else {
              const t = o.get(e);
              if (t === undefined) {
                return null;
              }
              if (!t) {
                return false;
              }
            }
          }
          return true;
        }
        _consume(t, e) {
          const n = Kt(e) ? e : [e];
          const o = this._consumables[t];
          for (const e of n) {
            if (t === "attributes" && (e === "class" || e === "style")) {
              const t = e == "class" ? "classes" : "styles";
              this._consume(t, [...this._consumables[t].keys()]);
            } else {
              o.set(e, false);
              if (t == "styles") {
                for (const t of this.element.document.stylesProcessor.getRelatedStyles(e)) {
                  o.set(t, false);
                }
              }
            }
          }
        }
        _revert(t, e) {
          const n = Kt(e) ? e : [e];
          const o = this._consumables[t];
          for (const e of n) {
            if (t === "attributes" && (e === "class" || e === "style")) {
              const t = e == "class" ? "classes" : "styles";
              this._revert(t, [...this._consumables[t].keys()]);
            } else {
              const t = o.get(e);
              if (t === false) {
                o.set(e, true);
              }
            }
          }
        }
      }
      class jw extends lt() {
        constructor() {
          super();
          this._sourceDefinitions = {};
          this._attributeProperties = {};
          this.decorate("checkChild");
          this.decorate("checkAttribute");
          this.on(
            "checkAttribute",
            (t, e) => {
              e[0] = new qw(e[0]);
            },
            { priority: "highest" }
          );
          this.on(
            "checkChild",
            (t, e) => {
              e[0] = new qw(e[0]);
              e[1] = this.getDefinition(e[1]);
            },
            { priority: "highest" }
          );
        }
        register(t, e) {
          if (this._sourceDefinitions[t]) {
            throw new P("schema-cannot-register-item-twice", this, { itemName: t });
          }
          this._sourceDefinitions[t] = [Object.assign({}, e)];
          this._clearCache();
        }
        extend(t, e) {
          if (!this._sourceDefinitions[t]) {
            throw new P("schema-cannot-extend-missing-item", this, { itemName: t });
          }
          this._sourceDefinitions[t].push(Object.assign({}, e));
          this._clearCache();
        }
        getDefinitions() {
          if (!this._compiledDefinitions) {
            this._compile();
          }
          return this._compiledDefinitions;
        }
        getDefinition(t) {
          let e;
          if (typeof t == "string") {
            e = t;
          } else if ("is" in t && (t.is("$text") || t.is("$textProxy"))) {
            e = "$text";
          } else {
            e = t.name;
          }
          return this.getDefinitions()[e];
        }
        isRegistered(t) {
          return !!this.getDefinition(t);
        }
        isBlock(t) {
          const e = this.getDefinition(t);
          return !!(e && e.isBlock);
        }
        isLimit(t) {
          const e = this.getDefinition(t);
          if (!e) {
            return false;
          }
          return !!(e.isLimit || e.isObject);
        }
        isObject(t) {
          const e = this.getDefinition(t);
          if (!e) {
            return false;
          }
          return !!(e.isObject || (e.isLimit && e.isSelectable && e.isContent));
        }
        isInline(t) {
          const e = this.getDefinition(t);
          return !!(e && e.isInline);
        }
        isSelectable(t) {
          const e = this.getDefinition(t);
          if (!e) {
            return false;
          }
          return !!(e.isSelectable || e.isObject);
        }
        isContent(t) {
          const e = this.getDefinition(t);
          if (!e) {
            return false;
          }
          return !!(e.isContent || e.isObject);
        }
        checkChild(t, e) {
          if (!e) {
            return false;
          }
          return this._checkContextMatch(e, t);
        }
        checkAttribute(t, e) {
          const n = this.getDefinition(t.last);
          if (!n) {
            return false;
          }
          return n.allowAttributes.includes(e);
        }
        checkMerge(t, e) {
          if (t instanceof Fk) {
            const e = t.nodeBefore;
            const n = t.nodeAfter;
            if (!(e instanceof Ok)) {
              throw new P("schema-check-merge-no-element-before", this);
            }
            if (!(n instanceof Ok)) {
              throw new P("schema-check-merge-no-element-after", this);
            }
            return this.checkMerge(e, n);
          }
          for (const n of e.getChildren()) {
            if (!this.checkChild(t, n)) {
              return false;
            }
          }
          return true;
        }
        addChildCheck(t) {
          this.on(
            "checkChild",
            (e, [n, o]) => {
              if (!o) {
                return;
              }
              const i = t(n, o);
              if (typeof i == "boolean") {
                e.stop();
                e.return = i;
              }
            },
            { priority: "high" }
          );
        }
        addAttributeCheck(t) {
          this.on(
            "checkAttribute",
            (e, [n, o]) => {
              const i = t(n, o);
              if (typeof i == "boolean") {
                e.stop();
                e.return = i;
              }
            },
            { priority: "high" }
          );
        }
        setAttributeProperties(t, e) {
          this._attributeProperties[t] = Object.assign(this.getAttributeProperties(t), e);
        }
        getAttributeProperties(t) {
          return this._attributeProperties[t] || {};
        }
        getLimitElement(t) {
          let e;
          if (t instanceof Fk) {
            e = t.parent;
          } else {
            const n = t instanceof qk ? [t] : Array.from(t.getRanges());
            e = n.reduce((t, e) => {
              const n = e.getCommonAncestor();
              if (!t) {
                return n;
              }
              return t.getCommonAncestor(n, { includeSelf: true });
            }, null);
          }
          while (!this.isLimit(e)) {
            if (e.parent) {
              e = e.parent;
            } else {
              break;
            }
          }
          return e;
        }
        checkAttributeInSelection(t, e) {
          if (t.isCollapsed) {
            const n = t.getFirstPosition();
            const o = [...n.getAncestors(), new Pk("", t.getAttributes())];
            return this.checkAttribute(o, e);
          } else {
            const n = t.getRanges();
            for (const t of n) {
              for (const n of t) {
                if (this.checkAttribute(n.item, e)) {
                  return true;
                }
              }
            }
          }
          return false;
        }
        *getValidRanges(t, e) {
          t = s_(t);
          for (const n of t) {
            yield* this._getValidRangesForRange(n, e);
          }
        }
        getNearestSelectionRange(t, e = "both") {
          if (t.root.rootName == "$graveyard") {
            return null;
          }
          if (this.checkChild(t, "$text")) {
            return new qk(t);
          }
          let n, o;
          const i =
            t
              .getAncestors()
              .reverse()
              .find((t) => this.isLimit(t)) || t.root;
          if (e == "both" || e == "backward") {
            n = new Ik({ boundaries: qk._createIn(i), startPosition: t, direction: "backward" });
          }
          if (e == "both" || e == "forward") {
            o = new Ik({ boundaries: qk._createIn(i), startPosition: t });
          }
          for (const t of r_(n, o)) {
            const e = t.walker == n ? "elementEnd" : "elementStart";
            const o = t.value;
            if (o.type == e && this.isObject(o.item)) {
              return qk._createOn(o.item);
            }
            if (this.checkChild(o.nextPosition, "$text")) {
              return new qk(o.nextPosition);
            }
          }
          return null;
        }
        findAllowedParent(t, e) {
          let n = t.parent;
          while (n) {
            if (this.checkChild(n, e)) {
              return n;
            }
            if (this.isLimit(n)) {
              return null;
            }
            n = n.parent;
          }
          return null;
        }
        setAllowedAttributes(t, e, n) {
          const o = n.model;
          for (const [i, r] of Object.entries(e)) {
            if (o.schema.checkAttribute(t, i)) {
              n.setAttribute(i, r, t);
            }
          }
        }
        removeDisallowedAttributes(t, e) {
          for (const n of t) {
            if (n.is("$text")) {
              a_(this, n, e);
            } else {
              const t = qk._createIn(n);
              const o = t.getPositions();
              for (const t of o) {
                const n = t.nodeBefore || t.parent;
                a_(this, n, e);
              }
            }
          }
        }
        getAttributesWithProperty(t, e, n) {
          const o = {};
          for (const [i, r] of t.getAttributes()) {
            const t = this.getAttributeProperties(i);
            if (t[e] === undefined) {
              continue;
            }
            if (n === undefined || n === t[e]) {
              o[i] = r;
            }
          }
          return o;
        }
        createContext(t) {
          return new qw(t);
        }
        _clearCache() {
          this._compiledDefinitions = null;
        }
        _compile() {
          const t = {};
          const e = this._sourceDefinitions;
          const n = Object.keys(e);
          for (const o of n) {
            t[o] = $w(e[o], o);
          }
          for (const e of n) {
            Ww(t, e);
          }
          for (const e of n) {
            Gw(t, e);
          }
          for (const e of n) {
            Kw(t, e);
          }
          for (const e of n) {
            Uw(t, e);
            Zw(t, e);
          }
          for (const e of n) {
            Jw(t, e);
            Yw(t, e);
            Qw(t, e);
          }
          this._compiledDefinitions = t;
        }
        _checkContextMatch(t, e, n = e.length - 1) {
          const o = e.getItem(n);
          if (t.allowIn.includes(o.name)) {
            if (n == 0) {
              return true;
            } else {
              const t = this.getDefinition(o);
              return this._checkContextMatch(t, e, n - 1);
            }
          } else {
            return false;
          }
        }
        *_getValidRangesForRange(t, e) {
          let n = t.start;
          let o = t.start;
          for (const i of t.getItems({ shallow: true })) {
            if (i.is("element")) {
              yield* this._getValidRangesForRange(qk._createIn(i), e);
            }
            if (!this.checkAttribute(i, e)) {
              if (!n.isEqual(o)) {
                yield new qk(n, o);
              }
              n = Fk._createAfter(i);
            }
            o = Fk._createAfter(i);
          }
          if (!n.isEqual(o)) {
            yield new qk(n, o);
          }
        }
      }
      class qw {
        constructor(t) {
          if (t instanceof qw) {
            return t;
          }
          let e;
          if (typeof t == "string") {
            e = [t];
          } else if (!Array.isArray(t)) {
            e = t.getAncestors({ includeSelf: true });
          } else {
            e = t;
          }
          this._items = e.map(i_);
        }
        get length() {
          return this._items.length;
        }
        get last() {
          return this._items[this._items.length - 1];
        }
        [Symbol.iterator]() {
          return this._items[Symbol.iterator]();
        }
        push(t) {
          const e = new qw([t]);
          e._items = [...this._items, ...e._items];
          return e;
        }
        getItem(t) {
          return this._items[t];
        }
        *getNames() {
          yield* this._items.map((t) => t.name);
        }
        endsWith(t) {
          return Array.from(this.getNames()).join(" ").endsWith(t);
        }
        startsWith(t) {
          return Array.from(this.getNames()).join(" ").startsWith(t);
        }
      }
      function $w(t, e) {
        const n = {
          name: e,
          allowIn: [],
          allowContentOf: [],
          allowWhere: [],
          allowAttributes: [],
          allowAttributesOf: [],
          allowChildren: [],
          inheritTypesFrom: [],
        };
        Xw(t, n);
        t_(t, n, "allowIn");
        t_(t, n, "allowContentOf");
        t_(t, n, "allowWhere");
        t_(t, n, "allowAttributes");
        t_(t, n, "allowAttributesOf");
        t_(t, n, "allowChildren");
        t_(t, n, "inheritTypesFrom");
        e_(t, n);
        return n;
      }
      function Ww(t, e) {
        const n = t[e];
        for (const o of n.allowChildren) {
          const n = t[o];
          if (!n) {
            continue;
          }
          n.allowIn.push(e);
        }
        n.allowChildren.length = 0;
      }
      function Gw(t, e) {
        for (const n of t[e].allowContentOf) {
          if (t[n]) {
            const o = n_(t, n);
            o.forEach((t) => {
              t.allowIn.push(e);
            });
          }
        }
        delete t[e].allowContentOf;
      }
      function Kw(t, e) {
        for (const n of t[e].allowWhere) {
          const o = t[n];
          if (o) {
            const n = o.allowIn;
            t[e].allowIn.push(...n);
          }
        }
        delete t[e].allowWhere;
      }
      function Uw(t, e) {
        for (const n of t[e].allowAttributesOf) {
          const o = t[n];
          if (o) {
            const n = o.allowAttributes;
            t[e].allowAttributes.push(...n);
          }
        }
        delete t[e].allowAttributesOf;
      }
      function Zw(t, e) {
        const n = t[e];
        for (const e of n.inheritTypesFrom) {
          const o = t[e];
          if (o) {
            const t = Object.keys(o).filter((t) => t.startsWith("is"));
            for (const e of t) {
              if (!(e in n)) {
                n[e] = o[e];
              }
            }
          }
        }
        delete n.inheritTypesFrom;
      }
      function Jw(t, e) {
        const n = t[e];
        const o = n.allowIn.filter((e) => t[e]);
        n.allowIn = Array.from(new Set(o));
      }
      function Yw(t, e) {
        const n = t[e];
        for (const o of n.allowIn) {
          const n = t[o];
          n.allowChildren.push(e);
        }
      }
      function Qw(t, e) {
        const n = t[e];
        n.allowAttributes = Array.from(new Set(n.allowAttributes));
      }
      function Xw(t, e) {
        for (const n of t) {
          const t = Object.keys(n).filter((t) => t.startsWith("is"));
          for (const o of t) {
            e[o] = !!n[o];
          }
        }
      }
      function t_(t, e, n) {
        for (const o of t) {
          const t = o[n];
          if (typeof t == "string") {
            e[n].push(t);
          } else if (Array.isArray(t)) {
            e[n].push(...t);
          }
        }
      }
      function e_(t, e) {
        for (const n of t) {
          const t = n.inheritAllFrom;
          if (t) {
            e.allowContentOf.push(t);
            e.allowWhere.push(t);
            e.allowAttributesOf.push(t);
            e.inheritTypesFrom.push(t);
          }
        }
      }
      function n_(t, e) {
        const n = t[e];
        return o_(t).filter((t) => t.allowIn.includes(n.name));
      }
      function o_(t) {
        return Object.keys(t).map((e) => t[e]);
      }
      function i_(t) {
        if (typeof t == "string" || t.is("documentFragment")) {
          return {
            name: typeof t == "string" ? t : "$documentFragment",
            *getAttributeKeys() {},
            getAttribute() {},
          };
        } else {
          return {
            name: t.is("element") ? t.name : "$text",
            *getAttributeKeys() {
              yield* t.getAttributeKeys();
            },
            getAttribute(e) {
              return t.getAttribute(e);
            },
          };
        }
      }
      function* r_(t, e) {
        let n = false;
        while (!n) {
          n = true;
          if (t) {
            const e = t.next();
            if (!e.done) {
              n = false;
              yield { walker: t, value: e.value };
            }
          }
          if (e) {
            const t = e.next();
            if (!t.done) {
              n = false;
              yield { walker: e, value: t.value };
            }
          }
        }
      }
      function* s_(t) {
        for (const e of t) {
          yield* e.getMinimalFlatRanges();
        }
      }
      function a_(t, e, n) {
        for (const o of e.getAttributeKeys()) {
          if (!t.checkAttribute(e, o)) {
            n.removeAttribute(o, e);
          }
        }
      }
      class c_ extends q() {
        constructor(t) {
          super();
          this._splitParts = new Map();
          this._cursorParents = new Map();
          this._modelCursor = null;
          this._emptyElementsToKeep = new Set();
          this.conversionApi = {
            ...t,
            consumable: null,
            writer: null,
            store: null,
            convertItem: (t, e) => this._convertItem(t, e),
            convertChildren: (t, e) => this._convertChildren(t, e),
            safeInsert: (t, e) => this._safeInsert(t, e),
            updateConversionResult: (t, e) => this._updateConversionResult(t, e),
            splitToAllowedParent: (t, e) => this._splitToAllowedParent(t, e),
            getSplitParts: (t) => this._getSplitParts(t),
            keepEmptyElement: (t) => this._keepEmptyElement(t),
          };
        }
        convert(t, e, n = ["$root"]) {
          this.fire("viewCleanup", t);
          this._modelCursor = d_(n, e);
          this.conversionApi.writer = e;
          this.conversionApi.consumable = Vw.createFrom(t);
          this.conversionApi.store = {};
          const { modelRange: o } = this._convertItem(t, this._modelCursor);
          const i = e.createDocumentFragment();
          if (o) {
            this._removeEmptyElements();
            for (const t of Array.from(this._modelCursor.parent.getChildren())) {
              e.append(t, i);
            }
            i.markers = l_(i, e);
          }
          this._modelCursor = null;
          this._splitParts.clear();
          this._cursorParents.clear();
          this._emptyElementsToKeep.clear();
          this.conversionApi.writer = null;
          this.conversionApi.store = null;
          return i;
        }
        _convertItem(t, e) {
          const n = { viewItem: t, modelCursor: e, modelRange: null };
          if (t.is("element")) {
            this.fire(`element:${t.name}`, n, this.conversionApi);
          } else if (t.is("$text")) {
            this.fire("text", n, this.conversionApi);
          } else {
            this.fire("documentFragment", n, this.conversionApi);
          }
          if (n.modelRange && !(n.modelRange instanceof qk)) {
            throw new P("view-conversion-dispatcher-incorrect-result", this);
          }
          return { modelRange: n.modelRange, modelCursor: n.modelCursor };
        }
        _convertChildren(t, e) {
          let n = e.is("position") ? e : Fk._createAt(e, 0);
          const o = new qk(n);
          for (const e of Array.from(t.getChildren())) {
            const t = this._convertItem(e, n);
            if (t.modelRange instanceof qk) {
              o.end = t.modelRange.end;
              n = t.modelCursor;
            }
          }
          return { modelRange: o, modelCursor: n };
        }
        _safeInsert(t, e) {
          const n = this._splitToAllowedParent(t, e);
          if (!n) {
            return false;
          }
          this.conversionApi.writer.insert(t, n.position);
          return true;
        }
        _updateConversionResult(t, e) {
          const n = this._getSplitParts(t);
          const o = this.conversionApi.writer;
          if (!e.modelRange) {
            e.modelRange = o.createRange(
              o.createPositionBefore(t),
              o.createPositionAfter(n[n.length - 1])
            );
          }
          const i = this._cursorParents.get(t);
          if (i) {
            e.modelCursor = o.createPositionAt(i, 0);
          } else {
            e.modelCursor = e.modelRange.end;
          }
        }
        _splitToAllowedParent(t, e) {
          const { schema: n, writer: o } = this.conversionApi;
          let i = n.findAllowedParent(e, t);
          if (i) {
            if (i === e.parent) {
              return { position: e };
            }
            if (this._modelCursor.parent.getAncestors().includes(i)) {
              i = null;
            }
          }
          if (!i) {
            if (!sw(e, t, n)) {
              return null;
            }
            return { position: aw(e, o) };
          }
          const r = this.conversionApi.writer.split(e, i);
          const s = [];
          for (const t of r.range.getWalker()) {
            if (t.type == "elementEnd") {
              s.push(t.item);
            } else {
              const e = s.pop();
              const n = t.item;
              this._registerSplitPair(e, n);
            }
          }
          const a = r.range.end.parent;
          this._cursorParents.set(t, a);
          return { position: r.position, cursorParent: a };
        }
        _registerSplitPair(t, e) {
          if (!this._splitParts.has(t)) {
            this._splitParts.set(t, [t]);
          }
          const n = this._splitParts.get(t);
          this._splitParts.set(e, n);
          n.push(e);
        }
        _getSplitParts(t) {
          let e;
          if (!this._splitParts.has(t)) {
            e = [t];
          } else {
            e = this._splitParts.get(t);
          }
          return e;
        }
        _keepEmptyElement(t) {
          this._emptyElementsToKeep.add(t);
        }
        _removeEmptyElements() {
          let t = false;
          for (const e of this._splitParts.keys()) {
            if (e.isEmpty && !this._emptyElementsToKeep.has(e)) {
              this.conversionApi.writer.remove(e);
              this._splitParts.delete(e);
              t = true;
            }
          }
          if (t) {
            this._removeEmptyElements();
          }
        }
      }
      function l_(t, e) {
        const n = new Set();
        const o = new Map();
        const i = qk._createIn(t).getItems();
        for (const t of i) {
          if (t.is("element", "$marker")) {
            n.add(t);
          }
        }
        for (const t of n) {
          const n = t.getAttribute("data-name");
          const i = e.createPositionBefore(t);
          if (!o.has(n)) {
            o.set(n, new qk(i.clone()));
          } else {
            o.get(n).end = i.clone();
          }
          e.remove(t);
        }
        return o;
      }
      function d_(t, e) {
        let n;
        for (const o of new qw(t)) {
          const t = {};
          for (const e of o.getAttributeKeys()) {
            t[e] = o.getAttribute(e);
          }
          const i = e.createElement(o.name, t);
          if (n) {
            e.insert(i, n);
          }
          n = Fk._createAt(i, 0);
        }
        return n;
      }
      class h_ {
        getHtml(t) {
          const e = document.implementation.createHTMLDocument("");
          const n = e.createElement("div");
          n.appendChild(t);
          return n.innerHTML;
        }
      }
      class u_ {
        constructor(t) {
          this.skipComments = true;
          this.domParser = new DOMParser();
          this.domConverter = new Xg(t, { renderingMode: "data" });
          this.htmlWriter = new h_();
        }
        toData(t) {
          const e = this.domConverter.viewToDom(t);
          return this.htmlWriter.getHtml(e);
        }
        toView(t) {
          const e = this._toDom(t);
          return this.domConverter.domToView(e, { skipComments: this.skipComments });
        }
        registerRawContentMatcher(t) {
          this.domConverter.registerRawContentMatcher(t);
        }
        useFillerType(t) {
          this.domConverter.blockFillerMode = t == "marked" ? "markedNbsp" : "nbsp";
        }
        _toDom(t) {
          if (!t.match(/<(?:html|body|head|meta)(?:\s[^>]*)?>/i)) {
            t = `<body>${t}</body>`;
          }
          const e = this.domParser.parseFromString(t, "text/html");
          const n = e.createDocumentFragment();
          const o = e.body.childNodes;
          while (o.length > 0) {
            n.appendChild(o[0]);
          }
          return n;
        }
      }
      class f_ extends q() {
        constructor(t, e) {
          super();
          this.model = t;
          this.mapper = new $k();
          this.downcastDispatcher = new Kk({ mapper: this.mapper, schema: t.schema });
          this.downcastDispatcher.on("insert:$text", mb(), { priority: "lowest" });
          this.downcastDispatcher.on("insert", kb(), { priority: "lowest" });
          this.upcastDispatcher = new c_({ schema: t.schema });
          this.viewDocument = new Yp(e);
          this.stylesProcessor = e;
          this.htmlProcessor = new u_(this.viewDocument);
          this.processor = this.htmlProcessor;
          this._viewWriter = new ug(this.viewDocument);
          this.upcastDispatcher.on("text", dw(), { priority: "lowest" });
          this.upcastDispatcher.on("element", lw(), { priority: "lowest" });
          this.upcastDispatcher.on("documentFragment", lw(), { priority: "lowest" });
          lt().prototype.decorate.call(this, "init");
          lt().prototype.decorate.call(this, "set");
          lt().prototype.decorate.call(this, "get");
          lt().prototype.decorate.call(this, "toView");
          lt().prototype.decorate.call(this, "toModel");
          this.on(
            "init",
            () => {
              this.fire("ready");
            },
            { priority: "lowest" }
          );
          this.on(
            "ready",
            () => {
              this.model.enqueueChange({ isUndoable: false }, rw);
            },
            { priority: "lowest" }
          );
        }
        get(t = {}) {
          const { rootName: e = "main", trim: n = "empty" } = t;
          if (!this._checkIfRootsExists([e])) {
            throw new P("datacontroller-get-non-existent-root", this);
          }
          const o = this.model.document.getRoot(e);
          if (!o.isAttached()) {
            B("datacontroller-get-detached-root", this);
          }
          if (n === "empty" && !this.model.hasContent(o, { ignoreWhitespaces: true })) {
            return "";
          }
          return this.stringify(o, t);
        }
        stringify(t, e = {}) {
          const n = this.toView(t, e);
          return this.processor.toData(n);
        }
        toView(t, e = {}) {
          const n = this.viewDocument;
          const o = this._viewWriter;
          this.mapper.clearBindings();
          const i = qk._createIn(t);
          const r = new dg(n);
          this.mapper.bindElements(t, r);
          const s = t.is("documentFragment") ? t.markers : p_(t);
          this.downcastDispatcher.convert(i, s, o, e);
          return r;
        }
        init(t) {
          if (this.model.document.version) {
            throw new P("datacontroller-init-document-not-empty", this);
          }
          let e = {};
          if (typeof t === "string") {
            e.main = t;
          } else {
            e = t;
          }
          if (!this._checkIfRootsExists(Object.keys(e))) {
            throw new P("datacontroller-init-non-existent-root", this);
          }
          this.model.enqueueChange({ isUndoable: false }, (t) => {
            for (const n of Object.keys(e)) {
              const o = this.model.document.getRoot(n);
              t.insert(this.parse(e[n], o), o, 0);
            }
          });
          return Promise.resolve();
        }
        set(t, e = {}) {
          let n = {};
          if (typeof t === "string") {
            n.main = t;
          } else {
            n = t;
          }
          if (!this._checkIfRootsExists(Object.keys(n))) {
            throw new P("datacontroller-set-non-existent-root", this);
          }
          this.model.enqueueChange(e.batchType || {}, (t) => {
            t.setSelection(null);
            t.removeSelectionAttribute(this.model.document.selection.getAttributeKeys());
            for (const e of Object.keys(n)) {
              const o = this.model.document.getRoot(e);
              t.remove(t.createRangeIn(o));
              t.insert(this.parse(n[e], o), o, 0);
            }
          });
        }
        parse(t, e = "$root") {
          const n = this.processor.toView(t);
          return this.toModel(n, e);
        }
        toModel(t, e = "$root") {
          return this.model.change((n) => this.upcastDispatcher.convert(t, n, e));
        }
        addStyleProcessorRules(t) {
          t(this.stylesProcessor);
        }
        registerRawContentMatcher(t) {
          if (this.processor && this.processor !== this.htmlProcessor) {
            this.processor.registerRawContentMatcher(t);
          }
          this.htmlProcessor.registerRawContentMatcher(t);
        }
        destroy() {
          this.stopListening();
        }
        _checkIfRootsExists(t) {
          for (const e of t) {
            if (!this.model.document.getRoot(e)) {
              return false;
            }
          }
          return true;
        }
      }
      function p_(t) {
        const e = [];
        const n = t.root.document;
        if (!n) {
          return new Map();
        }
        const o = qk._createIn(t);
        for (const t of n.model.markers) {
          const n = t.getRange();
          const i = n.isCollapsed;
          const r = n.start.isEqual(o.start) || n.end.isEqual(o.end);
          if (i && r) {
            e.push([t.name, n]);
          } else {
            const i = o.getIntersection(n);
            if (i) {
              e.push([t.name, i]);
            }
          }
        }
        e.sort(([t, e], [n, o]) => {
          if (e.end.compareWith(o.start) !== "after") {
            return 1;
          } else if (e.start.compareWith(o.end) !== "before") {
            return -1;
          } else {
            switch (e.start.compareWith(o.start)) {
              case "before":
                return 1;
              case "after":
                return -1;
              default:
                switch (e.end.compareWith(o.end)) {
                  case "before":
                    return 1;
                  case "after":
                    return -1;
                  default:
                    return n.localeCompare(t);
                }
            }
          }
        });
        return new Map(e);
      }
      class g_ {
        constructor(t, e) {
          this._helpers = new Map();
          this._downcast = Xc(t);
          this._createConversionHelpers({
            name: "downcast",
            dispatchers: this._downcast,
            isDowncast: true,
          });
          this._upcast = Xc(e);
          this._createConversionHelpers({
            name: "upcast",
            dispatchers: this._upcast,
            isDowncast: false,
          });
        }
        addAlias(t, e) {
          const n = this._downcast.includes(e);
          const o = this._upcast.includes(e);
          if (!o && !n) {
            throw new P("conversion-add-alias-dispatcher-not-registered", this);
          }
          this._createConversionHelpers({ name: t, dispatchers: [e], isDowncast: n });
        }
        for(t) {
          if (!this._helpers.has(t)) {
            throw new P("conversion-for-unknown-group", this);
          }
          return this._helpers.get(t);
        }
        elementToElement(t) {
          this.for("downcast").elementToElement(t);
          for (const { model: e, view: n } of m_(t)) {
            this.for("upcast").elementToElement({
              model: e,
              view: n,
              converterPriority: t.converterPriority,
            });
          }
        }
        attributeToElement(t) {
          this.for("downcast").attributeToElement(t);
          for (const { model: e, view: n } of m_(t)) {
            this.for("upcast").elementToAttribute({
              view: n,
              model: e,
              converterPriority: t.converterPriority,
            });
          }
        }
        attributeToAttribute(t) {
          this.for("downcast").attributeToAttribute(t);
          for (const { model: e, view: n } of m_(t)) {
            this.for("upcast").attributeToAttribute({ view: n, model: e });
          }
        }
        _createConversionHelpers({ name: t, dispatchers: e, isDowncast: n }) {
          if (this._helpers.has(t)) {
            throw new P("conversion-group-exists", this);
          }
          const o = n ? new gb(e) : new cw(e);
          this._helpers.set(t, o);
        }
      }
      function* m_(t) {
        if (t.model.values) {
          for (const e of t.model.values) {
            const n = { key: t.model.key, value: e };
            const o = t.view[e];
            const i = t.upcastAlso ? t.upcastAlso[e] : undefined;
            yield* k_(n, o, i);
          }
        } else {
          yield* k_(t.model, t.view, t.upcastAlso);
        }
      }
      function* k_(t, e, n) {
        yield { model: t, view: e };
        if (n) {
          for (const e of Xc(n)) {
            yield { model: t, view: e };
          }
        }
      }
      class b_ {
        constructor(t) {
          this.baseVersion = t;
          this.isDocumentOperation = this.baseVersion !== null;
          this.batch = null;
        }
        _validate() {}
        toJSON() {
          const t = Object.assign({}, this);
          t.__className = this.constructor.className;
          delete t.batch;
          delete t.isDocumentOperation;
          return t;
        }
        static get className() {
          return "Operation";
        }
        static fromJSON(t, e) {
          return new this(t.baseVersion);
        }
      }
      function w_(t, e) {
        const n = C_(e);
        const o = n.reduce((t, e) => t + e.offsetSize, 0);
        const i = t.parent;
        x_(t);
        const r = t.index;
        i._insertChild(r, n);
        y_(i, r + n.length);
        y_(i, r);
        return new qk(t, t.getShiftedBy(o));
      }
      function __(t) {
        if (!t.isFlat) {
          throw new P("operation-utils-remove-range-not-flat", this);
        }
        const e = t.start.parent;
        x_(t.start);
        x_(t.end);
        const n = e._removeChildren(t.start.index, t.end.index - t.start.index);
        y_(e, t.start.index);
        return n;
      }
      function v_(t, e) {
        if (!t.isFlat) {
          throw new P("operation-utils-move-range-not-flat", this);
        }
        const n = __(t);
        e = e._getTransformedByDeletion(t.start, t.end.offset - t.start.offset);
        return w_(e, n);
      }
      function A_(t, e, n) {
        x_(t.start);
        x_(t.end);
        for (const o of t.getItems({ shallow: true })) {
          const t = o.is("$textProxy") ? o.textNode : o;
          if (n !== null) {
            t._setAttribute(e, n);
          } else {
            t._removeAttribute(e);
          }
          y_(t.parent, t.index);
        }
        y_(t.end.parent, t.end.index);
      }
      function C_(t) {
        const e = [];
        function n(t) {
          if (typeof t == "string") {
            e.push(new Pk(t));
          } else if (t instanceof Bk) {
            e.push(new Pk(t.data, t.getAttributes()));
          } else if (t instanceof Sk) {
            e.push(t);
          } else if (Ct(t)) {
            for (const e of t) {
              n(e);
            }
          }
        }
        n(t);
        for (let t = 1; t < e.length; t++) {
          const n = e[t];
          const o = e[t - 1];
          if (n instanceof Pk && o instanceof Pk && E_(n, o)) {
            e.splice(t - 1, 2, new Pk(o.data + n.data, o.getAttributes()));
            t--;
          }
        }
        return e;
      }
      function y_(t, e) {
        const n = t.getChild(e - 1);
        const o = t.getChild(e);
        if (n && o && n.is("$text") && o.is("$text") && E_(n, o)) {
          const i = new Pk(n.data + o.data, n.getAttributes());
          t._removeChildren(e - 1, 2);
          t._insertChild(e - 1, i);
        }
      }
      function x_(t) {
        const e = t.textNode;
        const n = t.parent;
        if (e) {
          const o = t.offset - e.startOffset;
          const i = e.index;
          n._removeChildren(i, 1);
          const r = new Pk(e.data.substr(0, o), e.getAttributes());
          const s = new Pk(e.data.substr(o), e.getAttributes());
          n._insertChild(i, [r, s]);
        }
      }
      function E_(t, e) {
        const n = t.getAttributes();
        const o = e.getAttributes();
        for (const t of n) {
          if (t[1] !== e.getAttribute(t[0])) {
            return false;
          }
          o.next();
        }
        return o.next().done;
      }
      class D_ extends b_ {
        constructor(t, e, n, o) {
          super(o);
          this.sourcePosition = t.clone();
          this.sourcePosition.stickiness = "toNext";
          this.howMany = e;
          this.targetPosition = n.clone();
          this.targetPosition.stickiness = "toNone";
        }
        get type() {
          if (this.targetPosition.root.rootName == "$graveyard") {
            return "remove";
          } else if (this.sourcePosition.root.rootName == "$graveyard") {
            return "reinsert";
          }
          return "move";
        }
        get affectedSelectable() {
          return [
            qk._createFromPositionAndShift(this.sourcePosition, this.howMany),
            qk._createFromPositionAndShift(this.targetPosition, 0),
          ];
        }
        clone() {
          return new D_(this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion);
        }
        getMovedRangeStart() {
          return this.targetPosition._getTransformedByDeletion(this.sourcePosition, this.howMany);
        }
        getReversed() {
          const t = this.sourcePosition._getTransformedByInsertion(
            this.targetPosition,
            this.howMany
          );
          return new D_(this.getMovedRangeStart(), this.howMany, t, this.baseVersion + 1);
        }
        _validate() {
          const t = this.sourcePosition.parent;
          const e = this.targetPosition.parent;
          const n = this.sourcePosition.offset;
          const o = this.targetPosition.offset;
          if (n + this.howMany > t.maxOffset) {
            throw new P("move-operation-nodes-do-not-exist", this);
          } else if (t === e && n < o && o < n + this.howMany) {
            throw new P("move-operation-range-into-itself", this);
          } else if (this.sourcePosition.root == this.targetPosition.root) {
            if (
              At(this.sourcePosition.getParentPath(), this.targetPosition.getParentPath()) ==
              "prefix"
            ) {
              const t = this.sourcePosition.path.length - 1;
              if (
                this.targetPosition.path[t] >= n &&
                this.targetPosition.path[t] < n + this.howMany
              ) {
                throw new P("move-operation-node-into-itself", this);
              }
            }
          }
        }
        _execute() {
          v_(
            qk._createFromPositionAndShift(this.sourcePosition, this.howMany),
            this.targetPosition
          );
        }
        toJSON() {
          const t = super.toJSON();
          t.sourcePosition = this.sourcePosition.toJSON();
          t.targetPosition = this.targetPosition.toJSON();
          return t;
        }
        static get className() {
          return "MoveOperation";
        }
        static fromJSON(t, e) {
          const n = Fk.fromJSON(t.sourcePosition, e);
          const o = Fk.fromJSON(t.targetPosition, e);
          return new this(n, t.howMany, o, t.baseVersion);
        }
      }
      class S_ extends b_ {
        constructor(t, e, n) {
          super(n);
          this.position = t.clone();
          this.position.stickiness = "toNone";
          this.nodes = new Tk(C_(e));
          this.shouldReceiveAttributes = false;
        }
        get type() {
          return "insert";
        }
        get howMany() {
          return this.nodes.maxOffset;
        }
        get affectedSelectable() {
          return this.position.clone();
        }
        clone() {
          const t = new Tk([...this.nodes].map((t) => t._clone(true)));
          const e = new S_(this.position, t, this.baseVersion);
          e.shouldReceiveAttributes = this.shouldReceiveAttributes;
          return e;
        }
        getReversed() {
          const t = this.position.root.document.graveyard;
          const e = new Fk(t, [0]);
          return new D_(this.position, this.nodes.maxOffset, e, this.baseVersion + 1);
        }
        _validate() {
          const t = this.position.parent;
          if (!t || t.maxOffset < this.position.offset) {
            throw new P("insert-operation-position-invalid", this);
          }
        }
        _execute() {
          const t = this.nodes;
          this.nodes = new Tk([...t].map((t) => t._clone(true)));
          w_(this.position, t);
        }
        toJSON() {
          const t = super.toJSON();
          t.position = this.position.toJSON();
          t.nodes = this.nodes.toJSON();
          return t;
        }
        static get className() {
          return "InsertOperation";
        }
        static fromJSON(t, e) {
          const n = [];
          for (const e of t.nodes) {
            if (e.name) {
              n.push(Ok.fromJSON(e));
            } else {
              n.push(Pk.fromJSON(e));
            }
          }
          const o = new S_(Fk.fromJSON(t.position, e), n, t.baseVersion);
          o.shouldReceiveAttributes = t.shouldReceiveAttributes;
          return o;
        }
      }
      class T_ extends b_ {
        constructor(t, e, n, o, i) {
          super(i);
          this.splitPosition = t.clone();
          this.splitPosition.stickiness = "toNext";
          this.howMany = e;
          this.insertionPosition = n;
          this.graveyardPosition = o ? o.clone() : null;
          if (this.graveyardPosition) {
            this.graveyardPosition.stickiness = "toNext";
          }
        }
        get type() {
          return "split";
        }
        get moveTargetPosition() {
          const t = this.insertionPosition.path.slice();
          t.push(0);
          return new Fk(this.insertionPosition.root, t);
        }
        get movedRange() {
          const t = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);
          return new qk(this.splitPosition, t);
        }
        get affectedSelectable() {
          const t = [
            qk._createFromPositionAndShift(this.splitPosition, 0),
            qk._createFromPositionAndShift(this.insertionPosition, 0),
          ];
          if (this.graveyardPosition) {
            t.push(qk._createFromPositionAndShift(this.graveyardPosition, 0));
          }
          return t;
        }
        clone() {
          return new T_(
            this.splitPosition,
            this.howMany,
            this.insertionPosition,
            this.graveyardPosition,
            this.baseVersion
          );
        }
        getReversed() {
          const t = this.splitPosition.root.document.graveyard;
          const e = new Fk(t, [0]);
          return new P_(
            this.moveTargetPosition,
            this.howMany,
            this.splitPosition,
            e,
            this.baseVersion + 1
          );
        }
        _validate() {
          const t = this.splitPosition.parent;
          const e = this.splitPosition.offset;
          if (!t || t.maxOffset < e) {
            throw new P("split-operation-position-invalid", this);
          } else if (!t.parent) {
            throw new P("split-operation-split-in-root", this);
          } else if (this.howMany != t.maxOffset - this.splitPosition.offset) {
            throw new P("split-operation-how-many-invalid", this);
          } else if (this.graveyardPosition && !this.graveyardPosition.nodeAfter) {
            throw new P("split-operation-graveyard-position-invalid", this);
          }
        }
        _execute() {
          const t = this.splitPosition.parent;
          if (this.graveyardPosition) {
            v_(qk._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition);
          } else {
            const e = t._clone();
            w_(this.insertionPosition, e);
          }
          const e = new qk(
            Fk._createAt(t, this.splitPosition.offset),
            Fk._createAt(t, t.maxOffset)
          );
          v_(e, this.moveTargetPosition);
        }
        toJSON() {
          const t = super.toJSON();
          t.splitPosition = this.splitPosition.toJSON();
          t.insertionPosition = this.insertionPosition.toJSON();
          if (this.graveyardPosition) {
            t.graveyardPosition = this.graveyardPosition.toJSON();
          }
          return t;
        }
        static get className() {
          return "SplitOperation";
        }
        static getInsertionPosition(t) {
          const e = t.path.slice(0, -1);
          e[e.length - 1]++;
          return new Fk(t.root, e, "toPrevious");
        }
        static fromJSON(t, e) {
          const n = Fk.fromJSON(t.splitPosition, e);
          const o = Fk.fromJSON(t.insertionPosition, e);
          const i = t.graveyardPosition ? Fk.fromJSON(t.graveyardPosition, e) : null;
          return new this(n, t.howMany, o, i, t.baseVersion);
        }
      }
      class P_ extends b_ {
        constructor(t, e, n, o, i) {
          super(i);
          this.sourcePosition = t.clone();
          this.sourcePosition.stickiness = "toPrevious";
          this.howMany = e;
          this.targetPosition = n.clone();
          this.targetPosition.stickiness = "toNext";
          this.graveyardPosition = o.clone();
        }
        get type() {
          return "merge";
        }
        get deletionPosition() {
          return new Fk(this.sourcePosition.root, this.sourcePosition.path.slice(0, -1));
        }
        get movedRange() {
          const t = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);
          return new qk(this.sourcePosition, t);
        }
        get affectedSelectable() {
          const t = this.sourcePosition.parent;
          return [
            qk._createOn(t),
            qk._createFromPositionAndShift(this.targetPosition, 0),
            qk._createFromPositionAndShift(this.graveyardPosition, 0),
          ];
        }
        clone() {
          return new P_(
            this.sourcePosition,
            this.howMany,
            this.targetPosition,
            this.graveyardPosition,
            this.baseVersion
          );
        }
        getReversed() {
          const t = this.targetPosition._getTransformedByMergeOperation(this);
          const e = this.sourcePosition.path.slice(0, -1);
          const n = new Fk(this.sourcePosition.root, e)._getTransformedByMergeOperation(this);
          return new T_(t, this.howMany, n, this.graveyardPosition, this.baseVersion + 1);
        }
        _validate() {
          const t = this.sourcePosition.parent;
          const e = this.targetPosition.parent;
          if (!t.parent) {
            throw new P("merge-operation-source-position-invalid", this);
          } else if (!e.parent) {
            throw new P("merge-operation-target-position-invalid", this);
          } else if (this.howMany != t.maxOffset) {
            throw new P("merge-operation-how-many-invalid", this);
          }
        }
        _execute() {
          const t = this.sourcePosition.parent;
          const e = qk._createIn(t);
          v_(e, this.targetPosition);
          v_(qk._createOn(t), this.graveyardPosition);
        }
        toJSON() {
          const t = super.toJSON();
          t.sourcePosition = t.sourcePosition.toJSON();
          t.targetPosition = t.targetPosition.toJSON();
          t.graveyardPosition = t.graveyardPosition.toJSON();
          return t;
        }
        static get className() {
          return "MergeOperation";
        }
        static fromJSON(t, e) {
          const n = Fk.fromJSON(t.sourcePosition, e);
          const o = Fk.fromJSON(t.targetPosition, e);
          const i = Fk.fromJSON(t.graveyardPosition, e);
          return new this(n, t.howMany, o, i, t.baseVersion);
        }
      }
      class B_ extends b_ {
        constructor(t, e, n, o, i, r) {
          super(r);
          this.name = t;
          this.oldRange = e ? e.clone() : null;
          this.newRange = n ? n.clone() : null;
          this.affectsData = i;
          this._markers = o;
        }
        get type() {
          return "marker";
        }
        get affectedSelectable() {
          const t = [];
          if (this.oldRange) {
            t.push(this.oldRange.clone());
          }
          if (this.newRange) {
            if (this.oldRange) {
              t.push(...this.newRange.getDifference(this.oldRange));
            } else {
              t.push(this.newRange.clone());
            }
          }
          return t;
        }
        clone() {
          return new B_(
            this.name,
            this.oldRange,
            this.newRange,
            this._markers,
            this.affectsData,
            this.baseVersion
          );
        }
        getReversed() {
          return new B_(
            this.name,
            this.newRange,
            this.oldRange,
            this._markers,
            this.affectsData,
            this.baseVersion + 1
          );
        }
        _execute() {
          if (this.newRange) {
            this._markers._set(this.name, this.newRange, true, this.affectsData);
          } else {
            this._markers._remove(this.name);
          }
        }
        toJSON() {
          const t = super.toJSON();
          if (this.oldRange) {
            t.oldRange = this.oldRange.toJSON();
          }
          if (this.newRange) {
            t.newRange = this.newRange.toJSON();
          }
          delete t._markers;
          return t;
        }
        static get className() {
          return "MarkerOperation";
        }
        static fromJSON(t, e) {
          return new B_(
            t.name,
            t.oldRange ? qk.fromJSON(t.oldRange, e) : null,
            t.newRange ? qk.fromJSON(t.newRange, e) : null,
            e.model.markers,
            t.affectsData,
            t.baseVersion
          );
        }
      }
      function O_(t, e) {
        return lk(t, e);
      }
      const R_ = O_;
      class I_ extends b_ {
        constructor(t, e, n, o, i) {
          super(i);
          this.range = t.clone();
          this.key = e;
          this.oldValue = n === undefined ? null : n;
          this.newValue = o === undefined ? null : o;
        }
        get type() {
          if (this.oldValue === null) {
            return "addAttribute";
          } else if (this.newValue === null) {
            return "removeAttribute";
          } else {
            return "changeAttribute";
          }
        }
        get affectedSelectable() {
          return this.range.clone();
        }
        clone() {
          return new I_(this.range, this.key, this.oldValue, this.newValue, this.baseVersion);
        }
        getReversed() {
          return new I_(this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
        }
        toJSON() {
          const t = super.toJSON();
          t.range = this.range.toJSON();
          return t;
        }
        _validate() {
          if (!this.range.isFlat) {
            throw new P("attribute-operation-range-not-flat", this);
          }
          for (const t of this.range.getItems({ shallow: true })) {
            if (this.oldValue !== null && !R_(t.getAttribute(this.key), this.oldValue)) {
              throw new P("attribute-operation-wrong-old-value", this, {
                item: t,
                key: this.key,
                value: this.oldValue,
              });
            }
            if (this.oldValue === null && this.newValue !== null && t.hasAttribute(this.key)) {
              throw new P("attribute-operation-attribute-exists", this, { node: t, key: this.key });
            }
          }
        }
        _execute() {
          if (!R_(this.oldValue, this.newValue)) {
            A_(this.range, this.key, this.newValue);
          }
        }
        static get className() {
          return "AttributeOperation";
        }
        static fromJSON(t, e) {
          return new I_(qk.fromJSON(t.range, e), t.key, t.oldValue, t.newValue, t.baseVersion);
        }
      }
      class z_ extends b_ {
        get type() {
          return "noop";
        }
        get affectedSelectable() {
          return null;
        }
        clone() {
          return new z_(this.baseVersion);
        }
        getReversed() {
          return new z_(this.baseVersion + 1);
        }
        _execute() {}
        static get className() {
          return "NoOperation";
        }
      }
      class F_ extends b_ {
        constructor(t, e, n, o) {
          super(o);
          this.position = t;
          this.position.stickiness = "toNext";
          this.oldName = e;
          this.newName = n;
        }
        get type() {
          return "rename";
        }
        get affectedSelectable() {
          return this.position.nodeAfter;
        }
        clone() {
          return new F_(this.position.clone(), this.oldName, this.newName, this.baseVersion);
        }
        getReversed() {
          return new F_(this.position.clone(), this.newName, this.oldName, this.baseVersion + 1);
        }
        _validate() {
          const t = this.position.nodeAfter;
          if (!(t instanceof Ok)) {
            throw new P("rename-operation-wrong-position", this);
          } else if (t.name !== this.oldName) {
            throw new P("rename-operation-wrong-name", this);
          }
        }
        _execute() {
          const t = this.position.nodeAfter;
          t.name = this.newName;
        }
        toJSON() {
          const t = super.toJSON();
          t.position = this.position.toJSON();
          return t;
        }
        static get className() {
          return "RenameOperation";
        }
        static fromJSON(t, e) {
          return new F_(Fk.fromJSON(t.position, e), t.oldName, t.newName, t.baseVersion);
        }
      }
      class M_ extends b_ {
        constructor(t, e, n, o, i) {
          super(i);
          this.root = t;
          this.key = e;
          this.oldValue = n === undefined ? null : n;
          this.newValue = o === undefined ? null : o;
        }
        get type() {
          if (this.oldValue === null) {
            return "addRootAttribute";
          } else if (this.newValue === null) {
            return "removeRootAttribute";
          } else {
            return "changeRootAttribute";
          }
        }
        get affectedSelectable() {
          return this.root;
        }
        clone() {
          return new M_(this.root, this.key, this.oldValue, this.newValue, this.baseVersion);
        }
        getReversed() {
          return new M_(this.root, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
        }
        _validate() {
          if (this.root != this.root.root || this.root.is("documentFragment")) {
            throw new P("rootattribute-operation-not-a-root", this, {
              root: this.root,
              key: this.key,
            });
          }
          if (this.oldValue !== null && this.root.getAttribute(this.key) !== this.oldValue) {
            throw new P("rootattribute-operation-wrong-old-value", this, {
              root: this.root,
              key: this.key,
            });
          }
          if (
            this.oldValue === null &&
            this.newValue !== null &&
            this.root.hasAttribute(this.key)
          ) {
            throw new P("rootattribute-operation-attribute-exists", this, {
              root: this.root,
              key: this.key,
            });
          }
        }
        _execute() {
          if (this.newValue !== null) {
            this.root._setAttribute(this.key, this.newValue);
          } else {
            this.root._removeAttribute(this.key);
          }
        }
        toJSON() {
          const t = super.toJSON();
          t.root = this.root.toJSON();
          return t;
        }
        static get className() {
          return "RootAttributeOperation";
        }
        static fromJSON(t, e) {
          if (!e.getRoot(t.root)) {
            throw new P("rootattribute-operation-fromjson-no-root", this, { rootName: t.root });
          }
          return new M_(e.getRoot(t.root), t.key, t.oldValue, t.newValue, t.baseVersion);
        }
      }
      class N_ extends b_ {
        constructor(t, e, n, o, i) {
          super(i);
          this.rootName = t;
          this.elementName = e;
          this.isAdd = n;
          this._document = o;
          if (!this._document.getRoot(this.rootName)) {
            const t = this._document.createRoot(this.elementName, this.rootName);
            t._isAttached = false;
          }
        }
        get type() {
          return this.isAdd ? "addRoot" : "detachRoot";
        }
        get affectedSelectable() {
          return this._document.getRoot(this.rootName);
        }
        clone() {
          return new N_(
            this.rootName,
            this.elementName,
            this.isAdd,
            this._document,
            this.baseVersion
          );
        }
        getReversed() {
          return new N_(
            this.rootName,
            this.elementName,
            !this.isAdd,
            this._document,
            this.baseVersion + 1
          );
        }
        _execute() {
          this._document.getRoot(this.rootName)._isAttached = this.isAdd;
        }
        toJSON() {
          const t = super.toJSON();
          delete t._document;
          return t;
        }
        static get className() {
          return "RootOperation";
        }
        static fromJSON(t, e) {
          return new N_(t.rootName, t.elementName, t.isAdd, e, t.baseVersion);
        }
      }
      const V_ = {};
      V_[I_.className] = I_;
      V_[S_.className] = S_;
      V_[B_.className] = B_;
      V_[D_.className] = D_;
      V_[z_.className] = z_;
      V_[b_.className] = b_;
      V_[F_.className] = F_;
      V_[M_.className] = M_;
      V_[N_.className] = N_;
      V_[T_.className] = T_;
      V_[P_.className] = P_;
      class L_ {
        static fromJSON(t, e) {
          return V_[t.__className].fromJSON(t, e);
        }
      }
      const H_ = new Map();
      function j_(t, e, n) {
        let o = H_.get(t);
        if (!o) {
          o = new Map();
          H_.set(t, o);
        }
        o.set(e, n);
      }
      function q_(t, e) {
        const n = H_.get(t);
        if (n && n.has(e)) {
          return n.get(e);
        }
        return $_;
      }
      function $_(t) {
        return [t];
      }
      function W_(t, e, n = {}) {
        const o = q_(t.constructor, e.constructor);
        try {
          t = t.clone();
          return o(t, e, n);
        } catch (t) {
          throw t;
        }
      }
      function G_(t, e, n) {
        t = t.slice();
        e = e.slice();
        const o = new K_(n.document, n.useRelations, n.forceWeakRemove);
        o.setOriginalOperations(t);
        o.setOriginalOperations(e);
        const i = o.originalOperations;
        if (t.length == 0 || e.length == 0) {
          return { operationsA: t, operationsB: e, originalOperations: i };
        }
        const r = new WeakMap();
        for (const e of t) {
          r.set(e, 0);
        }
        const s = {
          nextBaseVersionA: t[t.length - 1].baseVersion + 1,
          nextBaseVersionB: e[e.length - 1].baseVersion + 1,
          originalOperationsACount: t.length,
          originalOperationsBCount: e.length,
        };
        let a = 0;
        while (a < t.length) {
          const n = t[a];
          const i = r.get(n);
          if (i == e.length) {
            a++;
            continue;
          }
          const s = e[i];
          const c = W_(n, s, o.getContext(n, s, true));
          const l = W_(s, n, o.getContext(s, n, false));
          o.updateRelation(n, s);
          o.setOriginalOperations(c, n);
          o.setOriginalOperations(l, s);
          for (const t of c) {
            r.set(t, i + l.length);
          }
          t.splice(a, 1, ...c);
          e.splice(i, 1, ...l);
        }
        if (n.padWithNoOps) {
          const n = t.length - s.originalOperationsACount;
          const o = e.length - s.originalOperationsBCount;
          Z_(t, o - n);
          Z_(e, n - o);
        }
        U_(t, s.nextBaseVersionB);
        U_(e, s.nextBaseVersionA);
        return { operationsA: t, operationsB: e, originalOperations: i };
      }
      class K_ {
        constructor(t, e, n = false) {
          this.originalOperations = new Map();
          this._history = t.history;
          this._useRelations = e;
          this._forceWeakRemove = !!n;
          this._relations = new Map();
        }
        setOriginalOperations(t, e = null) {
          const n = e ? this.originalOperations.get(e) : null;
          for (const e of t) {
            this.originalOperations.set(e, n || e);
          }
        }
        updateRelation(t, e) {
          if (t instanceof D_) {
            if (e instanceof P_) {
              if (
                t.targetPosition.isEqual(e.sourcePosition) ||
                e.movedRange.containsPosition(t.targetPosition)
              ) {
                this._setRelation(t, e, "insertAtSource");
              } else if (t.targetPosition.isEqual(e.deletionPosition)) {
                this._setRelation(t, e, "insertBetween");
              } else if (t.targetPosition.isAfter(e.sourcePosition)) {
                this._setRelation(t, e, "moveTargetAfter");
              }
            } else if (e instanceof D_) {
              if (
                t.targetPosition.isEqual(e.sourcePosition) ||
                t.targetPosition.isBefore(e.sourcePosition)
              ) {
                this._setRelation(t, e, "insertBefore");
              } else {
                this._setRelation(t, e, "insertAfter");
              }
            }
          } else if (t instanceof T_) {
            if (e instanceof P_) {
              if (t.splitPosition.isBefore(e.sourcePosition)) {
                this._setRelation(t, e, "splitBefore");
              }
            } else if (e instanceof D_) {
              if (
                t.splitPosition.isEqual(e.sourcePosition) ||
                t.splitPosition.isBefore(e.sourcePosition)
              ) {
                this._setRelation(t, e, "splitBefore");
              } else {
                const n = qk._createFromPositionAndShift(e.sourcePosition, e.howMany);
                if (
                  t.splitPosition.hasSameParentAs(e.sourcePosition) &&
                  n.containsPosition(t.splitPosition)
                ) {
                  const o = n.end.offset - t.splitPosition.offset;
                  const i = t.splitPosition.offset - n.start.offset;
                  this._setRelation(t, e, { howMany: o, offset: i });
                }
              }
            }
          } else if (t instanceof P_) {
            if (e instanceof P_) {
              if (!t.targetPosition.isEqual(e.sourcePosition)) {
                this._setRelation(t, e, "mergeTargetNotMoved");
              }
              if (t.sourcePosition.isEqual(e.targetPosition)) {
                this._setRelation(t, e, "mergeSourceNotMoved");
              }
              if (t.sourcePosition.isEqual(e.sourcePosition)) {
                this._setRelation(t, e, "mergeSameElement");
              }
            } else if (e instanceof T_) {
              if (t.sourcePosition.isEqual(e.splitPosition)) {
                this._setRelation(t, e, "splitAtSource");
              }
            }
          } else if (t instanceof B_) {
            const n = t.newRange;
            if (!n) {
              return;
            }
            if (e instanceof D_) {
              const o = qk._createFromPositionAndShift(e.sourcePosition, e.howMany);
              const i = o.containsPosition(n.start) || o.start.isEqual(n.start);
              const r = o.containsPosition(n.end) || o.end.isEqual(n.end);
              if ((i || r) && !o.containsRange(n)) {
                this._setRelation(t, e, {
                  side: i ? "left" : "right",
                  path: i ? n.start.path.slice() : n.end.path.slice(),
                });
              }
            } else if (e instanceof P_) {
              const o = n.start.isEqual(e.targetPosition);
              const i = n.start.isEqual(e.deletionPosition);
              const r = n.end.isEqual(e.deletionPosition);
              const s = n.end.isEqual(e.sourcePosition);
              if (o || i || r || s) {
                this._setRelation(t, e, {
                  wasInLeftElement: o,
                  wasStartBeforeMergedElement: i,
                  wasEndBeforeMergedElement: r,
                  wasInRightElement: s,
                });
              }
            }
          }
        }
        getContext(t, e, n) {
          return {
            aIsStrong: n,
            aWasUndone: this._wasUndone(t),
            bWasUndone: this._wasUndone(e),
            abRelation: this._useRelations ? this._getRelation(t, e) : null,
            baRelation: this._useRelations ? this._getRelation(e, t) : null,
            forceWeakRemove: this._forceWeakRemove,
          };
        }
        _wasUndone(t) {
          const e = this.originalOperations.get(t);
          return e.wasUndone || this._history.isUndoneOperation(e);
        }
        _getRelation(t, e) {
          const n = this.originalOperations.get(e);
          const o = this._history.getUndoneOperation(n);
          if (!o) {
            return null;
          }
          const i = this.originalOperations.get(t);
          const r = this._relations.get(i);
          if (r) {
            return r.get(o) || null;
          }
          return null;
        }
        _setRelation(t, e, n) {
          const o = this.originalOperations.get(t);
          const i = this.originalOperations.get(e);
          let r = this._relations.get(o);
          if (!r) {
            r = new Map();
            this._relations.set(o, r);
          }
          r.set(i, n);
        }
      }
      function U_(t, e) {
        for (const n of t) {
          n.baseVersion = e++;
        }
      }
      function Z_(t, e) {
        for (let n = 0; n < e; n++) {
          t.push(new z_(0));
        }
      }
      j_(I_, I_, (t, e, n) => {
        if (t.key === e.key && t.range.start.hasSameParentAs(e.range.start)) {
          const o = t.range
            .getDifference(e.range)
            .map((e) => new I_(e, t.key, t.oldValue, t.newValue, 0));
          const i = t.range.getIntersection(e.range);
          if (i) {
            if (n.aIsStrong) {
              o.push(new I_(i, e.key, e.newValue, t.newValue, 0));
            }
          }
          if (o.length == 0) {
            return [new z_(0)];
          }
          return o;
        } else {
          return [t];
        }
      });
      j_(I_, S_, (t, e) => {
        if (t.range.start.hasSameParentAs(e.position) && t.range.containsPosition(e.position)) {
          const n = t.range._getTransformedByInsertion(
            e.position,
            e.howMany,
            !e.shouldReceiveAttributes
          );
          const o = n.map((e) => new I_(e, t.key, t.oldValue, t.newValue, t.baseVersion));
          if (e.shouldReceiveAttributes) {
            const n = J_(e, t.key, t.oldValue);
            if (n) {
              o.unshift(n);
            }
          }
          return o;
        }
        t.range = t.range._getTransformedByInsertion(e.position, e.howMany, false)[0];
        return [t];
      });
      function J_(t, e, n) {
        const o = t.nodes;
        const i = o.getNode(0).getAttribute(e);
        if (i == n) {
          return null;
        }
        const r = new qk(t.position, t.position.getShiftedBy(t.howMany));
        return new I_(r, e, i, n, 0);
      }
      j_(I_, P_, (t, e) => {
        const n = [];
        if (t.range.start.hasSameParentAs(e.deletionPosition)) {
          if (
            t.range.containsPosition(e.deletionPosition) ||
            t.range.start.isEqual(e.deletionPosition)
          ) {
            n.push(qk._createFromPositionAndShift(e.graveyardPosition, 1));
          }
        }
        const o = t.range._getTransformedByMergeOperation(e);
        if (!o.isCollapsed) {
          n.push(o);
        }
        return n.map((e) => new I_(e, t.key, t.oldValue, t.newValue, t.baseVersion));
      });
      j_(I_, D_, (t, e) => {
        const n = Y_(t.range, e);
        return n.map((e) => new I_(e, t.key, t.oldValue, t.newValue, t.baseVersion));
      });
      function Y_(t, e) {
        const n = qk._createFromPositionAndShift(e.sourcePosition, e.howMany);
        let o = null;
        let i = [];
        if (n.containsRange(t, true)) {
          o = t;
        } else if (t.start.hasSameParentAs(n.start)) {
          i = t.getDifference(n);
          o = t.getIntersection(n);
        } else {
          i = [t];
        }
        const r = [];
        for (let t of i) {
          t = t._getTransformedByDeletion(e.sourcePosition, e.howMany);
          const n = e.getMovedRangeStart();
          const o = t.start.hasSameParentAs(n);
          const i = t._getTransformedByInsertion(n, e.howMany, o);
          r.push(...i);
        }
        if (o) {
          r.push(o._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany, false)[0]);
        }
        return r;
      }
      j_(I_, T_, (t, e) => {
        if (t.range.end.isEqual(e.insertionPosition)) {
          if (!e.graveyardPosition) {
            t.range.end.offset++;
          }
          return [t];
        }
        if (
          t.range.start.hasSameParentAs(e.splitPosition) &&
          t.range.containsPosition(e.splitPosition)
        ) {
          const n = t.clone();
          n.range = new qk(
            e.moveTargetPosition.clone(),
            t.range.end._getCombined(e.splitPosition, e.moveTargetPosition)
          );
          t.range.end = e.splitPosition.clone();
          t.range.end.stickiness = "toPrevious";
          return [t, n];
        }
        t.range = t.range._getTransformedBySplitOperation(e);
        return [t];
      });
      j_(S_, I_, (t, e) => {
        const n = [t];
        if (
          t.shouldReceiveAttributes &&
          t.position.hasSameParentAs(e.range.start) &&
          e.range.containsPosition(t.position)
        ) {
          const o = J_(t, e.key, e.newValue);
          if (o) {
            n.push(o);
          }
        }
        return n;
      });
      j_(S_, S_, (t, e, n) => {
        if (t.position.isEqual(e.position) && n.aIsStrong) {
          return [t];
        }
        t.position = t.position._getTransformedByInsertOperation(e);
        return [t];
      });
      j_(S_, D_, (t, e) => {
        t.position = t.position._getTransformedByMoveOperation(e);
        return [t];
      });
      j_(S_, T_, (t, e) => {
        t.position = t.position._getTransformedBySplitOperation(e);
        return [t];
      });
      j_(S_, P_, (t, e) => {
        t.position = t.position._getTransformedByMergeOperation(e);
        return [t];
      });
      j_(B_, S_, (t, e) => {
        if (t.oldRange) {
          t.oldRange = t.oldRange._getTransformedByInsertOperation(e)[0];
        }
        if (t.newRange) {
          t.newRange = t.newRange._getTransformedByInsertOperation(e)[0];
        }
        return [t];
      });
      j_(B_, B_, (t, e, n) => {
        if (t.name == e.name) {
          if (n.aIsStrong) {
            t.oldRange = e.newRange ? e.newRange.clone() : null;
          } else {
            return [new z_(0)];
          }
        }
        return [t];
      });
      j_(B_, P_, (t, e) => {
        if (t.oldRange) {
          t.oldRange = t.oldRange._getTransformedByMergeOperation(e);
        }
        if (t.newRange) {
          t.newRange = t.newRange._getTransformedByMergeOperation(e);
        }
        return [t];
      });
      j_(B_, D_, (t, e, n) => {
        if (t.oldRange) {
          t.oldRange = qk._createFromRanges(t.oldRange._getTransformedByMoveOperation(e));
        }
        if (t.newRange) {
          if (n.abRelation) {
            const o = qk._createFromRanges(t.newRange._getTransformedByMoveOperation(e));
            if (n.abRelation.side == "left" && e.targetPosition.isEqual(t.newRange.start)) {
              t.newRange.end = o.end;
              t.newRange.start.path = n.abRelation.path;
              return [t];
            } else if (n.abRelation.side == "right" && e.targetPosition.isEqual(t.newRange.end)) {
              t.newRange.start = o.start;
              t.newRange.end.path = n.abRelation.path;
              return [t];
            }
          }
          t.newRange = qk._createFromRanges(t.newRange._getTransformedByMoveOperation(e));
        }
        return [t];
      });
      j_(B_, T_, (t, e, n) => {
        if (t.oldRange) {
          t.oldRange = t.oldRange._getTransformedBySplitOperation(e);
        }
        if (t.newRange) {
          if (n.abRelation) {
            const o = t.newRange._getTransformedBySplitOperation(e);
            if (
              t.newRange.start.isEqual(e.splitPosition) &&
              n.abRelation.wasStartBeforeMergedElement
            ) {
              t.newRange.start = Fk._createAt(e.insertionPosition);
            } else if (
              t.newRange.start.isEqual(e.splitPosition) &&
              !n.abRelation.wasInLeftElement
            ) {
              t.newRange.start = Fk._createAt(e.moveTargetPosition);
            }
            if (t.newRange.end.isEqual(e.splitPosition) && n.abRelation.wasInRightElement) {
              t.newRange.end = Fk._createAt(e.moveTargetPosition);
            } else if (
              t.newRange.end.isEqual(e.splitPosition) &&
              n.abRelation.wasEndBeforeMergedElement
            ) {
              t.newRange.end = Fk._createAt(e.insertionPosition);
            } else {
              t.newRange.end = o.end;
            }
            return [t];
          }
          t.newRange = t.newRange._getTransformedBySplitOperation(e);
        }
        return [t];
      });
      j_(P_, S_, (t, e) => {
        if (t.sourcePosition.hasSameParentAs(e.position)) {
          t.howMany += e.howMany;
        }
        t.sourcePosition = t.sourcePosition._getTransformedByInsertOperation(e);
        t.targetPosition = t.targetPosition._getTransformedByInsertOperation(e);
        return [t];
      });
      j_(P_, P_, (t, e, n) => {
        if (
          t.sourcePosition.isEqual(e.sourcePosition) &&
          t.targetPosition.isEqual(e.targetPosition)
        ) {
          if (!n.bWasUndone) {
            return [new z_(0)];
          } else {
            const n = e.graveyardPosition.path.slice();
            n.push(0);
            t.sourcePosition = new Fk(e.graveyardPosition.root, n);
            t.howMany = 0;
            return [t];
          }
        }
        if (
          t.sourcePosition.isEqual(e.sourcePosition) &&
          !t.targetPosition.isEqual(e.targetPosition) &&
          !n.bWasUndone &&
          n.abRelation != "splitAtSource"
        ) {
          const o = t.targetPosition.root.rootName == "$graveyard";
          const i = e.targetPosition.root.rootName == "$graveyard";
          const r = o && !i;
          const s = i && !o;
          const a = s || (!r && n.aIsStrong);
          if (a) {
            const n = e.targetPosition._getTransformedByMergeOperation(e);
            const o = t.targetPosition._getTransformedByMergeOperation(e);
            return [new D_(n, t.howMany, o, 0)];
          } else {
            return [new z_(0)];
          }
        }
        if (t.sourcePosition.hasSameParentAs(e.targetPosition)) {
          t.howMany += e.howMany;
        }
        t.sourcePosition = t.sourcePosition._getTransformedByMergeOperation(e);
        t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e);
        if (!t.graveyardPosition.isEqual(e.graveyardPosition) || !n.aIsStrong) {
          t.graveyardPosition = t.graveyardPosition._getTransformedByMergeOperation(e);
        }
        return [t];
      });
      j_(P_, D_, (t, e, n) => {
        const o = qk._createFromPositionAndShift(e.sourcePosition, e.howMany);
        if (e.type == "remove" && !n.bWasUndone && !n.forceWeakRemove) {
          if (
            t.deletionPosition.hasSameParentAs(e.sourcePosition) &&
            o.containsPosition(t.sourcePosition)
          ) {
            return [new z_(0)];
          }
        }
        if (t.sourcePosition.hasSameParentAs(e.targetPosition)) {
          t.howMany += e.howMany;
        }
        if (t.sourcePosition.hasSameParentAs(e.sourcePosition)) {
          t.howMany -= e.howMany;
        }
        t.sourcePosition = t.sourcePosition._getTransformedByMoveOperation(e);
        t.targetPosition = t.targetPosition._getTransformedByMoveOperation(e);
        if (!t.graveyardPosition.isEqual(e.targetPosition)) {
          t.graveyardPosition = t.graveyardPosition._getTransformedByMoveOperation(e);
        }
        return [t];
      });
      j_(P_, T_, (t, e, n) => {
        if (e.graveyardPosition) {
          t.graveyardPosition = t.graveyardPosition._getTransformedByDeletion(
            e.graveyardPosition,
            1
          );
          if (t.deletionPosition.isEqual(e.graveyardPosition)) {
            t.howMany = e.howMany;
          }
        }
        if (t.targetPosition.isEqual(e.splitPosition)) {
          const o = e.howMany != 0;
          const i = e.graveyardPosition && t.deletionPosition.isEqual(e.graveyardPosition);
          if (o || i || n.abRelation == "mergeTargetNotMoved") {
            t.sourcePosition = t.sourcePosition._getTransformedBySplitOperation(e);
            return [t];
          }
        }
        if (t.sourcePosition.isEqual(e.splitPosition)) {
          if (n.abRelation == "mergeSourceNotMoved") {
            t.howMany = 0;
            t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e);
            return [t];
          }
          if (n.abRelation == "mergeSameElement" || t.sourcePosition.offset > 0) {
            t.sourcePosition = e.moveTargetPosition.clone();
            t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e);
            return [t];
          }
        }
        if (t.sourcePosition.hasSameParentAs(e.splitPosition)) {
          t.howMany = e.splitPosition.offset;
        }
        t.sourcePosition = t.sourcePosition._getTransformedBySplitOperation(e);
        t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e);
        return [t];
      });
      j_(D_, S_, (t, e) => {
        const n = qk._createFromPositionAndShift(t.sourcePosition, t.howMany);
        const o = n._getTransformedByInsertOperation(e, false)[0];
        t.sourcePosition = o.start;
        t.howMany = o.end.offset - o.start.offset;
        if (!t.targetPosition.isEqual(e.position)) {
          t.targetPosition = t.targetPosition._getTransformedByInsertOperation(e);
        }
        return [t];
      });
      j_(D_, D_, (t, e, n) => {
        const o = qk._createFromPositionAndShift(t.sourcePosition, t.howMany);
        const i = qk._createFromPositionAndShift(e.sourcePosition, e.howMany);
        let r = n.aIsStrong;
        let s = !n.aIsStrong;
        if (n.abRelation == "insertBefore" || n.baRelation == "insertAfter") {
          s = true;
        } else if (n.abRelation == "insertAfter" || n.baRelation == "insertBefore") {
          s = false;
        }
        let a;
        if (t.targetPosition.isEqual(e.targetPosition) && s) {
          a = t.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany);
        } else {
          a = t.targetPosition._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany);
        }
        if (Q_(t, e) && Q_(e, t)) {
          return [e.getReversed()];
        }
        const c = o.containsPosition(e.targetPosition);
        if (c && o.containsRange(i, true)) {
          o.start = o.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany);
          o.end = o.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany);
          return X_([o], a);
        }
        const l = i.containsPosition(t.targetPosition);
        if (l && i.containsRange(o, true)) {
          o.start = o.start._getCombined(e.sourcePosition, e.getMovedRangeStart());
          o.end = o.end._getCombined(e.sourcePosition, e.getMovedRangeStart());
          return X_([o], a);
        }
        const d = At(t.sourcePosition.getParentPath(), e.sourcePosition.getParentPath());
        if (d == "prefix" || d == "extension") {
          o.start = o.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany);
          o.end = o.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany);
          return X_([o], a);
        }
        if (t.type == "remove" && e.type != "remove" && !n.aWasUndone && !n.forceWeakRemove) {
          r = true;
        } else if (
          t.type != "remove" &&
          e.type == "remove" &&
          !n.bWasUndone &&
          !n.forceWeakRemove
        ) {
          r = false;
        }
        const h = [];
        const u = o.getDifference(i);
        for (const t of u) {
          t.start = t.start._getTransformedByDeletion(e.sourcePosition, e.howMany);
          t.end = t.end._getTransformedByDeletion(e.sourcePosition, e.howMany);
          const n = At(t.start.getParentPath(), e.getMovedRangeStart().getParentPath()) == "same";
          const o = t._getTransformedByInsertion(e.getMovedRangeStart(), e.howMany, n);
          h.push(...o);
        }
        const f = o.getIntersection(i);
        if (f !== null && r) {
          f.start = f.start._getCombined(e.sourcePosition, e.getMovedRangeStart());
          f.end = f.end._getCombined(e.sourcePosition, e.getMovedRangeStart());
          if (h.length === 0) {
            h.push(f);
          } else if (h.length == 1) {
            if (i.start.isBefore(o.start) || i.start.isEqual(o.start)) {
              h.unshift(f);
            } else {
              h.push(f);
            }
          } else {
            h.splice(1, 0, f);
          }
        }
        if (h.length === 0) {
          return [new z_(t.baseVersion)];
        }
        return X_(h, a);
      });
      j_(D_, T_, (t, e, n) => {
        let o = t.targetPosition.clone();
        if (
          !t.targetPosition.isEqual(e.insertionPosition) ||
          !e.graveyardPosition ||
          n.abRelation == "moveTargetAfter"
        ) {
          o = t.targetPosition._getTransformedBySplitOperation(e);
        }
        const i = qk._createFromPositionAndShift(t.sourcePosition, t.howMany);
        if (i.end.isEqual(e.insertionPosition)) {
          if (!e.graveyardPosition) {
            t.howMany++;
          }
          t.targetPosition = o;
          return [t];
        }
        if (i.start.hasSameParentAs(e.splitPosition) && i.containsPosition(e.splitPosition)) {
          let t = new qk(e.splitPosition, i.end);
          t = t._getTransformedBySplitOperation(e);
          const n = [new qk(i.start, e.splitPosition), t];
          return X_(n, o);
        }
        if (t.targetPosition.isEqual(e.splitPosition) && n.abRelation == "insertAtSource") {
          o = e.moveTargetPosition;
        }
        if (t.targetPosition.isEqual(e.insertionPosition) && n.abRelation == "insertBetween") {
          o = t.targetPosition;
        }
        const r = i._getTransformedBySplitOperation(e);
        const s = [r];
        if (e.graveyardPosition) {
          const o = i.start.isEqual(e.graveyardPosition) || i.containsPosition(e.graveyardPosition);
          if (t.howMany > 1 && o && !n.aWasUndone) {
            s.push(qk._createFromPositionAndShift(e.insertionPosition, 1));
          }
        }
        return X_(s, o);
      });
      j_(D_, P_, (t, e, n) => {
        const o = qk._createFromPositionAndShift(t.sourcePosition, t.howMany);
        if (
          e.deletionPosition.hasSameParentAs(t.sourcePosition) &&
          o.containsPosition(e.sourcePosition)
        ) {
          if (t.type == "remove" && !n.forceWeakRemove) {
            if (!n.aWasUndone) {
              const n = [];
              let o = e.graveyardPosition.clone();
              let i = e.targetPosition._getTransformedByMergeOperation(e);
              if (t.howMany > 1) {
                n.push(new D_(t.sourcePosition, t.howMany - 1, t.targetPosition, 0));
                o = o._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany - 1);
                i = i._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany - 1);
              }
              const r = e.deletionPosition._getCombined(t.sourcePosition, t.targetPosition);
              const s = new D_(o, 1, r, 0);
              const a = s.getMovedRangeStart().path.slice();
              a.push(0);
              const c = new Fk(s.targetPosition.root, a);
              i = i._getTransformedByMove(o, r, 1);
              const l = new D_(i, e.howMany, c, 0);
              n.push(s);
              n.push(l);
              return n;
            }
          } else {
            if (t.howMany == 1) {
              if (!n.bWasUndone) {
                return [new z_(0)];
              } else {
                t.sourcePosition = e.graveyardPosition.clone();
                t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e);
                return [t];
              }
            }
          }
        }
        const i = qk._createFromPositionAndShift(t.sourcePosition, t.howMany);
        const r = i._getTransformedByMergeOperation(e);
        t.sourcePosition = r.start;
        t.howMany = r.end.offset - r.start.offset;
        t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e);
        return [t];
      });
      j_(F_, S_, (t, e) => {
        t.position = t.position._getTransformedByInsertOperation(e);
        return [t];
      });
      j_(F_, P_, (t, e) => {
        if (t.position.isEqual(e.deletionPosition)) {
          t.position = e.graveyardPosition.clone();
          t.position.stickiness = "toNext";
          return [t];
        }
        t.position = t.position._getTransformedByMergeOperation(e);
        return [t];
      });
      j_(F_, D_, (t, e) => {
        t.position = t.position._getTransformedByMoveOperation(e);
        return [t];
      });
      j_(F_, F_, (t, e, n) => {
        if (t.position.isEqual(e.position)) {
          if (n.aIsStrong) {
            t.oldName = e.newName;
          } else {
            return [new z_(0)];
          }
        }
        return [t];
      });
      j_(F_, T_, (t, e) => {
        const n = t.position.path;
        const o = e.splitPosition.getParentPath();
        if (At(n, o) == "same" && !e.graveyardPosition) {
          const e = new F_(t.position.getShiftedBy(1), t.oldName, t.newName, 0);
          return [t, e];
        }
        t.position = t.position._getTransformedBySplitOperation(e);
        return [t];
      });
      j_(M_, M_, (t, e, n) => {
        if (t.root === e.root && t.key === e.key) {
          if (!n.aIsStrong || t.newValue === e.newValue) {
            return [new z_(0)];
          } else {
            t.oldValue = e.newValue;
          }
        }
        return [t];
      });
      j_(N_, N_, (t, e) => {
        if (t.rootName === e.rootName && t.isAdd === e.isAdd) {
          return [new z_(0)];
        }
        return [t];
      });
      j_(T_, S_, (t, e) => {
        if (
          t.splitPosition.hasSameParentAs(e.position) &&
          t.splitPosition.offset < e.position.offset
        ) {
          t.howMany += e.howMany;
        }
        t.splitPosition = t.splitPosition._getTransformedByInsertOperation(e);
        t.insertionPosition = t.insertionPosition._getTransformedByInsertOperation(e);
        return [t];
      });
      j_(T_, P_, (t, e, n) => {
        if (
          !t.graveyardPosition &&
          !n.bWasUndone &&
          t.splitPosition.hasSameParentAs(e.sourcePosition)
        ) {
          const n = e.graveyardPosition.path.slice();
          n.push(0);
          const o = new Fk(e.graveyardPosition.root, n);
          const i = T_.getInsertionPosition(new Fk(e.graveyardPosition.root, n));
          const r = new T_(o, 0, i, null, 0);
          t.splitPosition = t.splitPosition._getTransformedByMergeOperation(e);
          t.insertionPosition = T_.getInsertionPosition(t.splitPosition);
          t.graveyardPosition = r.insertionPosition.clone();
          t.graveyardPosition.stickiness = "toNext";
          return [r, t];
        }
        if (
          t.splitPosition.hasSameParentAs(e.deletionPosition) &&
          !t.splitPosition.isAfter(e.deletionPosition)
        ) {
          t.howMany--;
        }
        if (t.splitPosition.hasSameParentAs(e.targetPosition)) {
          t.howMany += e.howMany;
        }
        t.splitPosition = t.splitPosition._getTransformedByMergeOperation(e);
        t.insertionPosition = T_.getInsertionPosition(t.splitPosition);
        if (t.graveyardPosition) {
          t.graveyardPosition = t.graveyardPosition._getTransformedByMergeOperation(e);
        }
        return [t];
      });
      j_(T_, D_, (t, e, n) => {
        const o = qk._createFromPositionAndShift(e.sourcePosition, e.howMany);
        if (t.graveyardPosition) {
          const i = o.start.isEqual(t.graveyardPosition) || o.containsPosition(t.graveyardPosition);
          if (!n.bWasUndone && i) {
            const n = t.splitPosition._getTransformedByMoveOperation(e);
            const o = t.graveyardPosition._getTransformedByMoveOperation(e);
            const i = o.path.slice();
            i.push(0);
            const r = new Fk(o.root, i);
            const s = new D_(n, t.howMany, r, 0);
            return [s];
          }
          t.graveyardPosition = t.graveyardPosition._getTransformedByMoveOperation(e);
        }
        const i = t.splitPosition.isEqual(e.targetPosition);
        if (i && (n.baRelation == "insertAtSource" || n.abRelation == "splitBefore")) {
          t.howMany += e.howMany;
          t.splitPosition = t.splitPosition._getTransformedByDeletion(e.sourcePosition, e.howMany);
          t.insertionPosition = T_.getInsertionPosition(t.splitPosition);
          return [t];
        }
        if (i && n.abRelation && n.abRelation.howMany) {
          const { howMany: e, offset: o } = n.abRelation;
          t.howMany += e;
          t.splitPosition = t.splitPosition.getShiftedBy(o);
          return [t];
        }
        if (
          t.splitPosition.hasSameParentAs(e.sourcePosition) &&
          o.containsPosition(t.splitPosition)
        ) {
          const n = e.howMany - (t.splitPosition.offset - e.sourcePosition.offset);
          t.howMany -= n;
          if (
            t.splitPosition.hasSameParentAs(e.targetPosition) &&
            t.splitPosition.offset < e.targetPosition.offset
          ) {
            t.howMany += e.howMany;
          }
          t.splitPosition = e.sourcePosition.clone();
          t.insertionPosition = T_.getInsertionPosition(t.splitPosition);
          return [t];
        }
        if (!e.sourcePosition.isEqual(e.targetPosition)) {
          if (
            t.splitPosition.hasSameParentAs(e.sourcePosition) &&
            t.splitPosition.offset <= e.sourcePosition.offset
          ) {
            t.howMany -= e.howMany;
          }
          if (
            t.splitPosition.hasSameParentAs(e.targetPosition) &&
            t.splitPosition.offset < e.targetPosition.offset
          ) {
            t.howMany += e.howMany;
          }
        }
        t.splitPosition.stickiness = "toNone";
        t.splitPosition = t.splitPosition._getTransformedByMoveOperation(e);
        t.splitPosition.stickiness = "toNext";
        if (t.graveyardPosition) {
          t.insertionPosition = t.insertionPosition._getTransformedByMoveOperation(e);
        } else {
          t.insertionPosition = T_.getInsertionPosition(t.splitPosition);
        }
        return [t];
      });
      j_(T_, T_, (t, e, n) => {
        if (t.splitPosition.isEqual(e.splitPosition)) {
          if (!t.graveyardPosition && !e.graveyardPosition) {
            return [new z_(0)];
          }
          if (
            t.graveyardPosition &&
            e.graveyardPosition &&
            t.graveyardPosition.isEqual(e.graveyardPosition)
          ) {
            return [new z_(0)];
          }
          if (n.abRelation == "splitBefore") {
            t.howMany = 0;
            t.graveyardPosition = t.graveyardPosition._getTransformedBySplitOperation(e);
            return [t];
          }
        }
        if (
          t.graveyardPosition &&
          e.graveyardPosition &&
          t.graveyardPosition.isEqual(e.graveyardPosition)
        ) {
          const o = t.splitPosition.root.rootName == "$graveyard";
          const i = e.splitPosition.root.rootName == "$graveyard";
          const r = o && !i;
          const s = i && !o;
          const a = s || (!r && n.aIsStrong);
          if (a) {
            const n = [];
            if (e.howMany) {
              n.push(new D_(e.moveTargetPosition, e.howMany, e.splitPosition, 0));
            }
            if (t.howMany) {
              n.push(new D_(t.splitPosition, t.howMany, t.moveTargetPosition, 0));
            }
            return n;
          } else {
            return [new z_(0)];
          }
        }
        if (t.graveyardPosition) {
          t.graveyardPosition = t.graveyardPosition._getTransformedBySplitOperation(e);
        }
        if (t.splitPosition.isEqual(e.insertionPosition) && n.abRelation == "splitBefore") {
          t.howMany++;
          return [t];
        }
        if (e.splitPosition.isEqual(t.insertionPosition) && n.baRelation == "splitBefore") {
          const n = e.insertionPosition.path.slice();
          n.push(0);
          const o = new Fk(e.insertionPosition.root, n);
          const i = new D_(t.insertionPosition, 1, o, 0);
          return [t, i];
        }
        if (
          t.splitPosition.hasSameParentAs(e.splitPosition) &&
          t.splitPosition.offset < e.splitPosition.offset
        ) {
          t.howMany -= e.howMany;
        }
        t.splitPosition = t.splitPosition._getTransformedBySplitOperation(e);
        t.insertionPosition = T_.getInsertionPosition(t.splitPosition);
        return [t];
      });
      function Q_(t, e) {
        return t.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany) === null;
      }
      function X_(t, e) {
        const n = [];
        for (let o = 0; o < t.length; o++) {
          const i = t[o];
          const r = new D_(i.start, i.end.offset - i.start.offset, e, 0);
          n.push(r);
          for (let e = o + 1; e < t.length; e++) {
            t[e] = t[e]._getTransformedByMove(r.sourcePosition, r.targetPosition, r.howMany)[0];
          }
          e = e._getTransformedByMove(r.sourcePosition, r.targetPosition, r.howMany);
        }
        return n;
      }
      class tv extends q(Fk) {
        constructor(t, e, n = "toNone") {
          super(t, e, n);
          if (!this.root.is("rootElement")) {
            throw new P("model-liveposition-root-not-rootelement", t);
          }
          ev.call(this);
        }
        detach() {
          this.stopListening();
        }
        toPosition() {
          return new Fk(this.root, this.path.slice(), this.stickiness);
        }
        static fromPosition(t, e) {
          return new this(t.root, t.path.slice(), e ? e : t.stickiness);
        }
      }
      tv.prototype.is = function (t) {
        return (
          t === "livePosition" ||
          t === "model:livePosition" ||
          t == "position" ||
          t === "model:position"
        );
      };
      function ev() {
        this.listenTo(
          this.root.document.model,
          "applyOperation",
          (t, e) => {
            const n = e[0];
            if (!n.isDocumentOperation) {
              return;
            }
            nv.call(this, n);
          },
          { priority: "low" }
        );
      }
      function nv(t) {
        const e = this.getTransformedByOperation(t);
        if (!this.isEqual(e)) {
          const t = this.toPosition();
          this.path = e.path;
          this.root = e.root;
          this.fire("change", t);
        }
      }
      class ov {
        constructor(t = {}) {
          if (typeof t === "string") {
            t = t === "transparent" ? { isUndoable: false } : {};
            B("batch-constructor-deprecated-string-type");
          }
          const {
            isUndoable: e = true,
            isLocal: n = true,
            isUndo: o = false,
            isTyping: i = false,
          } = t;
          this.operations = [];
          this.isUndoable = e;
          this.isLocal = n;
          this.isUndo = o;
          this.isTyping = i;
        }
        get type() {
          B("batch-type-deprecated");
          return "default";
        }
        get baseVersion() {
          for (const t of this.operations) {
            if (t.baseVersion !== null) {
              return t.baseVersion;
            }
          }
          return null;
        }
        addOperation(t) {
          t.batch = this;
          this.operations.push(t);
          return t;
        }
      }
      class iv {
        constructor(t) {
          this._changesInElement = new Map();
          this._elementSnapshots = new Map();
          this._changedMarkers = new Map();
          this._changedRoots = new Map();
          this._changeCount = 0;
          this._cachedChanges = null;
          this._cachedChangesWithGraveyard = null;
          this._refreshedItems = new Set();
          this._markerCollection = t;
        }
        get isEmpty() {
          return (
            this._changesInElement.size == 0 &&
            this._changedMarkers.size == 0 &&
            this._changedRoots.size == 0
          );
        }
        bufferOperation(t) {
          const e = t;
          switch (e.type) {
            case "insert": {
              if (this._isInInsertedElement(e.position.parent)) {
                return;
              }
              this._markInsert(e.position.parent, e.position.offset, e.nodes.maxOffset);
              break;
            }
            case "addAttribute":
            case "removeAttribute":
            case "changeAttribute": {
              for (const t of e.range.getItems({ shallow: true })) {
                if (this._isInInsertedElement(t.parent)) {
                  continue;
                }
                this._markAttribute(t);
              }
              break;
            }
            case "remove":
            case "move":
            case "reinsert": {
              if (
                e.sourcePosition.isEqual(e.targetPosition) ||
                e.sourcePosition.getShiftedBy(e.howMany).isEqual(e.targetPosition)
              ) {
                return;
              }
              const t = this._isInInsertedElement(e.sourcePosition.parent);
              const n = this._isInInsertedElement(e.targetPosition.parent);
              if (!t) {
                this._markRemove(e.sourcePosition.parent, e.sourcePosition.offset, e.howMany);
              }
              if (!n) {
                this._markInsert(e.targetPosition.parent, e.getMovedRangeStart().offset, e.howMany);
              }
              break;
            }
            case "rename": {
              if (this._isInInsertedElement(e.position.parent)) {
                return;
              }
              this._markRemove(e.position.parent, e.position.offset, 1);
              this._markInsert(e.position.parent, e.position.offset, 1);
              const t = qk._createFromPositionAndShift(e.position, 1);
              for (const e of this._markerCollection.getMarkersIntersectingRange(t)) {
                const t = e.getData();
                this.bufferMarkerChange(e.name, t, t);
              }
              break;
            }
            case "split": {
              const t = e.splitPosition.parent;
              if (!this._isInInsertedElement(t)) {
                this._markRemove(t, e.splitPosition.offset, e.howMany);
              }
              if (!this._isInInsertedElement(e.insertionPosition.parent)) {
                this._markInsert(e.insertionPosition.parent, e.insertionPosition.offset, 1);
              }
              if (e.graveyardPosition) {
                this._markRemove(e.graveyardPosition.parent, e.graveyardPosition.offset, 1);
              }
              break;
            }
            case "merge": {
              const t = e.sourcePosition.parent;
              if (!this._isInInsertedElement(t.parent)) {
                this._markRemove(t.parent, t.startOffset, 1);
              }
              const n = e.graveyardPosition.parent;
              this._markInsert(n, e.graveyardPosition.offset, 1);
              const o = e.targetPosition.parent;
              if (!this._isInInsertedElement(o)) {
                this._markInsert(o, e.targetPosition.offset, t.maxOffset);
              }
              break;
            }
            case "detachRoot":
            case "addRoot": {
              const t = e.affectedSelectable;
              if (!t._isLoaded) {
                return;
              }
              if (t.isAttached() == e.isAdd) {
                return;
              }
              this._bufferRootStateChange(e.rootName, e.isAdd);
              break;
            }
            case "addRootAttribute":
            case "removeRootAttribute":
            case "changeRootAttribute": {
              if (!e.root._isLoaded) {
                return;
              }
              const t = e.root.rootName;
              this._bufferRootAttributeChange(t, e.key, e.oldValue, e.newValue);
              break;
            }
          }
          this._cachedChanges = null;
        }
        bufferMarkerChange(t, e, n) {
          if (e.range && e.range.root.is("rootElement") && !e.range.root._isLoaded) {
            e.range = null;
          }
          if (n.range && n.range.root.is("rootElement") && !n.range.root._isLoaded) {
            n.range = null;
          }
          let o = this._changedMarkers.get(t);
          if (!o) {
            o = { newMarkerData: n, oldMarkerData: e };
            this._changedMarkers.set(t, o);
          } else {
            o.newMarkerData = n;
          }
          if (o.oldMarkerData.range == null && n.range == null) {
            this._changedMarkers.delete(t);
          }
        }
        getMarkersToRemove() {
          const t = [];
          for (const [e, n] of this._changedMarkers) {
            if (n.oldMarkerData.range != null) {
              t.push({ name: e, range: n.oldMarkerData.range });
            }
          }
          return t;
        }
        getMarkersToAdd() {
          const t = [];
          for (const [e, n] of this._changedMarkers) {
            if (n.newMarkerData.range != null) {
              t.push({ name: e, range: n.newMarkerData.range });
            }
          }
          return t;
        }
        getChangedMarkers() {
          return Array.from(this._changedMarkers).map(([t, e]) => ({
            name: t,
            data: { oldRange: e.oldMarkerData.range, newRange: e.newMarkerData.range },
          }));
        }
        hasDataChanges() {
          if (this._changesInElement.size > 0) {
            return true;
          }
          if (this._changedRoots.size > 0) {
            return true;
          }
          for (const { newMarkerData: t, oldMarkerData: e } of this._changedMarkers.values()) {
            if (t.affectsData !== e.affectsData) {
              return true;
            }
            if (t.affectsData) {
              const n = t.range && !e.range;
              const o = !t.range && e.range;
              const i = t.range && e.range && !t.range.isEqual(e.range);
              if (n || o || i) {
                return true;
              }
            }
          }
          return false;
        }
        getChanges(t = {}) {
          if (this._cachedChanges) {
            if (t.includeChangesInGraveyard) {
              return this._cachedChangesWithGraveyard.slice();
            } else {
              return this._cachedChanges.slice();
            }
          }
          let e = [];
          for (const t of this._changesInElement.keys()) {
            const n = this._changesInElement.get(t).sort((t, e) => {
              if (t.offset === e.offset) {
                if (t.type != e.type) {
                  return t.type == "remove" ? -1 : 1;
                }
                return 0;
              }
              return t.offset < e.offset ? -1 : 1;
            });
            const o = this._elementSnapshots.get(t);
            const i = rv(t.getChildren());
            const r = sv(o.length, n);
            let s = 0;
            let a = 0;
            for (const n of r) {
              if (n === "i") {
                e.push(this._getInsertDiff(t, s, i[s]));
                s++;
              } else if (n === "r") {
                e.push(this._getRemoveDiff(t, s, o[a]));
                a++;
              } else if (n === "a") {
                const n = i[s].attributes;
                const r = o[a].attributes;
                let c;
                if (i[s].name == "$text") {
                  c = new qk(Fk._createAt(t, s), Fk._createAt(t, s + 1));
                } else {
                  const e = t.offsetToIndex(s);
                  c = new qk(Fk._createAt(t, s), Fk._createAt(t.getChild(e), 0));
                }
                e.push(...this._getAttributesDiff(c, r, n));
                s++;
                a++;
              } else {
                s++;
                a++;
              }
            }
          }
          e.sort((t, e) => {
            if (t.position.root != e.position.root) {
              return t.position.root.rootName < e.position.root.rootName ? -1 : 1;
            }
            if (t.position.isEqual(e.position)) {
              return t.changeCount - e.changeCount;
            }
            return t.position.isBefore(e.position) ? -1 : 1;
          });
          for (let t = 1, n = 0; t < e.length; t++) {
            const o = e[n];
            const i = e[t];
            const r =
              o.type == "remove" &&
              i.type == "remove" &&
              o.name == "$text" &&
              i.name == "$text" &&
              o.position.isEqual(i.position);
            const s =
              o.type == "insert" &&
              i.type == "insert" &&
              o.name == "$text" &&
              i.name == "$text" &&
              o.position.parent == i.position.parent &&
              o.position.offset + o.length == i.position.offset;
            const a =
              o.type == "attribute" &&
              i.type == "attribute" &&
              o.position.parent == i.position.parent &&
              o.range.isFlat &&
              i.range.isFlat &&
              o.position.offset + o.length == i.position.offset &&
              o.attributeKey == i.attributeKey &&
              o.attributeOldValue == i.attributeOldValue &&
              o.attributeNewValue == i.attributeNewValue;
            if (r || s || a) {
              o.length++;
              if (a) {
                o.range.end = o.range.end.getShiftedBy(1);
              }
              e[t] = null;
            } else {
              n = t;
            }
          }
          e = e.filter((t) => t);
          for (const t of e) {
            delete t.changeCount;
            if (t.type == "attribute") {
              delete t.position;
              delete t.length;
            }
          }
          this._changeCount = 0;
          this._cachedChangesWithGraveyard = e;
          this._cachedChanges = e.filter(av);
          if (t.includeChangesInGraveyard) {
            return this._cachedChangesWithGraveyard.slice();
          } else {
            return this._cachedChanges.slice();
          }
        }
        getChangedRoots() {
          return Array.from(this._changedRoots.values()).map((t) => {
            const e = { ...t };
            if (e.state !== undefined) {
              delete e.attributes;
            }
            return e;
          });
        }
        getRefreshedItems() {
          return new Set(this._refreshedItems);
        }
        reset() {
          this._changesInElement.clear();
          this._elementSnapshots.clear();
          this._changedMarkers.clear();
          this._changedRoots.clear();
          this._refreshedItems = new Set();
          this._cachedChanges = null;
        }
        _bufferRootStateChange(t, e) {
          if (!this._changedRoots.has(t)) {
            this._changedRoots.set(t, { name: t, state: e ? "attached" : "detached" });
            return;
          }
          const n = this._changedRoots.get(t);
          if (n.state !== undefined) {
            delete n.state;
            if (n.attributes === undefined) {
              this._changedRoots.delete(t);
            }
          } else {
            n.state = e ? "attached" : "detached";
          }
        }
        _bufferRootAttributeChange(t, e, n, o) {
          const i = this._changedRoots.get(t) || { name: t };
          const r = i.attributes || {};
          if (r[e]) {
            const t = r[e];
            if (o === t.oldValue) {
              delete r[e];
            } else {
              t.newValue = o;
            }
          } else {
            r[e] = { oldValue: n, newValue: o };
          }
          if (Object.entries(r).length === 0) {
            delete i.attributes;
            if (i.state === undefined) {
              this._changedRoots.delete(t);
            }
          } else {
            i.attributes = r;
            this._changedRoots.set(t, i);
          }
        }
        _refreshItem(t) {
          if (this._isInInsertedElement(t.parent)) {
            return;
          }
          this._markRemove(t.parent, t.startOffset, t.offsetSize);
          this._markInsert(t.parent, t.startOffset, t.offsetSize);
          this._refreshedItems.add(t);
          const e = qk._createOn(t);
          for (const t of this._markerCollection.getMarkersIntersectingRange(e)) {
            const e = t.getData();
            this.bufferMarkerChange(t.name, e, e);
          }
          this._cachedChanges = null;
        }
        _bufferRootLoad(t) {
          if (!t.isAttached()) {
            return;
          }
          this._bufferRootStateChange(t.rootName, true);
          this._markInsert(t, 0, t.maxOffset);
          for (const e of t.getAttributeKeys()) {
            this._bufferRootAttributeChange(t.rootName, e, null, t.getAttribute(e));
          }
          for (const e of this._markerCollection) {
            if (e.getRange().root == t) {
              const t = e.getData();
              this.bufferMarkerChange(e.name, { ...t, range: null }, t);
            }
          }
        }
        _markInsert(t, e, n) {
          if (t.root.is("rootElement") && !t.root._isLoaded) {
            return;
          }
          const o = { type: "insert", offset: e, howMany: n, count: this._changeCount++ };
          this._markChange(t, o);
        }
        _markRemove(t, e, n) {
          if (t.root.is("rootElement") && !t.root._isLoaded) {
            return;
          }
          const o = { type: "remove", offset: e, howMany: n, count: this._changeCount++ };
          this._markChange(t, o);
          this._removeAllNestedChanges(t, e, n);
        }
        _markAttribute(t) {
          if (t.root.is("rootElement") && !t.root._isLoaded) {
            return;
          }
          const e = {
            type: "attribute",
            offset: t.startOffset,
            howMany: t.offsetSize,
            count: this._changeCount++,
          };
          this._markChange(t.parent, e);
        }
        _markChange(t, e) {
          this._makeSnapshot(t);
          const n = this._getChangesForElement(t);
          this._handleChange(e, n);
          n.push(e);
          for (let t = 0; t < n.length; t++) {
            if (n[t].howMany < 1) {
              n.splice(t, 1);
              t--;
            }
          }
        }
        _getChangesForElement(t) {
          let e;
          if (this._changesInElement.has(t)) {
            e = this._changesInElement.get(t);
          } else {
            e = [];
            this._changesInElement.set(t, e);
          }
          return e;
        }
        _makeSnapshot(t) {
          if (!this._elementSnapshots.has(t)) {
            this._elementSnapshots.set(t, rv(t.getChildren()));
          }
        }
        _handleChange(t, e) {
          t.nodesToHandle = t.howMany;
          for (const n of e) {
            const o = t.offset + t.howMany;
            const i = n.offset + n.howMany;
            if (t.type == "insert") {
              if (n.type == "insert") {
                if (t.offset <= n.offset) {
                  n.offset += t.howMany;
                } else if (t.offset < i) {
                  n.howMany += t.nodesToHandle;
                  t.nodesToHandle = 0;
                }
              }
              if (n.type == "remove") {
                if (t.offset < n.offset) {
                  n.offset += t.howMany;
                }
              }
              if (n.type == "attribute") {
                if (t.offset <= n.offset) {
                  n.offset += t.howMany;
                } else if (t.offset < i) {
                  const i = n.howMany;
                  n.howMany = t.offset - n.offset;
                  e.unshift({
                    type: "attribute",
                    offset: o,
                    howMany: i - n.howMany,
                    count: this._changeCount++,
                  });
                }
              }
            }
            if (t.type == "remove") {
              if (n.type == "insert") {
                if (o <= n.offset) {
                  n.offset -= t.howMany;
                } else if (o <= i) {
                  if (t.offset < n.offset) {
                    const e = o - n.offset;
                    n.offset = t.offset;
                    n.howMany -= e;
                    t.nodesToHandle -= e;
                  } else {
                    n.howMany -= t.nodesToHandle;
                    t.nodesToHandle = 0;
                  }
                } else {
                  if (t.offset <= n.offset) {
                    t.nodesToHandle -= n.howMany;
                    n.howMany = 0;
                  } else if (t.offset < i) {
                    const e = i - t.offset;
                    n.howMany -= e;
                    t.nodesToHandle -= e;
                  }
                }
              }
              if (n.type == "remove") {
                if (o <= n.offset) {
                  n.offset -= t.howMany;
                } else if (t.offset < n.offset) {
                  t.nodesToHandle += n.howMany;
                  n.howMany = 0;
                }
              }
              if (n.type == "attribute") {
                if (o <= n.offset) {
                  n.offset -= t.howMany;
                } else if (t.offset < n.offset) {
                  const e = o - n.offset;
                  n.offset = t.offset;
                  n.howMany -= e;
                } else if (t.offset < i) {
                  if (o <= i) {
                    const o = n.howMany;
                    n.howMany = t.offset - n.offset;
                    const i = o - n.howMany - t.nodesToHandle;
                    e.unshift({
                      type: "attribute",
                      offset: t.offset,
                      howMany: i,
                      count: this._changeCount++,
                    });
                  } else {
                    n.howMany -= i - t.offset;
                  }
                }
              }
            }
            if (t.type == "attribute") {
              if (n.type == "insert") {
                if (t.offset < n.offset && o > n.offset) {
                  if (o > i) {
                    const t = {
                      type: "attribute",
                      offset: i,
                      howMany: o - i,
                      count: this._changeCount++,
                    };
                    this._handleChange(t, e);
                    e.push(t);
                  }
                  t.nodesToHandle = n.offset - t.offset;
                  t.howMany = t.nodesToHandle;
                } else if (t.offset >= n.offset && t.offset < i) {
                  if (o > i) {
                    t.nodesToHandle = o - i;
                    t.offset = i;
                  } else {
                    t.nodesToHandle = 0;
                  }
                }
              }
              if (n.type == "remove") {
                if (t.offset < n.offset && o > n.offset) {
                  const i = {
                    type: "attribute",
                    offset: n.offset,
                    howMany: o - n.offset,
                    count: this._changeCount++,
                  };
                  this._handleChange(i, e);
                  e.push(i);
                  t.nodesToHandle = n.offset - t.offset;
                  t.howMany = t.nodesToHandle;
                }
              }
              if (n.type == "attribute") {
                if (t.offset >= n.offset && o <= i) {
                  t.nodesToHandle = 0;
                  t.howMany = 0;
                  t.offset = 0;
                } else if (t.offset <= n.offset && o >= i) {
                  n.howMany = 0;
                }
              }
            }
          }
          t.howMany = t.nodesToHandle;
          delete t.nodesToHandle;
        }
        _getInsertDiff(t, e, n) {
          return {
            type: "insert",
            position: Fk._createAt(t, e),
            name: n.name,
            attributes: new Map(n.attributes),
            length: 1,
            changeCount: this._changeCount++,
          };
        }
        _getRemoveDiff(t, e, n) {
          return {
            type: "remove",
            position: Fk._createAt(t, e),
            name: n.name,
            attributes: new Map(n.attributes),
            length: 1,
            changeCount: this._changeCount++,
          };
        }
        _getAttributesDiff(t, e, n) {
          const o = [];
          n = new Map(n);
          for (const [i, r] of e) {
            const e = n.has(i) ? n.get(i) : null;
            if (e !== r) {
              o.push({
                type: "attribute",
                position: t.start,
                range: t.clone(),
                length: 1,
                attributeKey: i,
                attributeOldValue: r,
                attributeNewValue: e,
                changeCount: this._changeCount++,
              });
            }
            n.delete(i);
          }
          for (const [e, i] of n) {
            o.push({
              type: "attribute",
              position: t.start,
              range: t.clone(),
              length: 1,
              attributeKey: e,
              attributeOldValue: null,
              attributeNewValue: i,
              changeCount: this._changeCount++,
            });
          }
          return o;
        }
        _isInInsertedElement(t) {
          const e = t.parent;
          if (!e) {
            return false;
          }
          const n = this._changesInElement.get(e);
          const o = t.startOffset;
          if (n) {
            for (const t of n) {
              if (t.type == "insert" && o >= t.offset && o < t.offset + t.howMany) {
                return true;
              }
            }
          }
          return this._isInInsertedElement(e);
        }
        _removeAllNestedChanges(t, e, n) {
          const o = new qk(Fk._createAt(t, e), Fk._createAt(t, e + n));
          for (const t of o.getItems({ shallow: true })) {
            if (t.is("element")) {
              this._elementSnapshots.delete(t);
              this._changesInElement.delete(t);
              this._removeAllNestedChanges(t, 0, t.maxOffset);
            }
          }
        }
      }
      function rv(t) {
        const e = [];
        for (const n of t) {
          if (n.is("$text")) {
            for (let t = 0; t < n.data.length; t++) {
              e.push({ name: "$text", attributes: new Map(n.getAttributes()) });
            }
          } else {
            e.push({ name: n.name, attributes: new Map(n.getAttributes()) });
          }
        }
        return e;
      }
      function sv(t, e) {
        const n = [];
        let o = 0;
        let i = 0;
        for (const t of e) {
          if (t.offset > o) {
            for (let e = 0; e < t.offset - o; e++) {
              n.push("e");
            }
            i += t.offset - o;
          }
          if (t.type == "insert") {
            for (let e = 0; e < t.howMany; e++) {
              n.push("i");
            }
            o = t.offset + t.howMany;
          } else if (t.type == "remove") {
            for (let e = 0; e < t.howMany; e++) {
              n.push("r");
            }
            o = t.offset;
            i += t.howMany;
          } else {
            n.push(..."a".repeat(t.howMany).split(""));
            o = t.offset + t.howMany;
            i += t.howMany;
          }
        }
        if (i < t) {
          for (let e = 0; e < t - i - o; e++) {
            n.push("e");
          }
        }
        return n;
      }
      function av(t) {
        const e = "position" in t && t.position.root.rootName == "$graveyard";
        const n = "range" in t && t.range.root.rootName == "$graveyard";
        return !e && !n;
      }
      class cv {
        constructor() {
          this._operations = [];
          this._undoPairs = new Map();
          this._undoneOperations = new Set();
          this._baseVersionToOperationIndex = new Map();
          this._version = 0;
          this._gaps = new Map();
        }
        get version() {
          return this._version;
        }
        set version(t) {
          if (this._operations.length && t > this._version + 1) {
            this._gaps.set(this._version, t);
          }
          this._version = t;
        }
        get lastOperation() {
          return this._operations[this._operations.length - 1];
        }
        addOperation(t) {
          if (t.baseVersion !== this.version) {
            throw new P("model-document-history-addoperation-incorrect-version", this, {
              operation: t,
              historyVersion: this.version,
            });
          }
          this._operations.push(t);
          this._version++;
          this._baseVersionToOperationIndex.set(t.baseVersion, this._operations.length - 1);
        }
        getOperations(t, e = this.version) {
          if (!this._operations.length) {
            return [];
          }
          const n = this._operations[0];
          if (t === undefined) {
            t = n.baseVersion;
          }
          let o = e - 1;
          for (const [e, n] of this._gaps) {
            if (t > e && t < n) {
              t = n;
            }
            if (o > e && o < n) {
              o = e - 1;
            }
          }
          if (o < n.baseVersion || t > this.lastOperation.baseVersion) {
            return [];
          }
          let i = this._baseVersionToOperationIndex.get(t);
          if (i === undefined) {
            i = 0;
          }
          let r = this._baseVersionToOperationIndex.get(o);
          if (r === undefined) {
            r = this._operations.length - 1;
          }
          return this._operations.slice(i, r + 1);
        }
        getOperation(t) {
          const e = this._baseVersionToOperationIndex.get(t);
          if (e === undefined) {
            return;
          }
          return this._operations[e];
        }
        setOperationAsUndone(t, e) {
          this._undoPairs.set(e, t);
          this._undoneOperations.add(t);
        }
        isUndoingOperation(t) {
          return this._undoPairs.has(t);
        }
        isUndoneOperation(t) {
          return this._undoneOperations.has(t);
        }
        getUndoneOperation(t) {
          return this._undoPairs.get(t);
        }
        reset() {
          this._version = 0;
          this._undoPairs = new Map();
          this._operations = [];
          this._undoneOperations = new Set();
          this._gaps = new Map();
          this._baseVersionToOperationIndex = new Map();
        }
      }
      class lv extends Ok {
        constructor(t, e, n = "main") {
          super(e);
          this._isAttached = true;
          this._isLoaded = true;
          this._document = t;
          this.rootName = n;
        }
        get document() {
          return this._document;
        }
        isAttached() {
          return this._isAttached;
        }
        toJSON() {
          return this.rootName;
        }
      }
      lv.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === "rootElement" ||
            t === "model:rootElement" ||
            t === "element" ||
            t === "model:element" ||
            t === "node" ||
            t === "model:node"
          );
        }
        return (
          e === this.name &&
          (t === "rootElement" ||
            t === "model:rootElement" ||
            t === "element" ||
            t === "model:element")
        );
      };
      const dv = "$graveyard";
      class hv extends q() {
        constructor(t) {
          super();
          this.model = t;
          this.history = new cv();
          this.selection = new db(this);
          this.roots = new ll({ idProperty: "rootName" });
          this.differ = new iv(t.markers);
          this.isReadOnly = false;
          this._postFixers = new Set();
          this._hasSelectionChangedFromTheLastChangeBlock = false;
          this.createRoot("$root", dv);
          this.listenTo(
            t,
            "applyOperation",
            (t, e) => {
              const n = e[0];
              if (n.isDocumentOperation) {
                this.differ.bufferOperation(n);
              }
            },
            { priority: "high" }
          );
          this.listenTo(
            t,
            "applyOperation",
            (t, e) => {
              const n = e[0];
              if (n.isDocumentOperation) {
                this.history.addOperation(n);
              }
            },
            { priority: "low" }
          );
          this.listenTo(this.selection, "change", () => {
            this._hasSelectionChangedFromTheLastChangeBlock = true;
          });
          this.listenTo(t.markers, "update", (t, e, n, o, i) => {
            const r = { ...e.getData(), range: o };
            this.differ.bufferMarkerChange(e.name, i, r);
            if (n === null) {
              e.on("change", (t, n) => {
                const o = e.getData();
                this.differ.bufferMarkerChange(e.name, { ...o, range: n }, o);
              });
            }
          });
          this.registerPostFixer((t) => {
            let e = false;
            for (const n of this.roots) {
              if (!n.isAttached() && !n.isEmpty) {
                t.remove(t.createRangeIn(n));
                e = true;
              }
            }
            for (const n of this.model.markers) {
              if (!n.getRange().root.isAttached()) {
                t.removeMarker(n);
                e = true;
              }
            }
            return e;
          });
        }
        get version() {
          return this.history.version;
        }
        set version(t) {
          this.history.version = t;
        }
        get graveyard() {
          return this.getRoot(dv);
        }
        createRoot(t = "$root", e = "main") {
          if (this.roots.get(e)) {
            throw new P("model-document-createroot-name-exists", this, { name: e });
          }
          const n = new lv(this, t, e);
          this.roots.add(n);
          return n;
        }
        destroy() {
          this.selection.destroy();
          this.stopListening();
        }
        getRoot(t = "main") {
          return this.roots.get(t);
        }
        getRootNames(t = false) {
          return this.getRoots(t).map((t) => t.rootName);
        }
        getRoots(t = false) {
          return Array.from(this.roots).filter(
            (e) => e != this.graveyard && (t || e.isAttached()) && e._isLoaded
          );
        }
        registerPostFixer(t) {
          this._postFixers.add(t);
        }
        toJSON() {
          const t = Su(this);
          t.selection = "[engine.model.DocumentSelection]";
          t.model = "[engine.model.Model]";
          return t;
        }
        _handleChangeBlock(t) {
          if (this._hasDocumentChangedFromTheLastChangeBlock()) {
            this._callPostFixers(t);
            this.selection.refresh();
            if (this.differ.hasDataChanges()) {
              this.fire("change:data", t.batch);
            } else {
              this.fire("change", t.batch);
            }
            this.selection.refresh();
            this.differ.reset();
          }
          this._hasSelectionChangedFromTheLastChangeBlock = false;
        }
        _hasDocumentChangedFromTheLastChangeBlock() {
          return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock;
        }
        _getDefaultRoot() {
          const t = this.getRoots();
          return t.length ? t[0] : this.graveyard;
        }
        _getDefaultRange() {
          const t = this._getDefaultRoot();
          const e = this.model;
          const n = e.schema;
          const o = e.createPositionFromPath(t, [0]);
          const i = n.getNearestSelectionRange(o);
          return i || e.createRange(o);
        }
        _validateSelectionRange(t) {
          return uv(t.start) && uv(t.end);
        }
        _callPostFixers(t) {
          let e = false;
          do {
            for (const n of this._postFixers) {
              this.selection.refresh();
              e = n(t);
              if (e) {
                break;
              }
            }
          } while (e);
        }
      }
      function uv(t) {
        const e = t.textNode;
        if (e) {
          const n = e.data;
          const o = t.offset - e.startOffset;
          return !Al(n, o) && !Cl(n, o);
        }
        return true;
      }
      class fv extends q() {
        constructor() {
          super(...arguments);
          this._markers = new Map();
        }
        [Symbol.iterator]() {
          return this._markers.values();
        }
        has(t) {
          const e = t instanceof pv ? t.name : t;
          return this._markers.has(e);
        }
        get(t) {
          return this._markers.get(t) || null;
        }
        _set(t, e, n = false, o = false) {
          const i = t instanceof pv ? t.name : t;
          if (i.includes(",")) {
            throw new P("markercollection-incorrect-marker-name", this);
          }
          const r = this._markers.get(i);
          if (r) {
            const t = r.getData();
            const s = r.getRange();
            let a = false;
            if (!s.isEqual(e)) {
              r._attachLiveRange(rb.fromRange(e));
              a = true;
            }
            if (n != r.managedUsingOperations) {
              r._managedUsingOperations = n;
              a = true;
            }
            if (typeof o === "boolean" && o != r.affectsData) {
              r._affectsData = o;
              a = true;
            }
            if (a) {
              this.fire(`update:${i}`, r, s, e, t);
            }
            return r;
          }
          const s = rb.fromRange(e);
          const a = new pv(i, s, n, o);
          this._markers.set(i, a);
          this.fire(`update:${i}`, a, null, e, { ...a.getData(), range: null });
          return a;
        }
        _remove(t) {
          const e = t instanceof pv ? t.name : t;
          const n = this._markers.get(e);
          if (n) {
            this._markers.delete(e);
            this.fire(`update:${e}`, n, n.getRange(), null, n.getData());
            this._destroyMarker(n);
            return true;
          }
          return false;
        }
        _refresh(t) {
          const e = t instanceof pv ? t.name : t;
          const n = this._markers.get(e);
          if (!n) {
            throw new P("markercollection-refresh-marker-not-exists", this);
          }
          const o = n.getRange();
          this.fire(`update:${e}`, n, o, o, n.getData());
        }
        *getMarkersAtPosition(t) {
          for (const e of this) {
            if (e.getRange().containsPosition(t)) {
              yield e;
            }
          }
        }
        *getMarkersIntersectingRange(t) {
          for (const e of this) {
            if (e.getRange().getIntersection(t) !== null) {
              yield e;
            }
          }
        }
        destroy() {
          for (const t of this._markers.values()) {
            this._destroyMarker(t);
          }
          this._markers = null;
          this.stopListening();
        }
        *getMarkersGroup(t) {
          for (const e of this._markers.values()) {
            if (e.name.startsWith(t + ":")) {
              yield e;
            }
          }
        }
        _destroyMarker(t) {
          t.stopListening();
          t._detachLiveRange();
        }
      }
      class pv extends q(Dk) {
        constructor(t, e, n, o) {
          super();
          this.name = t;
          this._liveRange = this._attachLiveRange(e);
          this._managedUsingOperations = n;
          this._affectsData = o;
        }
        get managedUsingOperations() {
          if (!this._liveRange) {
            throw new P("marker-destroyed", this);
          }
          return this._managedUsingOperations;
        }
        get affectsData() {
          if (!this._liveRange) {
            throw new P("marker-destroyed", this);
          }
          return this._affectsData;
        }
        getData() {
          return {
            range: this.getRange(),
            affectsData: this.affectsData,
            managedUsingOperations: this.managedUsingOperations,
          };
        }
        getStart() {
          if (!this._liveRange) {
            throw new P("marker-destroyed", this);
          }
          return this._liveRange.start.clone();
        }
        getEnd() {
          if (!this._liveRange) {
            throw new P("marker-destroyed", this);
          }
          return this._liveRange.end.clone();
        }
        getRange() {
          if (!this._liveRange) {
            throw new P("marker-destroyed", this);
          }
          return this._liveRange.toRange();
        }
        _attachLiveRange(t) {
          if (this._liveRange) {
            this._detachLiveRange();
          }
          t.delegate("change:range").to(this);
          t.delegate("change:content").to(this);
          this._liveRange = t;
          return t;
        }
        _detachLiveRange() {
          this._liveRange.stopDelegating("change:range", this);
          this._liveRange.stopDelegating("change:content", this);
          this._liveRange.detach();
          this._liveRange = null;
        }
      }
      pv.prototype.is = function (t) {
        return t === "marker" || t === "model:marker";
      };
      class gv extends b_ {
        constructor(t, e) {
          super(null);
          this.sourcePosition = t.clone();
          this.howMany = e;
        }
        get type() {
          return "detach";
        }
        get affectedSelectable() {
          return null;
        }
        toJSON() {
          const t = super.toJSON();
          t.sourcePosition = this.sourcePosition.toJSON();
          return t;
        }
        _validate() {
          if (this.sourcePosition.root.document) {
            throw new P("detach-operation-on-document-node", this);
          }
        }
        _execute() {
          __(qk._createFromPositionAndShift(this.sourcePosition, this.howMany));
        }
        static get className() {
          return "DetachOperation";
        }
      }
      class mv extends Dk {
        constructor(t) {
          super();
          this.markers = new Map();
          this._children = new Tk();
          if (t) {
            this._insertChild(0, t);
          }
        }
        [Symbol.iterator]() {
          return this.getChildren();
        }
        get childCount() {
          return this._children.length;
        }
        get maxOffset() {
          return this._children.maxOffset;
        }
        get isEmpty() {
          return this.childCount === 0;
        }
        get nextSibling() {
          return null;
        }
        get previousSibling() {
          return null;
        }
        get root() {
          return this;
        }
        get parent() {
          return null;
        }
        get document() {
          return null;
        }
        isAttached() {
          return false;
        }
        getAncestors() {
          return [];
        }
        getChild(t) {
          return this._children.getNode(t);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        getChildIndex(t) {
          return this._children.getNodeIndex(t);
        }
        getChildStartOffset(t) {
          return this._children.getNodeStartOffset(t);
        }
        getPath() {
          return [];
        }
        getNodeByPath(t) {
          let e = this;
          for (const n of t) {
            e = e.getChild(e.offsetToIndex(n));
          }
          return e;
        }
        offsetToIndex(t) {
          return this._children.offsetToIndex(t);
        }
        toJSON() {
          const t = [];
          for (const e of this._children) {
            t.push(e.toJSON());
          }
          return t;
        }
        static fromJSON(t) {
          const e = [];
          for (const n of t) {
            if (n.name) {
              e.push(Ok.fromJSON(n));
            } else {
              e.push(Pk.fromJSON(n));
            }
          }
          return new mv(e);
        }
        _appendChild(t) {
          this._insertChild(this.childCount, t);
        }
        _insertChild(t, e) {
          const n = kv(e);
          for (const t of n) {
            if (t.parent !== null) {
              t._remove();
            }
            t.parent = this;
          }
          this._children._insertNodes(t, n);
        }
        _removeChildren(t, e = 1) {
          const n = this._children._removeNodes(t, e);
          for (const t of n) {
            t.parent = null;
          }
          return n;
        }
      }
      mv.prototype.is = function (t) {
        return t === "documentFragment" || t === "model:documentFragment";
      };
      function kv(t) {
        if (typeof t == "string") {
          return [new Pk(t)];
        }
        if (!Ct(t)) {
          t = [t];
        }
        return Array.from(t).map((t) => {
          if (typeof t == "string") {
            return new Pk(t);
          }
          if (t instanceof Bk) {
            return new Pk(t.data, t.getAttributes());
          }
          return t;
        });
      }
      class bv {
        constructor(t, e) {
          this.model = t;
          this.batch = e;
        }
        createText(t, e) {
          return new Pk(t, e);
        }
        createElement(t, e) {
          return new Ok(t, e);
        }
        createDocumentFragment() {
          return new mv();
        }
        cloneElement(t, e = true) {
          return t._clone(e);
        }
        insert(t, e, n = 0) {
          this._assertWriterUsedCorrectly();
          if (t instanceof Pk && t.data == "") {
            return;
          }
          const o = Fk._createAt(e, n);
          if (t.parent) {
            if (Cv(t.root, o.root)) {
              this.move(qk._createOn(t), o);
              return;
            } else {
              if (t.root.document) {
                throw new P("model-writer-insert-forbidden-move", this);
              } else {
                this.remove(t);
              }
            }
          }
          const i = o.root.document ? o.root.document.version : null;
          const r = new S_(o, t, i);
          if (t instanceof Pk) {
            r.shouldReceiveAttributes = true;
          }
          this.batch.addOperation(r);
          this.model.applyOperation(r);
          if (t instanceof mv) {
            for (const [e, n] of t.markers) {
              const t = Fk._createAt(n.root, 0);
              const i = new qk(n.start._getCombined(t, o), n.end._getCombined(t, o));
              const r = { range: i, usingOperation: true, affectsData: true };
              if (this.model.markers.has(e)) {
                this.updateMarker(e, r);
              } else {
                this.addMarker(e, r);
              }
            }
          }
        }
        insertText(t, e, n, o) {
          if (e instanceof mv || e instanceof Ok || e instanceof Fk) {
            this.insert(this.createText(t), e, n);
          } else {
            this.insert(this.createText(t, e), n, o);
          }
        }
        insertElement(t, e, n, o) {
          if (e instanceof mv || e instanceof Ok || e instanceof Fk) {
            this.insert(this.createElement(t), e, n);
          } else {
            this.insert(this.createElement(t, e), n, o);
          }
        }
        append(t, e) {
          this.insert(t, e, "end");
        }
        appendText(t, e, n) {
          if (e instanceof mv || e instanceof Ok) {
            this.insert(this.createText(t), e, "end");
          } else {
            this.insert(this.createText(t, e), n, "end");
          }
        }
        appendElement(t, e, n) {
          if (e instanceof mv || e instanceof Ok) {
            this.insert(this.createElement(t), e, "end");
          } else {
            this.insert(this.createElement(t, e), n, "end");
          }
        }
        setAttribute(t, e, n) {
          this._assertWriterUsedCorrectly();
          if (n instanceof qk) {
            const o = n.getMinimalFlatRanges();
            for (const n of o) {
              wv(this, t, e, n);
            }
          } else {
            _v(this, t, e, n);
          }
        }
        setAttributes(t, e) {
          for (const [n, o] of pl(t)) {
            this.setAttribute(n, o, e);
          }
        }
        removeAttribute(t, e) {
          this._assertWriterUsedCorrectly();
          if (e instanceof qk) {
            const n = e.getMinimalFlatRanges();
            for (const e of n) {
              wv(this, t, null, e);
            }
          } else {
            _v(this, t, null, e);
          }
        }
        clearAttributes(t) {
          this._assertWriterUsedCorrectly();
          const e = (t) => {
            for (const e of t.getAttributeKeys()) {
              this.removeAttribute(e, t);
            }
          };
          if (!(t instanceof qk)) {
            e(t);
          } else {
            for (const n of t.getItems()) {
              e(n);
            }
          }
        }
        move(t, e, n) {
          this._assertWriterUsedCorrectly();
          if (!(t instanceof qk)) {
            throw new P("writer-move-invalid-range", this);
          }
          if (!t.isFlat) {
            throw new P("writer-move-range-not-flat", this);
          }
          const o = Fk._createAt(e, n);
          if (o.isEqual(t.start)) {
            return;
          }
          this._addOperationForAffectedMarkers("move", t);
          if (!Cv(t.root, o.root)) {
            throw new P("writer-move-different-document", this);
          }
          const i = t.root.document ? t.root.document.version : null;
          const r = new D_(t.start, t.end.offset - t.start.offset, o, i);
          this.batch.addOperation(r);
          this.model.applyOperation(r);
        }
        remove(t) {
          this._assertWriterUsedCorrectly();
          const e = t instanceof qk ? t : qk._createOn(t);
          const n = e.getMinimalFlatRanges().reverse();
          for (const t of n) {
            this._addOperationForAffectedMarkers("move", t);
            Av(t.start, t.end.offset - t.start.offset, this.batch, this.model);
          }
        }
        merge(t) {
          this._assertWriterUsedCorrectly();
          const e = t.nodeBefore;
          const n = t.nodeAfter;
          this._addOperationForAffectedMarkers("merge", t);
          if (!(e instanceof Ok)) {
            throw new P("writer-merge-no-element-before", this);
          }
          if (!(n instanceof Ok)) {
            throw new P("writer-merge-no-element-after", this);
          }
          if (!t.root.document) {
            this._mergeDetached(t);
          } else {
            this._merge(t);
          }
        }
        createPositionFromPath(t, e, n) {
          return this.model.createPositionFromPath(t, e, n);
        }
        createPositionAt(t, e) {
          return this.model.createPositionAt(t, e);
        }
        createPositionAfter(t) {
          return this.model.createPositionAfter(t);
        }
        createPositionBefore(t) {
          return this.model.createPositionBefore(t);
        }
        createRange(t, e) {
          return this.model.createRange(t, e);
        }
        createRangeIn(t) {
          return this.model.createRangeIn(t);
        }
        createRangeOn(t) {
          return this.model.createRangeOn(t);
        }
        createSelection(...t) {
          return this.model.createSelection(...t);
        }
        _mergeDetached(t) {
          const e = t.nodeBefore;
          const n = t.nodeAfter;
          this.move(qk._createIn(n), Fk._createAt(e, "end"));
          this.remove(n);
        }
        _merge(t) {
          const e = Fk._createAt(t.nodeBefore, "end");
          const n = Fk._createAt(t.nodeAfter, 0);
          const o = t.root.document.graveyard;
          const i = new Fk(o, [0]);
          const r = t.root.document.version;
          const s = new P_(n, t.nodeAfter.maxOffset, e, i, r);
          this.batch.addOperation(s);
          this.model.applyOperation(s);
        }
        rename(t, e) {
          this._assertWriterUsedCorrectly();
          if (!(t instanceof Ok)) {
            throw new P("writer-rename-not-element-instance", this);
          }
          const n = t.root.document ? t.root.document.version : null;
          const o = new F_(Fk._createBefore(t), t.name, e, n);
          this.batch.addOperation(o);
          this.model.applyOperation(o);
        }
        split(t, e) {
          this._assertWriterUsedCorrectly();
          let n = t.parent;
          if (!n.parent) {
            throw new P("writer-split-element-no-parent", this);
          }
          if (!e) {
            e = n.parent;
          }
          if (!t.parent.getAncestors({ includeSelf: true }).includes(e)) {
            throw new P("writer-split-invalid-limit-element", this);
          }
          let o;
          let i;
          do {
            const e = n.root.document ? n.root.document.version : null;
            const r = n.maxOffset - t.offset;
            const s = T_.getInsertionPosition(t);
            const a = new T_(t, r, s, null, e);
            this.batch.addOperation(a);
            this.model.applyOperation(a);
            if (!o && !i) {
              o = n;
              i = t.parent.nextSibling;
            }
            t = this.createPositionAfter(t.parent);
            n = t.parent;
          } while (n !== e);
          return { position: t, range: new qk(Fk._createAt(o, "end"), Fk._createAt(i, 0)) };
        }
        wrap(t, e) {
          this._assertWriterUsedCorrectly();
          if (!t.isFlat) {
            throw new P("writer-wrap-range-not-flat", this);
          }
          const n = e instanceof Ok ? e : new Ok(e);
          if (n.childCount > 0) {
            throw new P("writer-wrap-element-not-empty", this);
          }
          if (n.parent !== null) {
            throw new P("writer-wrap-element-attached", this);
          }
          this.insert(n, t.start);
          const o = new qk(t.start.getShiftedBy(1), t.end.getShiftedBy(1));
          this.move(o, Fk._createAt(n, 0));
        }
        unwrap(t) {
          this._assertWriterUsedCorrectly();
          if (t.parent === null) {
            throw new P("writer-unwrap-element-no-parent", this);
          }
          this.move(qk._createIn(t), this.createPositionAfter(t));
          this.remove(t);
        }
        addMarker(t, e) {
          this._assertWriterUsedCorrectly();
          if (!e || typeof e.usingOperation != "boolean") {
            throw new P("writer-addmarker-no-usingoperation", this);
          }
          const n = e.usingOperation;
          const o = e.range;
          const i = e.affectsData === undefined ? false : e.affectsData;
          if (this.model.markers.has(t)) {
            throw new P("writer-addmarker-marker-exists", this);
          }
          if (!o) {
            throw new P("writer-addmarker-no-range", this);
          }
          if (!n) {
            return this.model.markers._set(t, o, n, i);
          }
          vv(this, t, null, o, i);
          return this.model.markers.get(t);
        }
        updateMarker(t, e) {
          this._assertWriterUsedCorrectly();
          const n = typeof t == "string" ? t : t.name;
          const o = this.model.markers.get(n);
          if (!o) {
            throw new P("writer-updatemarker-marker-not-exists", this);
          }
          if (!e) {
            B("writer-updatemarker-reconvert-using-editingcontroller", { markerName: n });
            this.model.markers._refresh(o);
            return;
          }
          const i = typeof e.usingOperation == "boolean";
          const r = typeof e.affectsData == "boolean";
          const s = r ? e.affectsData : o.affectsData;
          if (!i && !e.range && !r) {
            throw new P("writer-updatemarker-wrong-options", this);
          }
          const a = o.getRange();
          const c = e.range ? e.range : a;
          if (i && e.usingOperation !== o.managedUsingOperations) {
            if (e.usingOperation) {
              vv(this, n, null, c, s);
            } else {
              vv(this, n, a, null, s);
              this.model.markers._set(n, c, undefined, s);
            }
            return;
          }
          if (o.managedUsingOperations) {
            vv(this, n, a, c, s);
          } else {
            this.model.markers._set(n, c, undefined, s);
          }
        }
        removeMarker(t) {
          this._assertWriterUsedCorrectly();
          const e = typeof t == "string" ? t : t.name;
          if (!this.model.markers.has(e)) {
            throw new P("writer-removemarker-no-marker", this);
          }
          const n = this.model.markers.get(e);
          if (!n.managedUsingOperations) {
            this.model.markers._remove(e);
            return;
          }
          const o = n.getRange();
          vv(this, e, o, null, n.affectsData);
        }
        addRoot(t, e = "$root") {
          this._assertWriterUsedCorrectly();
          const n = this.model.document.getRoot(t);
          if (n && n.isAttached()) {
            throw new P("writer-addroot-root-exists", this);
          }
          const o = this.model.document;
          const i = new N_(t, e, true, o, o.version);
          this.batch.addOperation(i);
          this.model.applyOperation(i);
          return this.model.document.getRoot(t);
        }
        detachRoot(t) {
          this._assertWriterUsedCorrectly();
          const e = typeof t == "string" ? this.model.document.getRoot(t) : t;
          if (!e || !e.isAttached()) {
            throw new P("writer-detachroot-no-root", this);
          }
          for (const t of this.model.markers) {
            if (t.getRange().root === e) {
              this.removeMarker(t);
            }
          }
          for (const t of e.getAttributeKeys()) {
            this.removeAttribute(t, e);
          }
          this.remove(this.createRangeIn(e));
          const n = this.model.document;
          const o = new N_(e.rootName, e.name, false, n, n.version);
          this.batch.addOperation(o);
          this.model.applyOperation(o);
        }
        setSelection(...t) {
          this._assertWriterUsedCorrectly();
          this.model.document.selection._setTo(...t);
        }
        setSelectionFocus(t, e) {
          this._assertWriterUsedCorrectly();
          this.model.document.selection._setFocus(t, e);
        }
        setSelectionAttribute(t, e) {
          this._assertWriterUsedCorrectly();
          if (typeof t === "string") {
            this._setSelectionAttribute(t, e);
          } else {
            for (const [e, n] of pl(t)) {
              this._setSelectionAttribute(e, n);
            }
          }
        }
        removeSelectionAttribute(t) {
          this._assertWriterUsedCorrectly();
          if (typeof t === "string") {
            this._removeSelectionAttribute(t);
          } else {
            for (const e of t) {
              this._removeSelectionAttribute(e);
            }
          }
        }
        overrideSelectionGravity() {
          return this.model.document.selection._overrideGravity();
        }
        restoreSelectionGravity(t) {
          this.model.document.selection._restoreGravity(t);
        }
        _setSelectionAttribute(t, e) {
          const n = this.model.document.selection;
          if (n.isCollapsed && n.anchor.parent.isEmpty) {
            const o = db._getStoreAttributeKey(t);
            this.setAttribute(o, e, n.anchor.parent);
          }
          n._setAttribute(t, e);
        }
        _removeSelectionAttribute(t) {
          const e = this.model.document.selection;
          if (e.isCollapsed && e.anchor.parent.isEmpty) {
            const n = db._getStoreAttributeKey(t);
            this.removeAttribute(n, e.anchor.parent);
          }
          e._removeAttribute(t);
        }
        _assertWriterUsedCorrectly() {
          if (this.model._currentWriter !== this) {
            throw new P("writer-incorrect-use", this);
          }
        }
        _addOperationForAffectedMarkers(t, e) {
          for (const n of this.model.markers) {
            if (!n.managedUsingOperations) {
              continue;
            }
            const o = n.getRange();
            let i = false;
            if (t === "move") {
              const t = e;
              i =
                t.containsPosition(o.start) ||
                t.start.isEqual(o.start) ||
                t.containsPosition(o.end) ||
                t.end.isEqual(o.end);
            } else {
              const t = e;
              const n = t.nodeBefore;
              const r = t.nodeAfter;
              const s = o.start.parent == n && o.start.isAtEnd;
              const a = o.end.parent == r && o.end.offset == 0;
              const c = o.end.nodeAfter == r;
              const l = o.start.nodeAfter == r;
              i = s || a || c || l;
            }
            if (i) {
              this.updateMarker(n.name, { range: o });
            }
          }
        }
      }
      function wv(t, e, n, o) {
        const i = t.model;
        const r = i.document;
        let s = o.start;
        let a;
        let c;
        let l;
        for (const t of o.getWalker({ shallow: true })) {
          l = t.item.getAttribute(e);
          if (a && c != l) {
            if (c != n) {
              d();
            }
            s = a;
          }
          a = t.nextPosition;
          c = l;
        }
        if (a instanceof Fk && a != s && c != n) {
          d();
        }
        function d() {
          const o = new qk(s, a);
          const l = o.root.document ? r.version : null;
          const d = new I_(o, e, c, n, l);
          t.batch.addOperation(d);
          i.applyOperation(d);
        }
      }
      function _v(t, e, n, o) {
        const i = t.model;
        const r = i.document;
        const s = o.getAttribute(e);
        let a, c;
        if (s != n) {
          const l = o.root === o;
          if (l) {
            const t = o.document ? r.version : null;
            c = new M_(o, e, s, n, t);
          } else {
            a = new qk(Fk._createBefore(o), t.createPositionAfter(o));
            const i = a.root.document ? r.version : null;
            c = new I_(a, e, s, n, i);
          }
          t.batch.addOperation(c);
          i.applyOperation(c);
        }
      }
      function vv(t, e, n, o, i) {
        const r = t.model;
        const s = r.document;
        const a = new B_(e, n, o, r.markers, !!i, s.version);
        t.batch.addOperation(a);
        r.applyOperation(a);
      }
      function Av(t, e, n, o) {
        let i;
        if (t.root.document) {
          const n = o.document;
          const r = new Fk(n.graveyard, [0]);
          i = new D_(t, e, r, n.version);
        } else {
          i = new gv(t, e);
        }
        n.addOperation(i);
        o.applyOperation(i);
      }
      function Cv(t, e) {
        if (t === e) {
          return true;
        }
        if (t instanceof lv && e instanceof lv) {
          return true;
        }
        return false;
      }
      function yv(t, e, n = {}) {
        if (e.isCollapsed) {
          return;
        }
        const o = e.getFirstRange();
        if (o.root.rootName == "$graveyard") {
          return;
        }
        const i = t.schema;
        t.change((t) => {
          if (!n.doNotResetEntireContent && Mv(i, e)) {
            Fv(t, e);
            return;
          }
          const r = {};
          if (!n.doNotAutoparagraph) {
            const t = e.getSelectedElement();
            if (t) {
              Object.assign(r, i.getAttributesWithProperty(t, "copyOnReplace", true));
            }
          }
          const [s, a] = xv(o);
          if (!s.isTouching(a)) {
            t.remove(t.createRange(s, a));
          }
          if (!n.leaveUnmerged) {
            Dv(t, s, a);
            i.removeDisallowedAttributes(s.parent.getChildren(), t);
          }
          Nv(t, e, s);
          if (!n.doNotAutoparagraph && Rv(i, s)) {
            zv(t, s, e, r);
          }
          s.detach();
          a.detach();
        });
      }
      function xv(t) {
        const e = t.root.document.model;
        const n = t.start;
        let o = t.end;
        if (e.hasContent(t, { ignoreMarkers: true })) {
          const n = Ev(o);
          if (n && o.isTouching(e.createPositionAt(n, 0))) {
            const n = e.createSelection(t);
            e.modifySelection(n, { direction: "backward" });
            const i = n.getLastPosition();
            const r = e.createRange(i, o);
            if (!e.hasContent(r, { ignoreMarkers: true })) {
              o = i;
            }
          }
        }
        return [tv.fromPosition(n, "toPrevious"), tv.fromPosition(o, "toNext")];
      }
      function Ev(t) {
        const e = t.parent;
        const n = e.root.document.model.schema;
        const o = e.getAncestors({ parentFirst: true, includeSelf: true });
        for (const t of o) {
          if (n.isLimit(t)) {
            return null;
          }
          if (n.isBlock(t)) {
            return t;
          }
        }
      }
      function Dv(t, e, n) {
        const o = t.model;
        if (!Bv(t.model.schema, e, n)) {
          return;
        }
        const [i, r] = Ov(e, n);
        if (!i || !r) {
          return;
        }
        if (!o.hasContent(i, { ignoreMarkers: true }) && o.hasContent(r, { ignoreMarkers: true })) {
          Tv(t, e, n, i.parent);
        } else {
          Sv(t, e, n, i.parent);
        }
      }
      function Sv(t, e, n, o) {
        const i = e.parent;
        const r = n.parent;
        if (i == o || r == o) {
          return;
        }
        e = t.createPositionAfter(i);
        n = t.createPositionBefore(r);
        if (!n.isEqual(e)) {
          t.insert(r, e);
        }
        t.merge(e);
        while (n.parent.isEmpty) {
          const e = n.parent;
          n = t.createPositionBefore(e);
          t.remove(e);
        }
        if (!Bv(t.model.schema, e, n)) {
          return;
        }
        Sv(t, e, n, o);
      }
      function Tv(t, e, n, o) {
        const i = e.parent;
        const r = n.parent;
        if (i == o || r == o) {
          return;
        }
        e = t.createPositionAfter(i);
        n = t.createPositionBefore(r);
        if (!n.isEqual(e)) {
          t.insert(i, n);
        }
        while (e.parent.isEmpty) {
          const n = e.parent;
          e = t.createPositionBefore(n);
          t.remove(n);
        }
        n = t.createPositionBefore(r);
        Pv(t, n);
        if (!Bv(t.model.schema, e, n)) {
          return;
        }
        Tv(t, e, n, o);
      }
      function Pv(t, e) {
        const n = e.nodeBefore;
        const o = e.nodeAfter;
        if (n.name != o.name) {
          t.rename(n, o.name);
        }
        t.clearAttributes(n);
        t.setAttributes(Object.fromEntries(o.getAttributes()), n);
        t.merge(e);
      }
      function Bv(t, e, n) {
        const o = e.parent;
        const i = n.parent;
        if (o == i) {
          return false;
        }
        if (t.isLimit(o) || t.isLimit(i)) {
          return false;
        }
        return Iv(e, n, t);
      }
      function Ov(t, e) {
        const n = t.getAncestors();
        const o = e.getAncestors();
        let i = 0;
        while (n[i] && n[i] == o[i]) {
          i++;
        }
        return [n[i], o[i]];
      }
      function Rv(t, e) {
        const n = t.checkChild(e, "$text");
        const o = t.checkChild(e, "paragraph");
        return !n && o;
      }
      function Iv(t, e, n) {
        const o = new qk(t, e);
        for (const t of o.getWalker()) {
          if (n.isLimit(t.item)) {
            return false;
          }
        }
        return true;
      }
      function zv(t, e, n, o = {}) {
        const i = t.createElement("paragraph");
        t.model.schema.setAllowedAttributes(i, o, t);
        t.insert(i, e);
        Nv(t, n, t.createPositionAt(i, 0));
      }
      function Fv(t, e) {
        const n = t.model.schema.getLimitElement(e);
        t.remove(t.createRangeIn(n));
        zv(t, t.createPositionAt(n, 0), e);
      }
      function Mv(t, e) {
        const n = t.getLimitElement(e);
        if (!e.containsEntireContent(n)) {
          return false;
        }
        const o = e.getFirstRange();
        if (o.start.parent == o.end.parent) {
          return false;
        }
        return t.checkChild(n, "paragraph");
      }
      function Nv(t, e, n) {
        if (e instanceof db) {
          t.setSelection(n);
        } else {
          e.setTo(n);
        }
      }
      function Vv(t, e) {
        return t.change((t) => {
          const n = t.createDocumentFragment();
          const o = e.getFirstRange();
          if (!o || o.isCollapsed) {
            return n;
          }
          const i = o.start.root;
          const r = o.start.getCommonPath(o.end);
          const s = i.getNodeByPath(r);
          let a;
          if (o.start.parent == o.end.parent) {
            a = o;
          } else {
            a = t.createRange(
              t.createPositionAt(s, o.start.path[r.length]),
              t.createPositionAt(s, o.end.path[r.length] + 1)
            );
          }
          const c = a.end.offset - a.start.offset;
          for (const e of a.getItems({ shallow: true })) {
            if (e.is("$textProxy")) {
              t.appendText(e.data, e.getAttributes(), n);
            } else {
              t.append(t.cloneElement(e, true), n);
            }
          }
          if (a != o) {
            const e = o._getTransformedByMove(a.start, t.createPositionAt(n, 0), c)[0];
            const i = t.createRange(t.createPositionAt(n, 0), e.start);
            const r = t.createRange(e.end, t.createPositionAt(n, "end"));
            Lv(r, t);
            Lv(i, t);
          }
          return n;
        });
      }
      function Lv(t, e) {
        const n = [];
        Array.from(t.getItems({ direction: "backward" }))
          .map((t) => e.createRangeOn(t))
          .filter((e) => {
            const n =
              (e.start.isAfter(t.start) || e.start.isEqual(t.start)) &&
              (e.end.isBefore(t.end) || e.end.isEqual(t.end));
            return n;
          })
          .forEach((t) => {
            n.push(t.start.parent);
            e.remove(t);
          });
        n.forEach((t) => {
          let n = t;
          while (n.parent && n.isEmpty) {
            const t = e.createRangeOn(n);
            n = n.parent;
            e.remove(t);
          }
        });
      }
      function Hv(t, e, n) {
        return t.change((o) => {
          const i = n ? n : t.document.selection;
          if (!i.isCollapsed) {
            t.deleteContent(i, { doNotAutoparagraph: true });
          }
          const r = new jv(t, o, i.anchor);
          const s = [];
          let a;
          if (e.is("documentFragment")) {
            if (e.markers.size) {
              const t = [];
              for (const [n, o] of e.markers) {
                const { start: e, end: i } = o;
                const r = e.isEqual(i);
                t.push(
                  { position: e, name: n, isCollapsed: r },
                  { position: i, name: n, isCollapsed: r }
                );
              }
              t.sort(({ position: t }, { position: e }) => (t.isBefore(e) ? 1 : -1));
              for (const { position: n, name: i, isCollapsed: r } of t) {
                let t = null;
                let a = null;
                const c = n.parent === e && n.isAtStart;
                const l = n.parent === e && n.isAtEnd;
                if (!c && !l) {
                  t = o.createElement("$marker");
                  o.insert(t, n);
                } else if (r) {
                  a = c ? "start" : "end";
                }
                s.push({ name: i, element: t, collapsed: a });
              }
            }
            a = e.getChildren();
          } else {
            a = [e];
          }
          r.handleNodes(a);
          let c = r.getSelectionRange();
          if (e.is("documentFragment") && s.length) {
            const t = c ? rb.fromRange(c) : null;
            const e = {};
            for (let t = s.length - 1; t >= 0; t--) {
              const { name: n, element: i, collapsed: a } = s[t];
              const c = !e[n];
              if (c) {
                e[n] = [];
              }
              if (i) {
                const t = o.createPositionAt(i, "before");
                e[n].push(t);
                o.remove(i);
              } else {
                const t = r.getAffectedRange();
                if (!t) {
                  if (a) {
                    e[n].push(r.position);
                  }
                  continue;
                }
                if (a) {
                  e[n].push(t[a]);
                } else {
                  e[n].push(c ? t.start : t.end);
                }
              }
            }
            for (const [t, [n, i]] of Object.entries(e)) {
              if (n && i && n.root === i.root) {
                o.addMarker(t, { usingOperation: true, affectsData: true, range: new qk(n, i) });
              }
            }
            if (t) {
              c = t.toRange();
              t.detach();
            }
          }
          if (c) {
            if (i instanceof db) {
              o.setSelection(c);
            } else {
              i.setTo(c);
            }
          } else {
          }
          const l = r.getAffectedRange() || t.createRange(i.anchor);
          r.destroy();
          return l;
        });
      }
      class jv {
        constructor(t, e, n) {
          this._firstNode = null;
          this._lastNode = null;
          this._lastAutoParagraph = null;
          this._filterAttributesOf = [];
          this._affectedStart = null;
          this._affectedEnd = null;
          this._nodeToSelect = null;
          this.model = t;
          this.writer = e;
          this.position = n;
          this.canMergeWith = new Set([this.position.parent]);
          this.schema = t.schema;
          this._documentFragment = e.createDocumentFragment();
          this._documentFragmentPosition = e.createPositionAt(this._documentFragment, 0);
        }
        handleNodes(t) {
          for (const e of Array.from(t)) {
            this._handleNode(e);
          }
          this._insertPartialFragment();
          if (this._lastAutoParagraph) {
            this._updateLastNodeFromAutoParagraph(this._lastAutoParagraph);
          }
          this._mergeOnRight();
          this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer);
          this._filterAttributesOf = [];
        }
        _updateLastNodeFromAutoParagraph(t) {
          const e = this.writer.createPositionAfter(this._lastNode);
          const n = this.writer.createPositionAfter(t);
          if (n.isAfter(e)) {
            this._lastNode = t;
            if (this.position.parent != t || !this.position.isAtEnd) {
              throw new P("insertcontent-invalid-insertion-position", this);
            }
            this.position = n;
            this._setAffectedBoundaries(this.position);
          }
        }
        getSelectionRange() {
          if (this._nodeToSelect) {
            return qk._createOn(this._nodeToSelect);
          }
          return this.model.schema.getNearestSelectionRange(this.position);
        }
        getAffectedRange() {
          if (!this._affectedStart) {
            return null;
          }
          return new qk(this._affectedStart, this._affectedEnd);
        }
        destroy() {
          if (this._affectedStart) {
            this._affectedStart.detach();
          }
          if (this._affectedEnd) {
            this._affectedEnd.detach();
          }
        }
        _handleNode(t) {
          if (this.schema.isObject(t)) {
            this._handleObject(t);
            return;
          }
          let e = this._checkAndAutoParagraphToAllowedPosition(t);
          if (!e) {
            e = this._checkAndSplitToAllowedPosition(t);
            if (!e) {
              this._handleDisallowedNode(t);
              return;
            }
          }
          this._appendToFragment(t);
          if (!this._firstNode) {
            this._firstNode = t;
          }
          this._lastNode = t;
        }
        _insertPartialFragment() {
          if (this._documentFragment.isEmpty) {
            return;
          }
          const t = tv.fromPosition(this.position, "toNext");
          this._setAffectedBoundaries(this.position);
          if (this._documentFragment.getChild(0) == this._firstNode) {
            this.writer.insert(this._firstNode, this.position);
            this._mergeOnLeft();
            this.position = t.toPosition();
          }
          if (!this._documentFragment.isEmpty) {
            this.writer.insert(this._documentFragment, this.position);
          }
          this._documentFragmentPosition = this.writer.createPositionAt(this._documentFragment, 0);
          this.position = t.toPosition();
          t.detach();
        }
        _handleObject(t) {
          if (this._checkAndSplitToAllowedPosition(t)) {
            this._appendToFragment(t);
          } else {
            this._tryAutoparagraphing(t);
          }
        }
        _handleDisallowedNode(t) {
          if (t.is("element")) {
            this.handleNodes(t.getChildren());
          } else {
            this._tryAutoparagraphing(t);
          }
        }
        _appendToFragment(t) {
          if (!this.schema.checkChild(this.position, t)) {
            throw new P("insertcontent-wrong-position", this, { node: t, position: this.position });
          }
          this.writer.insert(t, this._documentFragmentPosition);
          this._documentFragmentPosition = this._documentFragmentPosition.getShiftedBy(
            t.offsetSize
          );
          if (this.schema.isObject(t) && !this.schema.checkChild(this.position, "$text")) {
            this._nodeToSelect = t;
          } else {
            this._nodeToSelect = null;
          }
          this._filterAttributesOf.push(t);
        }
        _setAffectedBoundaries(t) {
          if (!this._affectedStart) {
            this._affectedStart = tv.fromPosition(t, "toPrevious");
          }
          if (!this._affectedEnd || this._affectedEnd.isBefore(t)) {
            if (this._affectedEnd) {
              this._affectedEnd.detach();
            }
            this._affectedEnd = tv.fromPosition(t, "toNext");
          }
        }
        _mergeOnLeft() {
          const t = this._firstNode;
          if (!(t instanceof Ok)) {
            return;
          }
          if (!this._canMergeLeft(t)) {
            return;
          }
          const e = tv._createBefore(t);
          e.stickiness = "toNext";
          const n = tv.fromPosition(this.position, "toNext");
          if (this._affectedStart.isEqual(e)) {
            this._affectedStart.detach();
            this._affectedStart = tv._createAt(e.nodeBefore, "end", "toPrevious");
          }
          if (this._firstNode === this._lastNode) {
            this._firstNode = e.nodeBefore;
            this._lastNode = e.nodeBefore;
          }
          this.writer.merge(e);
          if (e.isEqual(this._affectedEnd) && this._firstNode === this._lastNode) {
            this._affectedEnd.detach();
            this._affectedEnd = tv._createAt(e.nodeBefore, "end", "toNext");
          }
          this.position = n.toPosition();
          n.detach();
          this._filterAttributesOf.push(this.position.parent);
          e.detach();
        }
        _mergeOnRight() {
          const t = this._lastNode;
          if (!(t instanceof Ok)) {
            return;
          }
          if (!this._canMergeRight(t)) {
            return;
          }
          const e = tv._createAfter(t);
          e.stickiness = "toNext";
          if (!this.position.isEqual(e)) {
            throw new P("insertcontent-invalid-insertion-position", this);
          }
          this.position = Fk._createAt(e.nodeBefore, "end");
          const n = tv.fromPosition(this.position, "toPrevious");
          if (this._affectedEnd.isEqual(e)) {
            this._affectedEnd.detach();
            this._affectedEnd = tv._createAt(e.nodeBefore, "end", "toNext");
          }
          if (this._firstNode === this._lastNode) {
            this._firstNode = e.nodeBefore;
            this._lastNode = e.nodeBefore;
          }
          this.writer.merge(e);
          if (
            e.getShiftedBy(-1).isEqual(this._affectedStart) &&
            this._firstNode === this._lastNode
          ) {
            this._affectedStart.detach();
            this._affectedStart = tv._createAt(e.nodeBefore, 0, "toPrevious");
          }
          this.position = n.toPosition();
          n.detach();
          this._filterAttributesOf.push(this.position.parent);
          e.detach();
        }
        _canMergeLeft(t) {
          const e = t.previousSibling;
          return e instanceof Ok && this.canMergeWith.has(e) && this.model.schema.checkMerge(e, t);
        }
        _canMergeRight(t) {
          const e = t.nextSibling;
          return e instanceof Ok && this.canMergeWith.has(e) && this.model.schema.checkMerge(t, e);
        }
        _tryAutoparagraphing(t) {
          const e = this.writer.createElement("paragraph");
          if (this._getAllowedIn(this.position.parent, e) && this.schema.checkChild(e, t)) {
            e._appendChild(t);
            this._handleNode(e);
          }
        }
        _checkAndAutoParagraphToAllowedPosition(t) {
          if (this.schema.checkChild(this.position.parent, t)) {
            return true;
          }
          if (
            !this.schema.checkChild(this.position.parent, "paragraph") ||
            !this.schema.checkChild("paragraph", t)
          ) {
            return false;
          }
          this._insertPartialFragment();
          const e = this.writer.createElement("paragraph");
          this.writer.insert(e, this.position);
          this._setAffectedBoundaries(this.position);
          this._lastAutoParagraph = e;
          this.position = this.writer.createPositionAt(e, 0);
          return true;
        }
        _checkAndSplitToAllowedPosition(t) {
          const e = this._getAllowedIn(this.position.parent, t);
          if (!e) {
            return false;
          }
          if (e != this.position.parent) {
            this._insertPartialFragment();
          }
          while (e != this.position.parent) {
            if (this.position.isAtStart) {
              const t = this.position.parent;
              this.position = this.writer.createPositionBefore(t);
              if (t.isEmpty && t.parent === e) {
                this.writer.remove(t);
              }
            } else if (this.position.isAtEnd) {
              this.position = this.writer.createPositionAfter(this.position.parent);
            } else {
              const t = this.writer.createPositionAfter(this.position.parent);
              this._setAffectedBoundaries(this.position);
              this.writer.split(this.position);
              this.position = t;
              this.canMergeWith.add(this.position.nodeAfter);
            }
          }
          return true;
        }
        _getAllowedIn(t, e) {
          if (this.schema.checkChild(t, e)) {
            return t;
          }
          if (this.schema.isLimit(t)) {
            return null;
          }
          return this._getAllowedIn(t.parent, e);
        }
      }
      function qv(t, e, n = "auto") {
        const o = t.getSelectedElement();
        if (o && e.schema.isObject(o) && !e.schema.isInline(o)) {
          if (n == "before" || n == "after") {
            return e.createRange(e.createPositionAt(o, n));
          }
          return e.createRangeOn(o);
        }
        const i = dl(t.getSelectedBlocks());
        if (!i) {
          return e.createRange(t.focus);
        }
        if (i.isEmpty) {
          return e.createRange(e.createPositionAt(i, 0));
        }
        const r = e.createPositionAfter(i);
        if (t.focus.isTouching(r)) {
          return e.createRange(r);
        }
        return e.createRange(e.createPositionBefore(i));
      }
      function $v(t, e, n, o = {}) {
        if (!t.schema.isObject(e)) {
          throw new P("insertobject-element-not-an-object", t, { object: e });
        }
        const i = n ? n : t.document.selection;
        let r = i;
        if (o.findOptimalPosition && t.schema.isBlock(e)) {
          r = t.createSelection(qv(i, t, o.findOptimalPosition));
        }
        const s = dl(i.getSelectedBlocks());
        const a = {};
        if (s) {
          Object.assign(a, t.schema.getAttributesWithProperty(s, "copyOnReplace", true));
        }
        return t.change((n) => {
          if (!r.isCollapsed) {
            t.deleteContent(r, { doNotAutoparagraph: true });
          }
          let i = e;
          const s = r.anchor.parent;
          if (
            !t.schema.checkChild(s, e) &&
            t.schema.checkChild(s, "paragraph") &&
            t.schema.checkChild("paragraph", e)
          ) {
            i = n.createElement("paragraph");
            n.insert(e, i);
          }
          t.schema.setAllowedAttributes(i, a, n);
          const c = t.insertContent(i, r);
          if (c.isCollapsed) {
            return c;
          }
          if (o.setSelection) {
            Wv(n, e, o.setSelection, a);
          }
          return c;
        });
      }
      function Wv(t, e, n, o) {
        const i = t.model;
        if (n == "on") {
          t.setSelection(e, "on");
          return;
        }
        if (n != "after") {
          throw new P("insertobject-invalid-place-parameter-value", i);
        }
        let r = e.nextSibling;
        if (i.schema.isInline(e)) {
          t.setSelection(e, "after");
          return;
        }
        const s = r && i.schema.checkChild(r, "$text");
        if (!s && i.schema.checkChild(e.parent, "paragraph")) {
          r = t.createElement("paragraph");
          i.schema.setAllowedAttributes(r, o, t);
          i.insertContent(r, t.createPositionAfter(e));
        }
        if (r) {
          t.setSelection(r, 0);
        }
      }
      const Gv = ' ,.?!:;"-()';
      function Kv(t, e, n = {}) {
        const o = t.schema;
        const i = n.direction != "backward";
        const r = n.unit ? n.unit : "character";
        const s = !!n.treatEmojiAsSingleUnit;
        const a = e.focus;
        const c = new Ik({
          boundaries: Yv(a, i),
          singleCharacters: true,
          direction: i ? "forward" : "backward",
        });
        const l = { walker: c, schema: o, isForward: i, unit: r, treatEmojiAsSingleUnit: s };
        let d;
        while ((d = c.next())) {
          if (d.done) {
            return;
          }
          const n = Uv(l, d.value);
          if (n) {
            if (e instanceof db) {
              t.change((t) => {
                t.setSelectionFocus(n);
              });
            } else {
              e.setFocus(n);
            }
            return;
          }
        }
      }
      function Uv(t, e) {
        const { isForward: n, walker: o, unit: i, schema: r, treatEmojiAsSingleUnit: s } = t;
        const { type: a, item: c, nextPosition: l } = e;
        if (a == "text") {
          if (t.unit === "word") {
            return Jv(o, n);
          }
          return Zv(o, i, s);
        }
        if (a == (n ? "elementStart" : "elementEnd")) {
          if (r.isSelectable(c)) {
            return Fk._createAt(c, n ? "after" : "before");
          }
          if (r.checkChild(l, "$text")) {
            return l;
          }
        } else {
          if (r.isLimit(c)) {
            o.skip(() => true);
            return;
          }
          if (r.checkChild(l, "$text")) {
            return l;
          }
        }
      }
      function Zv(t, e, n) {
        const o = t.position.textNode;
        if (o) {
          const i = o.data;
          let r = t.position.offset - o.startOffset;
          while (Al(i, r) || (e == "character" && Cl(i, r)) || (n && xl(i, r))) {
            t.next();
            r = t.position.offset - o.startOffset;
          }
        }
        return t.position;
      }
      function Jv(t, e) {
        let n = t.position.textNode;
        if (!n) {
          n = e ? t.position.nodeAfter : t.position.nodeBefore;
        }
        while (n && n.is("$text")) {
          const o = t.position.offset - n.startOffset;
          if (Xv(n, o, e)) {
            n = e ? t.position.nodeAfter : t.position.nodeBefore;
          } else if (Qv(n.data, o, e)) {
            break;
          } else {
            t.next();
          }
        }
        return t.position;
      }
      function Yv(t, e) {
        const n = t.root;
        const o = Fk._createAt(n, e ? "end" : 0);
        if (e) {
          return new qk(t, o);
        } else {
          return new qk(o, t);
        }
      }
      function Qv(t, e, n) {
        const o = e + (n ? 0 : -1);
        return Gv.includes(t.charAt(o));
      }
      function Xv(t, e, n) {
        return e === (n ? t.offsetSize : 0);
      }
      class tA extends lt() {
        constructor() {
          super();
          this.markers = new fv();
          this.document = new hv(this);
          this.schema = new jw();
          this._pendingChanges = [];
          this._currentWriter = null;
          ["deleteContent", "modifySelection", "getSelectedContent", "applyOperation"].forEach(
            (t) => this.decorate(t)
          );
          this.on(
            "applyOperation",
            (t, e) => {
              const n = e[0];
              n._validate();
            },
            { priority: "highest" }
          );
          this.schema.register("$root", { isLimit: true });
          this.schema.register("$container", { allowIn: ["$root", "$container"] });
          this.schema.register("$block", { allowIn: ["$root", "$container"], isBlock: true });
          this.schema.register("$blockObject", {
            allowWhere: "$block",
            isBlock: true,
            isObject: true,
          });
          this.schema.register("$inlineObject", {
            allowWhere: "$text",
            allowAttributesOf: "$text",
            isInline: true,
            isObject: true,
          });
          this.schema.register("$text", { allowIn: "$block", isInline: true, isContent: true });
          this.schema.register("$clipboardHolder", {
            allowContentOf: "$root",
            allowChildren: "$text",
            isLimit: true,
          });
          this.schema.register("$documentFragment", {
            allowContentOf: "$root",
            allowChildren: "$text",
            isLimit: true,
          });
          this.schema.register("$marker");
          this.schema.addChildCheck((t, e) => {
            if (e.name === "$marker") {
              return true;
            }
          });
          Sw(this);
          this.document.registerPostFixer(rw);
          this.on("insertContent", (t, [e, n]) => {
            t.return = Hv(this, e, n);
          });
          this.on("insertObject", (t, [e, n, o]) => {
            t.return = $v(this, e, n, o);
          });
          this.on("canEditAt", (t) => {
            const e = !this.document.isReadOnly;
            t.return = e;
            if (!e) {
              t.stop();
            }
          });
        }
        change(t) {
          try {
            if (this._pendingChanges.length === 0) {
              this._pendingChanges.push({ batch: new ov(), callback: t });
              return this._runPendingChanges()[0];
            } else {
              return t(this._currentWriter);
            }
          } catch (t) {
            P.rethrowUnexpectedError(t, this);
          }
        }
        enqueueChange(t, e) {
          try {
            if (!t) {
              t = new ov();
            } else if (typeof t === "function") {
              e = t;
              t = new ov();
            } else if (!(t instanceof ov)) {
              t = new ov(t);
            }
            this._pendingChanges.push({ batch: t, callback: e });
            if (this._pendingChanges.length == 1) {
              this._runPendingChanges();
            }
          } catch (t) {
            P.rethrowUnexpectedError(t, this);
          }
        }
        applyOperation(t) {
          t._execute();
        }
        insertContent(t, e, n, ...o) {
          const i = eA(e, n);
          return this.fire("insertContent", [t, i, n, ...o]);
        }
        insertObject(t, e, n, o, ...i) {
          const r = eA(e, n);
          return this.fire("insertObject", [t, r, o, o, ...i]);
        }
        deleteContent(t, e) {
          yv(this, t, e);
        }
        modifySelection(t, e) {
          Kv(this, t, e);
        }
        getSelectedContent(t) {
          return Vv(this, t);
        }
        hasContent(t, e = {}) {
          const n = t instanceof qk ? t : qk._createIn(t);
          if (n.isCollapsed) {
            return false;
          }
          const { ignoreWhitespaces: o = false, ignoreMarkers: i = false } = e;
          if (!i) {
            for (const t of this.markers.getMarkersIntersectingRange(n)) {
              if (t.affectsData) {
                return true;
              }
            }
          }
          for (const t of n.getItems()) {
            if (this.schema.isContent(t)) {
              if (t.is("$textProxy")) {
                if (!o) {
                  return true;
                } else if (t.data.search(/\S/) !== -1) {
                  return true;
                }
              } else {
                return true;
              }
            }
          }
          return false;
        }
        canEditAt(t) {
          const e = eA(t);
          return this.fire("canEditAt", [e]);
        }
        createPositionFromPath(t, e, n) {
          return new Fk(t, e, n);
        }
        createPositionAt(t, e) {
          return Fk._createAt(t, e);
        }
        createPositionAfter(t) {
          return Fk._createAfter(t);
        }
        createPositionBefore(t) {
          return Fk._createBefore(t);
        }
        createRange(t, e) {
          return new qk(t, e);
        }
        createRangeIn(t) {
          return qk._createIn(t);
        }
        createRangeOn(t) {
          return qk._createOn(t);
        }
        createSelection(...t) {
          return new Yk(...t);
        }
        createBatch(t) {
          return new ov(t);
        }
        createOperationFromJSON(t) {
          return L_.fromJSON(t, this.document);
        }
        destroy() {
          this.document.destroy();
          this.stopListening();
        }
        _runPendingChanges() {
          const t = [];
          this.fire("_beforeChanges");
          try {
            while (this._pendingChanges.length) {
              const e = this._pendingChanges[0].batch;
              this._currentWriter = new bv(this, e);
              const n = this._pendingChanges[0].callback(this._currentWriter);
              t.push(n);
              this.document._handleChangeBlock(this._currentWriter);
              this._pendingChanges.shift();
              this._currentWriter = null;
            }
          } finally {
            this._pendingChanges.length = 0;
            this._currentWriter = null;
            this.fire("_afterChanges");
          }
          return t;
        }
      }
      function eA(t, e) {
        if (!t) {
          return;
        }
        if (t instanceof Yk || t instanceof db) {
          return t;
        }
        if (t instanceof Sk) {
          if (e || e === 0) {
            return new Yk(t, e);
          } else if (t.is("rootElement")) {
            return new Yk(t, "in");
          } else {
            return new Yk(t, "on");
          }
        }
        return new Yk(t);
      }
      class nA extends (null && DomEventObserver) {
        constructor() {
          super(...arguments);
          this.domEventType = "click";
        }
        onDomEvent(t) {
          this.fire(t.type, t);
        }
      }
      class oA extends dm {
        constructor() {
          super(...arguments);
          this.domEventType = ["mousedown", "mouseup", "mouseover", "mouseout"];
        }
        onDomEvent(t) {
          this.fire(t.type, t);
        }
      }
      class iA {
        constructor(t) {
          this.document = t;
        }
        createDocumentFragment(t) {
          return new DocumentFragment(this.document, t);
        }
        createElement(t, e, n) {
          return new Element(this.document, t, e, n);
        }
        createText(t) {
          return new Text(this.document, t);
        }
        clone(t, e = false) {
          return t._clone(e);
        }
        appendChild(t, e) {
          return e._appendChild(t);
        }
        insertChild(t, e, n) {
          return n._insertChild(t, e);
        }
        removeChildren(t, e, n) {
          return n._removeChildren(t, e);
        }
        remove(t) {
          const e = t.parent;
          if (e) {
            return this.removeChildren(e.getChildIndex(t), 1, e);
          }
          return [];
        }
        replace(t, e) {
          const n = t.parent;
          if (n) {
            const o = n.getChildIndex(t);
            this.removeChildren(o, 1, n);
            this.insertChild(o, e, n);
            return true;
          }
          return false;
        }
        unwrapElement(t) {
          const e = t.parent;
          if (e) {
            const n = e.getChildIndex(t);
            this.remove(t);
            this.insertChild(n, t.getChildren(), e);
          }
        }
        rename(t, e) {
          const n = new Element(this.document, t, e.getAttributes(), e.getChildren());
          return this.replace(e, n) ? n : null;
        }
        setAttribute(t, e, n) {
          n._setAttribute(t, e);
        }
        removeAttribute(t, e) {
          e._removeAttribute(t);
        }
        addClass(t, e) {
          e._addClass(t);
        }
        removeClass(t, e) {
          e._removeClass(t);
        }
        setStyle(t, e, n) {
          if (isPlainObject(t) && n === undefined) {
            e._setStyle(t);
          } else {
            n._setStyle(t, e);
          }
        }
        removeStyle(t, e) {
          e._removeStyle(t);
        }
        setCustomProperty(t, e, n) {
          n._setCustomProperty(t, e);
        }
        removeCustomProperty(t, e) {
          return e._removeCustomProperty(t);
        }
        createPositionAt(t, e) {
          return Position._createAt(t, e);
        }
        createPositionAfter(t) {
          return Position._createAfter(t);
        }
        createPositionBefore(t) {
          return Position._createBefore(t);
        }
        createRange(t, e) {
          return new Range(t, e);
        }
        createRangeOn(t) {
          return Range._createOn(t);
        }
        createRangeIn(t) {
          return Range._createIn(t);
        }
        createSelection(...t) {
          return new Selection(...t);
        }
      }
      const rA = /^#([0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/i;
      const sA = /^rgb\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}[0-9]{1,3}[ %]?\)$/i;
      const aA = /^rgba\([ ]?([0-9]{1,3}[ %]?,[ ]?){3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i;
      const cA = /^hsl\([ ]?([0-9]{1,3}[ %]?[,]?[ ]*){3}(1|[0-9]+%|[0]?\.?[0-9]+)?\)$/i;
      const lA = /^hsla\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i;
      const dA = /\w+\((?:[^()]|\([^()]*\))*\)|\S+/gi;
      const hA = new Set([
        "black",
        "silver",
        "gray",
        "white",
        "maroon",
        "red",
        "purple",
        "fuchsia",
        "green",
        "lime",
        "olive",
        "yellow",
        "navy",
        "blue",
        "teal",
        "aqua",
        "orange",
        "aliceblue",
        "antiquewhite",
        "aquamarine",
        "azure",
        "beige",
        "bisque",
        "blanchedalmond",
        "blueviolet",
        "brown",
        "burlywood",
        "cadetblue",
        "chartreuse",
        "chocolate",
        "coral",
        "cornflowerblue",
        "cornsilk",
        "crimson",
        "cyan",
        "darkblue",
        "darkcyan",
        "darkgoldenrod",
        "darkgray",
        "darkgreen",
        "darkgrey",
        "darkkhaki",
        "darkmagenta",
        "darkolivegreen",
        "darkorange",
        "darkorchid",
        "darkred",
        "darksalmon",
        "darkseagreen",
        "darkslateblue",
        "darkslategray",
        "darkslategrey",
        "darkturquoise",
        "darkviolet",
        "deeppink",
        "deepskyblue",
        "dimgray",
        "dimgrey",
        "dodgerblue",
        "firebrick",
        "floralwhite",
        "forestgreen",
        "gainsboro",
        "ghostwhite",
        "gold",
        "goldenrod",
        "greenyellow",
        "grey",
        "honeydew",
        "hotpink",
        "indianred",
        "indigo",
        "ivory",
        "khaki",
        "lavender",
        "lavenderblush",
        "lawngreen",
        "lemonchiffon",
        "lightblue",
        "lightcoral",
        "lightcyan",
        "lightgoldenrodyellow",
        "lightgray",
        "lightgreen",
        "lightgrey",
        "lightpink",
        "lightsalmon",
        "lightseagreen",
        "lightskyblue",
        "lightslategray",
        "lightslategrey",
        "lightsteelblue",
        "lightyellow",
        "limegreen",
        "linen",
        "magenta",
        "mediumaquamarine",
        "mediumblue",
        "mediumorchid",
        "mediumpurple",
        "mediumseagreen",
        "mediumslateblue",
        "mediumspringgreen",
        "mediumturquoise",
        "mediumvioletred",
        "midnightblue",
        "mintcream",
        "mistyrose",
        "moccasin",
        "navajowhite",
        "oldlace",
        "olivedrab",
        "orangered",
        "orchid",
        "palegoldenrod",
        "palegreen",
        "paleturquoise",
        "palevioletred",
        "papayawhip",
        "peachpuff",
        "peru",
        "pink",
        "plum",
        "powderblue",
        "rosybrown",
        "royalblue",
        "saddlebrown",
        "salmon",
        "sandybrown",
        "seagreen",
        "seashell",
        "sienna",
        "skyblue",
        "slateblue",
        "slategray",
        "slategrey",
        "snow",
        "springgreen",
        "steelblue",
        "tan",
        "thistle",
        "tomato",
        "turquoise",
        "violet",
        "wheat",
        "whitesmoke",
        "yellowgreen",
        "activeborder",
        "activecaption",
        "appworkspace",
        "background",
        "buttonface",
        "buttonhighlight",
        "buttonshadow",
        "buttontext",
        "captiontext",
        "graytext",
        "highlight",
        "highlighttext",
        "inactiveborder",
        "inactivecaption",
        "inactivecaptiontext",
        "infobackground",
        "infotext",
        "menu",
        "menutext",
        "scrollbar",
        "threeddarkshadow",
        "threedface",
        "threedhighlight",
        "threedlightshadow",
        "threedshadow",
        "window",
        "windowframe",
        "windowtext",
        "rebeccapurple",
        "currentcolor",
        "transparent",
      ]);
      function uA(t) {
        if (t.startsWith("#")) {
          return rA.test(t);
        }
        if (t.startsWith("rgb")) {
          return sA.test(t) || aA.test(t);
        }
        if (t.startsWith("hsl")) {
          return cA.test(t) || lA.test(t);
        }
        return hA.has(t.toLowerCase());
      }
      const fA = null && [
        "none",
        "hidden",
        "dotted",
        "dashed",
        "solid",
        "double",
        "groove",
        "ridge",
        "inset",
        "outset",
      ];
      function pA(t) {
        return fA.includes(t);
      }
      const gA = /^([+-]?[0-9]*([.][0-9]+)?(px|cm|mm|in|pc|pt|ch|em|ex|rem|vh|vw|vmin|vmax)|0)$/;
      function mA(t) {
        return gA.test(t);
      }
      const kA = /^[+-]?[0-9]*([.][0-9]+)?%$/;
      function bA(t) {
        return kA.test(t);
      }
      const wA = null && ["repeat-x", "repeat-y", "repeat", "space", "round", "no-repeat"];
      function _A(t) {
        return wA.includes(t);
      }
      const vA = null && ["center", "top", "bottom", "left", "right"];
      function AA(t) {
        return vA.includes(t);
      }
      const CA = null && ["fixed", "scroll", "local"];
      function yA(t) {
        return CA.includes(t);
      }
      const xA = /^url\(/;
      function EA(t) {
        return xA.test(t);
      }
      function DA(t = "") {
        if (t === "") {
          return { top: undefined, right: undefined, bottom: undefined, left: undefined };
        }
        const e = BA(t);
        const n = e[0];
        const o = e[2] || n;
        const i = e[1] || n;
        const r = e[3] || i;
        return { top: n, bottom: o, right: i, left: r };
      }
      function SA(t) {
        return (e) => {
          const { top: n, right: o, bottom: i, left: r } = e;
          const s = [];
          if (![n, o, r, i].every((t) => !!t)) {
            if (n) {
              s.push([t + "-top", n]);
            }
            if (o) {
              s.push([t + "-right", o]);
            }
            if (i) {
              s.push([t + "-bottom", i]);
            }
            if (r) {
              s.push([t + "-left", r]);
            }
          } else {
            s.push([t, TA(e)]);
          }
          return s;
        };
      }
      function TA({ top: t, right: e, bottom: n, left: o }) {
        const i = [];
        if (o !== e) {
          i.push(t, e, n, o);
        } else if (n !== t) {
          i.push(t, e, n);
        } else if (e !== t) {
          i.push(t, e);
        } else {
          i.push(t);
        }
        return i.join(" ");
      }
      function PA(t) {
        return (e) => ({ path: t, value: DA(e) });
      }
      function BA(t) {
        const e = t.matchAll(dA);
        return Array.from(e).map((t) => t[0]);
      }
      function OA(t) {
        t.setNormalizer("background", RA());
        t.setNormalizer("background-color", IA());
        t.setReducer("background", zA());
        t.setStyleRelation("background", ["background-color"]);
      }
      function RA() {
        return (t) => {
          const e = {};
          const n = getShorthandValues(t);
          for (const t of n) {
            if (isRepeat(t)) {
              e.repeat = e.repeat || [];
              e.repeat.push(t);
            } else if (isPosition(t)) {
              e.position = e.position || [];
              e.position.push(t);
            } else if (isAttachment(t)) {
              e.attachment = t;
            } else if (isColor(t)) {
              e.color = t;
            } else if (isURL(t)) {
              e.image = t;
            }
          }
          return { path: "background", value: e };
        };
      }
      function IA() {
        return (t) => ({ path: "background.color", value: t });
      }
      function zA() {
        return (t) => {
          const e = [];
          e.push(["background-color", t.color]);
          return e;
        };
      }
      function FA(t) {
        t.setNormalizer("border", MA());
        t.setNormalizer("border-top", NA("top"));
        t.setNormalizer("border-right", NA("right"));
        t.setNormalizer("border-bottom", NA("bottom"));
        t.setNormalizer("border-left", NA("left"));
        t.setNormalizer("border-color", VA("color"));
        t.setNormalizer("border-width", VA("width"));
        t.setNormalizer("border-style", VA("style"));
        t.setNormalizer("border-top-color", HA("color", "top"));
        t.setNormalizer("border-top-style", HA("style", "top"));
        t.setNormalizer("border-top-width", HA("width", "top"));
        t.setNormalizer("border-right-color", HA("color", "right"));
        t.setNormalizer("border-right-style", HA("style", "right"));
        t.setNormalizer("border-right-width", HA("width", "right"));
        t.setNormalizer("border-bottom-color", HA("color", "bottom"));
        t.setNormalizer("border-bottom-style", HA("style", "bottom"));
        t.setNormalizer("border-bottom-width", HA("width", "bottom"));
        t.setNormalizer("border-left-color", HA("color", "left"));
        t.setNormalizer("border-left-style", HA("style", "left"));
        t.setNormalizer("border-left-width", HA("width", "left"));
        t.setExtractor("border-top", jA("top"));
        t.setExtractor("border-right", jA("right"));
        t.setExtractor("border-bottom", jA("bottom"));
        t.setExtractor("border-left", jA("left"));
        t.setExtractor("border-top-color", "border.color.top");
        t.setExtractor("border-right-color", "border.color.right");
        t.setExtractor("border-bottom-color", "border.color.bottom");
        t.setExtractor("border-left-color", "border.color.left");
        t.setExtractor("border-top-width", "border.width.top");
        t.setExtractor("border-right-width", "border.width.right");
        t.setExtractor("border-bottom-width", "border.width.bottom");
        t.setExtractor("border-left-width", "border.width.left");
        t.setExtractor("border-top-style", "border.style.top");
        t.setExtractor("border-right-style", "border.style.right");
        t.setExtractor("border-bottom-style", "border.style.bottom");
        t.setExtractor("border-left-style", "border.style.left");
        t.setReducer("border-color", getBoxSidesValueReducer("border-color"));
        t.setReducer("border-style", getBoxSidesValueReducer("border-style"));
        t.setReducer("border-width", getBoxSidesValueReducer("border-width"));
        t.setReducer("border-top", GA("top"));
        t.setReducer("border-right", GA("right"));
        t.setReducer("border-bottom", GA("bottom"));
        t.setReducer("border-left", GA("left"));
        t.setReducer("border", WA());
        t.setStyleRelation("border", [
          "border-color",
          "border-style",
          "border-width",
          "border-top",
          "border-right",
          "border-bottom",
          "border-left",
          "border-top-color",
          "border-right-color",
          "border-bottom-color",
          "border-left-color",
          "border-top-style",
          "border-right-style",
          "border-bottom-style",
          "border-left-style",
          "border-top-width",
          "border-right-width",
          "border-bottom-width",
          "border-left-width",
        ]);
        t.setStyleRelation("border-color", [
          "border-top-color",
          "border-right-color",
          "border-bottom-color",
          "border-left-color",
        ]);
        t.setStyleRelation("border-style", [
          "border-top-style",
          "border-right-style",
          "border-bottom-style",
          "border-left-style",
        ]);
        t.setStyleRelation("border-width", [
          "border-top-width",
          "border-right-width",
          "border-bottom-width",
          "border-left-width",
        ]);
        t.setStyleRelation("border-top", [
          "border-top-color",
          "border-top-style",
          "border-top-width",
        ]);
        t.setStyleRelation("border-right", [
          "border-right-color",
          "border-right-style",
          "border-right-width",
        ]);
        t.setStyleRelation("border-bottom", [
          "border-bottom-color",
          "border-bottom-style",
          "border-bottom-width",
        ]);
        t.setStyleRelation("border-left", [
          "border-left-color",
          "border-left-style",
          "border-left-width",
        ]);
      }
      function MA() {
        return (t) => {
          const { color: e, style: n, width: o } = $A(t);
          return {
            path: "border",
            value: {
              color: getBoxSidesValues(e),
              style: getBoxSidesValues(n),
              width: getBoxSidesValues(o),
            },
          };
        };
      }
      function NA(t) {
        return (e) => {
          const { color: n, style: o, width: i } = $A(e);
          const r = {};
          if (n !== undefined) {
            r.color = { [t]: n };
          }
          if (o !== undefined) {
            r.style = { [t]: o };
          }
          if (i !== undefined) {
            r.width = { [t]: i };
          }
          return { path: "border", value: r };
        };
      }
      function VA(t) {
        return (e) => ({ path: "border", value: LA(e, t) });
      }
      function LA(t, e) {
        return { [e]: getBoxSidesValues(t) };
      }
      function HA(t, e) {
        return (n) => ({ path: "border", value: { [t]: { [e]: n } } });
      }
      function jA(t) {
        return (e, n) => {
          if (n.border) {
            return qA(n.border, t);
          }
        };
      }
      function qA(t, e) {
        const n = {};
        if (t.width && t.width[e]) {
          n.width = t.width[e];
        }
        if (t.style && t.style[e]) {
          n.style = t.style[e];
        }
        if (t.color && t.color[e]) {
          n.color = t.color[e];
        }
        return n;
      }
      function $A(t) {
        const e = {};
        const n = getShorthandValues(t);
        for (const t of n) {
          if (isLength(t) || /thin|medium|thick/.test(t)) {
            e.width = t;
          } else if (isLineStyle(t)) {
            e.style = t;
          } else {
            e.color = t;
          }
        }
        return e;
      }
      function WA() {
        return (e) => {
          const n = qA(e, "top");
          const o = qA(e, "right");
          const i = qA(e, "bottom");
          const r = qA(e, "left");
          const s = [n, o, i, r];
          const a = { width: t(s, "width"), style: t(s, "style"), color: t(s, "color") };
          const c = KA(a, "all");
          if (c.length) {
            return c;
          }
          const l = Object.entries(a).reduce((t, [e, n]) => {
            if (n) {
              t.push([`border-${e}`, n]);
              s.forEach((t) => delete t[e]);
            }
            return t;
          }, []);
          return [...l, ...KA(n, "top"), ...KA(o, "right"), ...KA(i, "bottom"), ...KA(r, "left")];
        };
        function t(t, e) {
          return t.map((t) => t[e]).reduce((t, e) => (t == e ? t : null));
        }
      }
      function GA(t) {
        return (e) => KA(e, t);
      }
      function KA(t, e) {
        const n = [];
        if (t && t.width) {
          n.push("width");
        }
        if (t && t.style) {
          n.push("style");
        }
        if (t && t.color) {
          n.push("color");
        }
        if (n.length == 3) {
          const o = n.map((e) => t[e]).join(" ");
          return [e == "all" ? ["border", o] : [`border-${e}`, o]];
        }
        if (e == "all") {
          return [];
        }
        return n.map((n) => [`border-${e}-${n}`, t[n]]);
      }
      function UA(t) {
        t.setNormalizer("margin", getPositionShorthandNormalizer("margin"));
        t.setNormalizer("margin-top", (t) => ({ path: "margin.top", value: t }));
        t.setNormalizer("margin-right", (t) => ({ path: "margin.right", value: t }));
        t.setNormalizer("margin-bottom", (t) => ({ path: "margin.bottom", value: t }));
        t.setNormalizer("margin-left", (t) => ({ path: "margin.left", value: t }));
        t.setReducer("margin", getBoxSidesValueReducer("margin"));
        t.setStyleRelation("margin", [
          "margin-top",
          "margin-right",
          "margin-bottom",
          "margin-left",
        ]);
      }
      function ZA(t) {
        t.setNormalizer("padding", getPositionShorthandNormalizer("padding"));
        t.setNormalizer("padding-top", (t) => ({ path: "padding.top", value: t }));
        t.setNormalizer("padding-right", (t) => ({ path: "padding.right", value: t }));
        t.setNormalizer("padding-bottom", (t) => ({ path: "padding.bottom", value: t }));
        t.setNormalizer("padding-left", (t) => ({ path: "padding.left", value: t }));
        t.setReducer("padding", getBoxSidesValueReducer("padding"));
        t.setStyleRelation("padding", [
          "padding-top",
          "padding-right",
          "padding-bottom",
          "padding-left",
        ]);
      }
      class JA {
        constructor() {
          this._commands = new Map();
        }
        add(t, e) {
          this._commands.set(t, e);
        }
        get(t) {
          return this._commands.get(t);
        }
        execute(t, ...e) {
          const n = this.get(t);
          if (!n) {
            throw new P("commandcollection-command-not-found", this, { commandName: t });
          }
          return n.execute(...e);
        }
        *names() {
          yield* this._commands.keys();
        }
        *commands() {
          yield* this._commands.values();
        }
        [Symbol.iterator]() {
          return this._commands[Symbol.iterator]();
        }
        destroy() {
          for (const t of this.commands()) {
            t.destroy();
          }
        }
      }
      class YA extends ul {
        constructor(t) {
          super();
          this.editor = t;
        }
        set(t, e, n = {}) {
          if (typeof e == "string") {
            const t = e;
            e = (e, n) => {
              this.editor.execute(t);
              n();
            };
          }
          super.set(t, e, n);
        }
      }
      class QA extends lt() {
        constructor(t = {}) {
          super();
          const e = this.constructor;
          const n = t.language || (e.defaultConfig && e.defaultConfig.language);
          this._context = t.context || new cu({ language: n });
          this._context._addEditor(this, !t.context);
          const o = Array.from(e.builtinPlugins || []);
          this.config = new Ha(t, e.defaultConfig);
          this.config.define("plugins", o);
          this.config.define(this._context._getEditorConfig());
          this.plugins = new au(this, o, this._context.plugins);
          this.locale = this._context.locale;
          this.t = this.locale.t;
          this._readOnlyLocks = new Set();
          this.commands = new JA();
          this.set("state", "initializing");
          this.once("ready", () => (this.state = "ready"), { priority: "high" });
          this.once("destroy", () => (this.state = "destroyed"), { priority: "high" });
          this.model = new tA();
          this.on("change:isReadOnly", () => {
            this.model.document.isReadOnly = this.isReadOnly;
          });
          const i = new yp();
          this.data = new f_(this.model, i);
          this.editing = new Mw(this.model, i);
          this.editing.view.document.bind("isReadOnly").to(this);
          this.conversion = new g_(
            [this.editing.downcastDispatcher, this.data.downcastDispatcher],
            this.data.upcastDispatcher
          );
          this.conversion.addAlias("dataDowncast", this.data.downcastDispatcher);
          this.conversion.addAlias("editingDowncast", this.editing.downcastDispatcher);
          this.keystrokes = new YA(this);
          this.keystrokes.listenTo(this.editing.view.document);
        }
        get isReadOnly() {
          return this._readOnlyLocks.size > 0;
        }
        set isReadOnly(t) {
          throw new P("editor-isreadonly-has-no-setter");
        }
        enableReadOnlyMode(t) {
          if (typeof t !== "string" && typeof t !== "symbol") {
            throw new P("editor-read-only-lock-id-invalid", null, { lockId: t });
          }
          if (this._readOnlyLocks.has(t)) {
            return;
          }
          this._readOnlyLocks.add(t);
          if (this._readOnlyLocks.size === 1) {
            this.fire("change:isReadOnly", "isReadOnly", true, false);
          }
        }
        disableReadOnlyMode(t) {
          if (typeof t !== "string" && typeof t !== "symbol") {
            throw new P("editor-read-only-lock-id-invalid", null, { lockId: t });
          }
          if (!this._readOnlyLocks.has(t)) {
            return;
          }
          this._readOnlyLocks.delete(t);
          if (this._readOnlyLocks.size === 0) {
            this.fire("change:isReadOnly", "isReadOnly", false, true);
          }
        }
        initPlugins() {
          const t = this.config;
          const e = t.get("plugins");
          const n = t.get("removePlugins") || [];
          const o = t.get("extraPlugins") || [];
          const i = t.get("substitutePlugins") || [];
          return this.plugins.init(e.concat(o), n, i);
        }
        destroy() {
          let t = Promise.resolve();
          if (this.state == "initializing") {
            t = new Promise((t) => this.once("ready", t));
          }
          return t
            .then(() => {
              this.fire("destroy");
              this.stopListening();
              this.commands.destroy();
            })
            .then(() => this.plugins.destroy())
            .then(() => {
              this.model.destroy();
              this.data.destroy();
              this.editing.destroy();
              this.keystrokes.destroy();
            })
            .then(() => this._context._removeEditor(this));
        }
        execute(t, ...e) {
          try {
            return this.commands.execute(t, ...e);
          } catch (t) {
            P.rethrowUnexpectedError(t, this);
          }
        }
        focus() {
          this.editing.view.focus();
        }
        static create(...t) {
          throw new Error("This is an abstract method.");
        }
      }
      function XA(t) {
        if (!qe(t.updateSourceElement)) {
          throw new P("attachtoform-missing-elementapi-interface", t);
        }
        const e = t.sourceElement;
        if (tC(e) && e.form) {
          let n;
          const o = e.form;
          const i = () => t.updateSourceElement();
          if (qe(o.submit)) {
            n = o.submit;
            o.submit = () => {
              i();
              n.apply(o);
            };
          }
          o.addEventListener("submit", i);
          t.on("destroy", () => {
            o.removeEventListener("submit", i);
            if (n) {
              o.submit = n;
            }
          });
        }
      }
      function tC(t) {
        return !!t && t.tagName.toLowerCase() === "textarea";
      }
      function eC(t) {
        class e extends t {
          setData(t) {
            this.data.set(t);
          }
          getData(t) {
            return this.data.get(t);
          }
        }
        return e;
      }
      {
        const t = eC(Object);
        eC.setData = t.prototype.setData;
        eC.getData = t.prototype.getData;
      }
      function nC(t) {
        class e extends t {
          updateSourceElement(t = this.data.get()) {
            if (!this.sourceElement) {
              throw new P("editor-missing-sourceelement", this);
            }
            const e = this.config.get("updateSourceElementOnDestroy");
            const n = this.sourceElement instanceof HTMLTextAreaElement;
            if (!e && !n) {
              gc(this.sourceElement, "");
              return;
            }
            gc(this.sourceElement, t);
          }
        }
        return e;
      }
      nC.updateSourceElement = nC(Object).prototype.updateSourceElement;
      function oC(t, e) {
        if (e.ckeditorInstance) {
          throw new CKEditorError("editor-source-element-already-used", t);
        }
        e.ckeditorInstance = t;
        t.once("destroy", () => {
          delete e.ckeditorInstance;
        });
      }
      class iC extends lu {
        static get pluginName() {
          return "PendingActions";
        }
        init() {
          this.set("hasAny", false);
          this._actions = new ll({ idProperty: "_id" });
          this._actions.delegate("add", "remove").to(this);
        }
        add(t) {
          if (typeof t !== "string") {
            throw new P("pendingactions-add-invalid-message", this);
          }
          const e = new (lt())();
          e.set("message", t);
          this._actions.add(e);
          this.hasAny = true;
          return e;
        }
        remove(t) {
          this._actions.remove(t);
          this.hasAny = !!this._actions.length;
        }
        get first() {
          return this._actions.get(0);
        }
        [Symbol.iterator]() {
          return this._actions[Symbol.iterator]();
        }
      }
      const rC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.591 10.177 4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>';
      const sC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 16h9a1 1 0 0 1 0 2H2a1 1 0 0 1 0-2z"/><path d="M17 1a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14zm0 1.5H3a.5.5 0 0 0-.492.41L2.5 3v9a.5.5 0 0 0 .41.492L3 12.5h14a.5.5 0 0 0 .492-.41L17.5 12V3a.5.5 0 0 0-.41-.492L17 2.5z" fill-opacity=".6"/></svg>';
      const aC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>';
      const cC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.333 2 .19 2.263a5.899 5.899 0 0 1 1.458.604L14.714 3.4 16.6 5.286l-1.467 1.733c.263.452.468.942.605 1.46L18 8.666v2.666l-2.263.19a5.899 5.899 0 0 1-.604 1.458l1.467 1.733-1.886 1.886-1.733-1.467a5.899 5.899 0 0 1-1.46.605L11.334 18H8.667l-.19-2.263a5.899 5.899 0 0 1-1.458-.604L5.286 16.6 3.4 14.714l1.467-1.733a5.899 5.899 0 0 1-.604-1.458L2 11.333V8.667l2.262-.189a5.899 5.899 0 0 1 .605-1.459L3.4 5.286 5.286 3.4l1.733 1.467a5.899 5.899 0 0 1 1.46-.605L8.666 2h2.666zM10 6.267a3.733 3.733 0 1 0 0 7.466 3.733 3.733 0 0 0 0-7.466z"/></svg>';
      const lC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m8.636 9.531-2.758 3.94a.5.5 0 0 0 .122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 0 1-.491-2.786l6.673-9.53a2 2 0 0 1 2.785-.49l3.742 2.62a2 2 0 0 1 .491 2.785l-7.269 10.053-2.147-.066z"/><path d="M4 18h5.523v-1H4zm-2 0h1v-1H2z"/></svg>';
      const dC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11 1a9 9 0 1 1-8.027 13.075l1.128-1.129A7.502 7.502 0 0 0 18.5 10a7.5 7.5 0 1 0-14.962.759l-.745-.746-.76.76A9 9 0 0 1 11 1z"/><path d="M.475 8.17a.75.75 0 0 1 .978.047l.075.082 1.284 1.643 1.681-1.284a.75.75 0 0 1 .978.057l.073.083a.75.75 0 0 1-.057.978l-.083.073-2.27 1.737a.75.75 0 0 1-.973-.052l-.074-.082-1.741-2.23a.75.75 0 0 1 .13-1.052z"/><path d="M11.5 5v4.999l3.196 3.196-1.06 1.06L10.1 10.72l-.1-.113V5z"/></svg>';
      const hC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.085 6.22 2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.094 11.094 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.488.488 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2c-.043.077-.08.158-.108.241a.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z"/></svg>';
      const uC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.68 13.74h-.001l4.209 4.208a1 1 0 1 0 1.414-1.414l-4.267-4.268a6 6 0 1 0-1.355 1.474ZM13 9a4 4 0 1 1-8 0 4 4 0 0 1 8 0Z"/></svg>';
      const fC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.91 10.54c.26-.23.64-.21.88.03l3.36 3.14 2.23-2.06a.64.64 0 0 1 .87 0l2.52 2.97V4.5H3.2v10.12l3.71-4.08zm10.27-7.51c.6 0 1.09.47 1.09 1.05v11.84c0 .59-.49 1.06-1.09 1.06H2.79c-.6 0-1.09-.47-1.09-1.06V4.08c0-.58.49-1.05 1.1-1.05h14.38zm-5.22 5.56a1.96 1.96 0 1 1 3.4-1.96 1.96 1.96 0 0 1-3.4 1.96z"/></svg>';
      const pC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.239 13.938-2.88-1.663a.75.75 0 0 1 .75-1.3L9 12.067V4.75a.75.75 0 1 1 1.5 0v7.318l1.89-1.093a.75.75 0 0 1 .75 1.3l-2.879 1.663a.752.752 0 0 1-.511.187.752.752 0 0 1-.511-.187zM4.25 17a.75.75 0 1 1 0-1.5h10.5a.75.75 0 0 1 0 1.5H4.25z"/></svg>';
      const gC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.75 11.875a.752.752 0 0 1 .508.184l2.883 1.666a.75.75 0 0 1-.659 1.344l-.091-.044-1.892-1.093.001 4.318a.75.75 0 1 1-1.5 0v-4.317l-1.89 1.092a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .51-.187zM15.25 9a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM9.75.375a.75.75 0 0 1 .75.75v4.318l1.89-1.093.092-.045a.75.75 0 0 1 .659 1.344l-2.883 1.667a.752.752 0 0 1-.508.184.752.752 0 0 1-.511-.187L6.359 5.65a.75.75 0 0 1 .75-1.299L9 5.442V1.125a.75.75 0 0 1 .75-.75z"/></svg>';
      const mC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m10.261 7.062 2.88 1.663a.75.75 0 0 1-.75 1.3L10.5 8.933v7.317a.75.75 0 1 1-1.5 0V8.932l-1.89 1.093a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .511-.187.752.752 0 0 1 .511.187zM15.25 4a.75.75 0 1 1 0 1.5H4.75a.75.75 0 0 1 0-1.5h10.5z"/></svg>';
      const kC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>';
      const bC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm2.286 4c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75z"/></svg>';
      const wC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.75a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 8a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 4a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75zm0-8a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75z"/></svg>';
      const _C =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>';
      const vC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>';
      const AC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M15.003 7v5.5a1 1 0 0 1-1 1H5.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H6.5V12h6.997V7.5z"/></svg>';
      const CC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>';
      const yC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18 7v5.5a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1zm-1.505.5H3.504V12h12.991V7.5z"/></svg>';
      const xC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>';
      const EC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zm0-3H18v1.5h-4.5zm0-3H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>';
      const DC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2zm0-9h5v1.5H2zm0 3h5v1.5H2zm0 3h5v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>';
      const SC =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M18.095 2H1.905C.853 2 0 2.895 0 4v12c0 1.105.853 2 1.905 2h16.19C19.147 18 20 17.105 20 16V4c0-1.105-.853-2-1.905-2zm0 1.5c.263 0 .476.224.476.5v12c0 .276-.213.5-.476.5H1.905a.489.489 0 0 1-.476-.5V4c0-.276.213-.5.476-.5h16.19z"/></svg>';
      const TC =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M13 6H2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5V8a.5.5 0 0 1 .5-.5h11z"/></svg>';
      const PC =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M7 10H2a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h5a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-4a.5.5 0 0 1 .5-.5h5z"/></svg>';
      const BC =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M10 8H2a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-6a.5.5 0 0 1 .5-.5h8z"/></svg>';
      const OC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.3 17.37-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506 13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5 9.375 17H19v1.5H8z"/></svg>';
      const RC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.999 2H15a1 1 0 0 1 0 2h-1.004v13a1 1 0 1 1-2 0V4H8.999v13a1 1 0 1 1-2 0v-7A4 4 0 0 1 3 6a4 4 0 0 1 3.999-4z"/></svg>';
      const IC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>';
      const zC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>';
      const FC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5 3.25a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 3.25a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M5 10a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 10a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M5 16.75a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 16.75a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/></svg>';
      const MC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>';
      const NC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.5 5.5H7v5h3.5a2.5 2.5 0 1 0 0-5zM5 3h6.5v.025a5 5 0 0 1 0 9.95V13H7v4a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z"/></svg>';
      const VC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 0 0-1 1v6H3a1 1 0 1 0 0 2h6v6a1 1 0 1 0 2 0v-6h6a1 1 0 1 0 0-2h-6V3a1 1 0 0 0-1-1Z"/></svg>';
      const LC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555Zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13Z"/><path d="m12.09 17-.534-1.292.848-1.971.545 1.319L12.113 17h-.023Zm1.142-5.187.545 1.319L15.5 9.13l1.858 4.316h-3.45l.398.965h3.467L18.887 17H20l-3.873-9h-1.254l-1.641 3.813Z"/></svg>';
      const HC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M19 4.5 14 0H3v12.673l.868-1.041c.185-.222.4-.402.632-.54V1.5h8v5h5v7.626a2.24 2.24 0 0 1 1.5.822V4.5ZM14 5V2l3.3 3H14Zm-3.692 12.5c.062.105.133.206.213.303L11.52 19H8v-.876a2.243 2.243 0 0 0 1.82-.624h.488Zm7.518-.657a.75.75 0 0 0-1.152-.96L15.5 17.29V12H14v5.29l-1.174-1.408a.75.75 0 0 0-1.152.96l2.346 2.816a.95.95 0 0 0 1.46 0l2.346-2.815Zm-15.056-.38a.75.75 0 0 1-.096-1.056l2.346-2.815a.95.95 0 0 1 1.46 0l2.346 2.815a.75.75 0 1 1-1.152.96L6.5 14.96V20H5v-5.04l-1.174 1.408a.75.75 0 0 1-1.056.096Z"/></svg>';
      const jC = {
        bold: MC,
        cancel: rC,
        caption: sC,
        check: aC,
        cog: cC,
        eraser: lC,
        history: dC,
        image: fC,
        lowVision: hC,
        loupe: uC,
        importExport: HC,
        paragraph: NC,
        plus: VC,
        text: LC,
        alignBottom: pC,
        alignMiddle: gC,
        alignTop: mC,
        alignLeft: kC,
        alignCenter: bC,
        alignRight: wC,
        alignJustify: _C,
        objectLeft: EC,
        objectCenter: AC,
        objectRight: DC,
        objectFullWidth: yC,
        objectInline: xC,
        objectBlockLeft: vC,
        objectBlockRight: CC,
        objectSizeFull: SC,
        objectSizeLarge: TC,
        objectSizeSmall: PC,
        objectSizeMedium: BC,
        pencil: OC,
        pilcrow: RC,
        quote: IC,
        threeVerticalDots: zC,
        dragIndicator: FC,
      };
      var qC = n(768);
      var $C = { injectType: "singletonStyleTag", attributes: { "data-cke": true } };
      $C.insert = "head";
      $C.singleton = true;
      var WC = Pl()(qC.Z, $C);
      const GC = qC.Z.locals || {};
      const { threeVerticalDots: KC } = jC;
      const UC = {
        alignLeft: jC.alignLeft,
        bold: jC.bold,
        importExport: jC.importExport,
        paragraph: jC.paragraph,
        plus: jC.plus,
        text: jC.text,
        threeVerticalDots: jC.threeVerticalDots,
        pilcrow: jC.pilcrow,
        dragIndicator: jC.dragIndicator,
      };
      class ZC extends zl {
        constructor(t, e) {
          super(t);
          const n = this.bindTemplate;
          const o = this.t;
          this.options = e || {};
          this.set("ariaLabel", o("Editor toolbar"));
          this.set("maxWidth", "auto");
          this.items = this.createCollection();
          this.focusTracker = new hl();
          this.keystrokes = new ul();
          this.set("class", undefined);
          this.set("isCompact", false);
          this.itemsView = new JC(t);
          this.children = this.createCollection();
          this.children.add(this.itemsView);
          this.focusables = this.createCollection();
          const i = t.uiLanguageDirection === "rtl";
          this._focusCycler = new Jh({
            focusables: this.focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: {
              focusPrevious: [i ? "arrowright" : "arrowleft", "arrowup"],
              focusNext: [i ? "arrowleft" : "arrowright", "arrowdown"],
            },
          });
          const r = ["ck", "ck-toolbar", n.to("class"), n.if("isCompact", "ck-toolbar_compact")];
          if (this.options.shouldGroupWhenFull && this.options.isFloating) {
            r.push("ck-toolbar_floating");
          }
          this.setTemplate({
            tag: "div",
            attributes: {
              class: r,
              role: "toolbar",
              "aria-label": n.to("ariaLabel"),
              style: { maxWidth: n.to("maxWidth") },
              tabindex: -1,
            },
            children: this.children,
            on: { mousedown: tu(this) },
          });
          this._behavior = this.options.shouldGroupWhenFull ? new QC(this) : new YC(this);
        }
        render() {
          super.render();
          this.focusTracker.add(this.element);
          for (const t of this.items) {
            this.focusTracker.add(t.element);
          }
          this.items.on("add", (t, e) => {
            this.focusTracker.add(e.element);
          });
          this.items.on("remove", (t, e) => {
            this.focusTracker.remove(e.element);
          });
          this.keystrokes.listenTo(this.element);
          this._behavior.render(this);
        }
        destroy() {
          this._behavior.destroy();
          this.focusTracker.destroy();
          this.keystrokes.destroy();
          return super.destroy();
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        focusLast() {
          this._focusCycler.focusLast();
        }
        fillFromConfig(t, e, n) {
          this.items.addMany(this._buildItemsFromConfig(t, e, n));
        }
        _buildItemsFromConfig(t, e, n) {
          const o = eu(t);
          const i = n || o.removeItems;
          const r = this._cleanItemsConfiguration(o.items, e, i)
            .map((t) => {
              if (nt(t)) {
                return this._createNestedToolbarDropdown(t, e, i);
              } else if (t === "|") {
                return new Qh();
              } else if (t === "-") {
                return new Xh();
              }
              return e.create(t);
            })
            .filter((t) => !!t);
          return r;
        }
        _cleanItemsConfiguration(t, e, n) {
          const o = t.filter((t, o, i) => {
            if (t === "|") {
              return true;
            }
            if (n.indexOf(t) !== -1) {
              return false;
            }
            if (t === "-") {
              if (this.options.shouldGroupWhenFull) {
                B("toolbarview-line-break-ignored-when-grouping-items", i);
                return false;
              }
              return true;
            }
            if (!nt(t) && !e.has(t)) {
              B("toolbarview-item-unavailable", { item: t });
              return false;
            }
            return true;
          });
          return this._cleanSeparatorsAndLineBreaks(o);
        }
        _cleanSeparatorsAndLineBreaks(t) {
          const e = (t) => t !== "-" && t !== "|";
          const n = t.length;
          const o = t.findIndex(e);
          if (o === -1) {
            return [];
          }
          const i = n - t.slice().reverse().findIndex(e);
          return t.slice(o, i).filter((t, n, o) => {
            if (e(t)) {
              return true;
            }
            const i = n > 0 && o[n - 1] === t;
            return !i;
          });
        }
        _createNestedToolbarDropdown(t, e, n) {
          let { label: o, icon: i, items: r, tooltip: s = true, withText: a = false } = t;
          r = this._cleanItemsConfiguration(r, e, n);
          if (!r.length) {
            return null;
          }
          const c = this.locale;
          const l = vy(c);
          if (!o) {
            B("toolbarview-nested-toolbar-dropdown-missing-label", t);
          }
          l.class = "ck-toolbar__nested-toolbar-dropdown";
          l.buttonView.set({ label: o, tooltip: s, withText: !!a });
          if (i !== false) {
            l.buttonView.icon = UC[i] || i || KC;
          } else {
            l.buttonView.withText = true;
          }
          Ay(l, () => l.toolbarView._buildItemsFromConfig(r, e, n));
          return l;
        }
      }
      class JC extends zl {
        constructor(t) {
          super(t);
          this.children = this.createCollection();
          this.setTemplate({
            tag: "div",
            attributes: { class: ["ck", "ck-toolbar__items"] },
            children: this.children,
          });
        }
      }
      class YC {
        constructor(t) {
          const e = t.bindTemplate;
          t.set("isVertical", false);
          t.itemsView.children.bindTo(t.items).using((t) => t);
          t.focusables.bindTo(t.items).using((t) => t);
          t.extendTemplate({ attributes: { class: [e.if("isVertical", "ck-toolbar_vertical")] } });
        }
        render() {}
        destroy() {}
      }
      class QC {
        constructor(t) {
          this.resizeObserver = null;
          this.cachedPadding = null;
          this.shouldUpdateGroupingOnNextResize = false;
          this.view = t;
          this.viewChildren = t.children;
          this.viewFocusables = t.focusables;
          this.viewItemsView = t.itemsView;
          this.viewFocusTracker = t.focusTracker;
          this.viewLocale = t.locale;
          this.ungroupedItems = t.createCollection();
          this.groupedItems = t.createCollection();
          this.groupedItemsDropdown = this._createGroupedItemsDropdown();
          t.itemsView.children.bindTo(this.ungroupedItems).using((t) => t);
          this.ungroupedItems.on("change", this._updateFocusCycleableItems.bind(this));
          t.children.on("change", this._updateFocusCycleableItems.bind(this));
          t.items.on("change", (t, e) => {
            const n = e.index;
            const o = Array.from(e.added);
            for (const t of e.removed) {
              if (n >= this.ungroupedItems.length) {
                this.groupedItems.remove(t);
              } else {
                this.ungroupedItems.remove(t);
              }
            }
            for (let t = n; t < n + o.length; t++) {
              const e = o[t - n];
              if (t > this.ungroupedItems.length) {
                this.groupedItems.add(e, t - this.ungroupedItems.length);
              } else {
                this.ungroupedItems.add(e, t);
              }
            }
            this._updateGrouping();
          });
          t.extendTemplate({ attributes: { class: ["ck-toolbar_grouping"] } });
        }
        render(t) {
          this.viewElement = t.element;
          this._enableGroupingOnResize();
          this._enableGroupingOnMaxWidthChange(t);
        }
        destroy() {
          this.groupedItemsDropdown.destroy();
          this.resizeObserver.destroy();
        }
        _updateGrouping() {
          if (!this.viewElement.ownerDocument.body.contains(this.viewElement)) {
            return;
          }
          if (!vc(this.viewElement)) {
            this.shouldUpdateGroupingOnNextResize = true;
            return;
          }
          const t = this.groupedItems.length;
          let e;
          while (this._areItemsOverflowing) {
            this._groupLastItem();
            e = true;
          }
          if (!e && this.groupedItems.length) {
            while (this.groupedItems.length && !this._areItemsOverflowing) {
              this._ungroupFirstItem();
            }
            if (this._areItemsOverflowing) {
              this._groupLastItem();
            }
          }
          if (this.groupedItems.length !== t) {
            this.view.fire("groupedItemsUpdate");
          }
        }
        get _areItemsOverflowing() {
          if (!this.ungroupedItems.length) {
            return false;
          }
          const t = this.viewElement;
          const e = this.viewLocale.uiLanguageDirection;
          const n = new ac(t.lastChild);
          const o = new ac(t);
          if (!this.cachedPadding) {
            const n = Qa.window.getComputedStyle(t);
            const o = e === "ltr" ? "paddingRight" : "paddingLeft";
            this.cachedPadding = Number.parseInt(n[o]);
          }
          if (e === "ltr") {
            return n.right > o.right - this.cachedPadding;
          } else {
            return n.left < o.left + this.cachedPadding;
          }
        }
        _enableGroupingOnResize() {
          let t;
          this.resizeObserver = new pc(this.viewElement, (e) => {
            if (!t || t !== e.contentRect.width || this.shouldUpdateGroupingOnNextResize) {
              this.shouldUpdateGroupingOnNextResize = false;
              this._updateGrouping();
              t = e.contentRect.width;
            }
          });
          this._updateGrouping();
        }
        _enableGroupingOnMaxWidthChange(t) {
          t.on("change:maxWidth", () => {
            this._updateGrouping();
          });
        }
        _groupLastItem() {
          if (!this.groupedItems.length) {
            this.viewChildren.add(new Qh());
            this.viewChildren.add(this.groupedItemsDropdown);
            this.viewFocusTracker.add(this.groupedItemsDropdown.element);
          }
          this.groupedItems.add(this.ungroupedItems.remove(this.ungroupedItems.last), 0);
        }
        _ungroupFirstItem() {
          this.ungroupedItems.add(this.groupedItems.remove(this.groupedItems.first));
          if (!this.groupedItems.length) {
            this.viewChildren.remove(this.groupedItemsDropdown);
            this.viewChildren.remove(this.viewChildren.last);
            this.viewFocusTracker.remove(this.groupedItemsDropdown.element);
          }
        }
        _createGroupedItemsDropdown() {
          const t = this.viewLocale;
          const e = t.t;
          const n = vy(t);
          n.class = "ck-toolbar__grouped-dropdown";
          n.panelPosition = t.uiLanguageDirection === "ltr" ? "sw" : "se";
          Ay(n, this.groupedItems);
          n.buttonView.set({
            label: e("Show more items"),
            tooltip: true,
            tooltipPosition: t.uiLanguageDirection === "rtl" ? "se" : "sw",
            icon: KC,
          });
          return n;
        }
        _updateFocusCycleableItems() {
          this.viewFocusables.clear();
          this.ungroupedItems.map((t) => {
            this.viewFocusables.add(t);
          });
          if (this.groupedItems.length) {
            this.viewFocusables.add(this.groupedItemsDropdown);
          }
        }
      }
      class XC extends zl {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          const n = `ck-editor__label_${x()}`;
          const o = new iy(t);
          this.children = this.createCollection();
          this.children.addMany([this._createLabel(n), o]);
          this.set({ label: "", isVisible: true });
          o.set({ role: "group", ariaLabelledBy: n });
          o.focusTracker.destroy();
          o.keystrokes.destroy();
          this.items = o.items;
          this.setTemplate({
            tag: "li",
            attributes: {
              role: "presentation",
              class: ["ck", "ck-list__group", e.if("isVisible", "ck-hidden", (t) => !t)],
            },
            children: this.children,
          });
        }
        _createLabel(t) {
          const e = new zl(this.locale);
          const n = this.bindTemplate;
          e.setTemplate({
            tag: "span",
            attributes: { id: t },
            children: [{ text: n.to("label") }],
          });
          return e;
        }
        focus() {
          if (this.items.first) {
            this.items.first.focus();
          }
        }
      }
      var ty = n(179);
      var ey = { injectType: "singletonStyleTag", attributes: { "data-cke": true } };
      ey.insert = "head";
      ey.singleton = true;
      var ny = Pl()(ty.Z, ey);
      const oy = ty.Z.locals || {};
      class iy extends zl {
        constructor(t) {
          super(t);
          this._listItemGroupToChangeListeners = new WeakMap();
          const e = this.bindTemplate;
          this.focusables = new Dl();
          this.items = this.createCollection();
          this.focusTracker = new hl();
          this.keystrokes = new ul();
          this._focusCycler = new Jh({
            focusables: this.focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: { focusPrevious: "arrowup", focusNext: "arrowdown" },
          });
          this.set("ariaLabel", undefined);
          this.set("ariaLabelledBy", undefined);
          this.set("role", undefined);
          this.setTemplate({
            tag: "ul",
            attributes: {
              class: ["ck", "ck-reset", "ck-list"],
              role: e.to("role"),
              "aria-label": e.to("ariaLabel"),
              "aria-labelledby": e.to("ariaLabelledBy"),
            },
            children: this.items,
          });
        }
        render() {
          super.render();
          for (const t of this.items) {
            if (t instanceof XC) {
              this._registerFocusableItemsGroup(t);
            } else {
              this._registerFocusableListItem(t);
            }
          }
          this.items.on("change", (t, e) => {
            for (const t of e.removed) {
              if (t instanceof XC) {
                this._deregisterFocusableItemsGroup(t);
              } else {
                this._deregisterFocusableListItem(t);
              }
            }
            for (const t of Array.from(e.added).reverse()) {
              if (t instanceof XC) {
                this._registerFocusableItemsGroup(t, e.index);
              } else {
                this._registerFocusableListItem(t, e.index);
              }
            }
          });
          this.keystrokes.listenTo(this.element);
        }
        destroy() {
          super.destroy();
          this.focusTracker.destroy();
          this.keystrokes.destroy();
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        focusFirst() {
          this._focusCycler.focusFirst();
        }
        focusLast() {
          this._focusCycler.focusLast();
        }
        _registerFocusableListItem(t, e) {
          this.focusTracker.add(t.element);
          this.focusables.add(t, e);
        }
        _deregisterFocusableListItem(t) {
          this.focusTracker.remove(t.element);
          this.focusables.remove(t);
        }
        _getOnGroupItemsChangeCallback(t) {
          return (e, n) => {
            for (const t of n.removed) {
              this._deregisterFocusableListItem(t);
            }
            for (const e of Array.from(n.added).reverse()) {
              this._registerFocusableListItem(e, this.items.getIndex(t) + n.index);
            }
          };
        }
        _registerFocusableItemsGroup(t, e) {
          Array.from(t.items).forEach((t, n) => {
            const o = typeof e !== "undefined" ? e + n : undefined;
            this._registerFocusableListItem(t, o);
          });
          const n = this._getOnGroupItemsChangeCallback(t);
          this._listItemGroupToChangeListeners.set(t, n);
          t.items.on("change", n);
        }
        _deregisterFocusableItemsGroup(t) {
          for (const e of t.items) {
            this._deregisterFocusableListItem(e);
          }
          t.items.off("change", this._listItemGroupToChangeListeners.get(t));
          this._listItemGroupToChangeListeners.delete(t);
        }
      }
      class ry extends zl {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          this.set("isVisible", true);
          this.children = this.createCollection();
          this.setTemplate({
            tag: "li",
            attributes: {
              class: ["ck", "ck-list__item", e.if("isVisible", "ck-hidden", (t) => !t)],
              role: "presentation",
            },
            children: this.children,
          });
        }
        focus() {
          if (this.children.first) {
            this.children.first.focus();
          }
        }
      }
      class sy extends zl {
        constructor(t) {
          super(t);
          this.setTemplate({ tag: "li", attributes: { class: ["ck", "ck-list__separator"] } });
        }
      }
      var ay = n(791);
      var cy = { injectType: "singletonStyleTag", attributes: { "data-cke": true } };
      cy.insert = "head";
      cy.singleton = true;
      var ly = Pl()(ay.Z, cy);
      const dy = ay.Z.locals || {};
      class hy extends zl {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          this.set("class", undefined);
          this.set("labelStyle", undefined);
          this.set("icon", undefined);
          this.set("isEnabled", true);
          this.set("isOn", false);
          this.set("isToggleable", false);
          this.set("isVisible", true);
          this.set("keystroke", undefined);
          this.set("withKeystroke", false);
          this.set("label", undefined);
          this.set("tabindex", -1);
          this.set("tooltip", false);
          this.set("tooltipPosition", "s");
          this.set("type", "button");
          this.set("withText", false);
          this.children = this.createCollection();
          this.actionView = this._createActionView();
          this.arrowView = this._createArrowView();
          this.keystrokes = new ul();
          this.focusTracker = new hl();
          this.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-splitbutton",
                e.to("class"),
                e.if("isVisible", "ck-hidden", (t) => !t),
                this.arrowView.bindTemplate.if("isOn", "ck-splitbutton_open"),
              ],
            },
            children: this.children,
          });
        }
        render() {
          super.render();
          this.children.add(this.actionView);
          this.children.add(this.arrowView);
          this.focusTracker.add(this.actionView.element);
          this.focusTracker.add(this.arrowView.element);
          this.keystrokes.listenTo(this.element);
          this.keystrokes.set("arrowright", (t, e) => {
            if (this.focusTracker.focusedElement === this.actionView.element) {
              this.arrowView.focus();
              e();
            }
          });
          this.keystrokes.set("arrowleft", (t, e) => {
            if (this.focusTracker.focusedElement === this.arrowView.element) {
              this.actionView.focus();
              e();
            }
          });
        }
        destroy() {
          super.destroy();
          this.focusTracker.destroy();
          this.keystrokes.destroy();
        }
        focus() {
          this.actionView.focus();
        }
        _createActionView() {
          const t = new vd();
          t.bind(
            "icon",
            "isEnabled",
            "isOn",
            "isToggleable",
            "keystroke",
            "label",
            "tabindex",
            "tooltip",
            "tooltipPosition",
            "type",
            "withText"
          ).to(this);
          t.extendTemplate({ attributes: { class: "ck-splitbutton__action" } });
          t.delegate("execute").to(this);
          return t;
        }
        _createArrowView() {
          const t = new vd();
          const e = t.bindTemplate;
          t.icon = Uh;
          t.extendTemplate({
            attributes: {
              class: ["ck-splitbutton__arrow"],
              "data-cke-tooltip-disabled": e.to("isOn"),
              "aria-haspopup": true,
              "aria-expanded": e.to("isOn", (t) => String(t)),
            },
          });
          t.bind("isEnabled").to(this);
          t.bind("label").to(this);
          t.bind("tooltip").to(this);
          t.delegate("execute").to(this, "open");
          return t;
        }
      }
      function uy({ emitter: t, activator: e, callback: n, contextElements: o }) {
        t.listenTo(document, "mousedown", (t, i) => {
          if (!e()) {
            return;
          }
          const r = typeof i.composedPath == "function" ? i.composedPath() : [];
          const s = typeof o == "function" ? o() : o;
          for (const t of s) {
            if (t.contains(i.target) || r.includes(t)) {
              return;
            }
          }
          n();
        });
      }
      var fy = n(704);
      var py = { injectType: "singletonStyleTag", attributes: { "data-cke": true } };
      py.insert = "head";
      py.singleton = true;
      var gy = Pl()(fy.Z, py);
      const my = fy.Z.locals || {};
      var ky = n(883);
      var by = { injectType: "singletonStyleTag", attributes: { "data-cke": true } };
      by.insert = "head";
      by.singleton = true;
      var wy = Pl()(ky.Z, by);
      const _y = ky.Z.locals || {};
      function vy(t, e = Zh) {
        const n = new e(t);
        const o = new jh(t);
        const i = new Kh(t, n, o);
        n.bind("isEnabled").to(i);
        if (n instanceof hy) {
          n.arrowView.bind("isOn").to(i, "isOpen");
        } else {
          n.bind("isOn").to(i, "isOpen");
        }
        Dy(i);
        return i;
      }
      function Ay(t, e, n = {}) {
        t.extendTemplate({ attributes: { class: ["ck-toolbar-dropdown"] } });
        if (t.isOpen) {
          Cy(t, e, n);
        } else {
          t.once("change:isOpen", () => Cy(t, e, n), { priority: "highest" });
        }
        if (n.enableActiveItemFocusOnDropdownOpen) {
          Ey(t, () => t.toolbarView.items.find((t) => t.isOn));
        }
      }
      function Cy(t, e, n) {
        const o = t.locale;
        const i = o.t;
        const r = (t.toolbarView = new ZC(o));
        const s = typeof e == "function" ? e() : e;
        r.ariaLabel = n.ariaLabel || i("Dropdown toolbar");
        if (n.maxWidth) {
          r.maxWidth = n.maxWidth;
        }
        if (n.class) {
          r.class = n.class;
        }
        if (n.isCompact) {
          r.isCompact = n.isCompact;
        }
        if (n.isVertical) {
          r.isVertical = true;
        }
        if (s instanceof Dl) {
          r.items.bindTo(s).using((t) => t);
        } else {
          r.items.addMany(s);
        }
        t.panelView.children.add(r);
        r.items.delegate("execute").to(t);
      }
      function yy(t, e, n = {}) {
        if (t.isOpen) {
          xy(t, e, n);
        } else {
          t.once("change:isOpen", () => xy(t, e, n), { priority: "highest" });
        }
        Ey(t, () =>
          t.listView.items.find((t) => {
            if (t instanceof ry) {
              return t.children.first.isOn;
            }
            return false;
          })
        );
      }
      function xy(t, e, n) {
        const o = t.locale;
        const i = (t.listView = new iy(o));
        const r = typeof e == "function" ? e() : e;
        i.ariaLabel = n.ariaLabel;
        i.role = n.role;
        Iy(t, i.items, r, o);
        t.panelView.children.add(i);
        i.items.delegate("execute").to(t);
      }
      function Ey(t, e) {
        t.on(
          "change:isOpen",
          () => {
            if (!t.isOpen) {
              return;
            }
            const n = e();
            if (!n) {
              return;
            }
            if (typeof n.focus === "function") {
              n.focus();
            } else {
              B("ui-dropdown-focus-child-on-open-child-missing-focus", { view: n });
            }
          },
          { priority: D.low - 10 }
        );
      }
      function Dy(t) {
        Sy(t);
        Ty(t);
        Py(t);
        By(t);
        Oy(t);
        Ry(t);
      }
      function Sy(t) {
        t.on("render", () => {
          uy({
            emitter: t,
            activator: () => t.isOpen,
            callback: () => {
              t.isOpen = false;
            },
            contextElements: () => [t.element, ...t.focusTracker._elements],
          });
        });
      }
      function Ty(t) {
        t.on("execute", (e) => {
          if (e.source instanceof Ed) {
            return;
          }
          t.isOpen = false;
        });
      }
      function Py(t) {
        t.focusTracker.on("change:isFocused", (e, n, o) => {
          if (t.isOpen && !o) {
            t.isOpen = false;
          }
        });
      }
      function By(t) {
        t.keystrokes.set("arrowdown", (e, n) => {
          if (t.isOpen) {
            t.panelView.focus();
            n();
          }
        });
        t.keystrokes.set("arrowup", (e, n) => {
          if (t.isOpen) {
            t.panelView.focusLast();
            n();
          }
        });
      }
      function Oy(t) {
        t.on("change:isOpen", (e, n, o) => {
          if (o) {
            return;
          }
          const i = t.panelView.element;
          if (i && i.contains(Qa.document.activeElement)) {
            t.buttonView.focus();
          }
        });
      }
      function Ry(t) {
        t.on(
          "change:isOpen",
          (e, n, o) => {
            if (!o) {
              return;
            }
            t.panelView.focus();
          },
          { priority: "low" }
        );
      }
      function Iy(t, e, n, o) {
        e.bindTo(n).using((e) => {
          if (e.type === "separator") {
            return new sy(o);
          } else if (e.type === "group") {
            const n = new XC(o);
            n.set({ label: e.label });
            Iy(t, n.items, e.items, o);
            n.items.delegate("execute").to(t);
            return n;
          } else if (e.type === "button" || e.type === "switchbutton") {
            const t = new ry(o);
            let n;
            if (e.type === "button") {
              n = new vd(o);
            } else {
              n = new Ed(o);
            }
            n.bind(...Object.keys(e.model)).to(e.model);
            n.delegate("execute").to(t);
            t.children.add(n);
            return t;
          }
          return null;
        });
      }
      const zy = (t, e, n) => {
        const o = new Ih(t.locale);
        o.set({ id: e, ariaDescribedById: n });
        o.bind("isReadOnly").to(t, "isEnabled", (t) => !t);
        o.bind("hasError").to(t, "errorText", (t) => !!t);
        o.on("input", () => {
          t.errorText = null;
        });
        t.bind("isEmpty", "isFocused", "placeholder").to(o);
        return o;
      };
      const Fy = (t, e, n) => {
        const o = new InputNumberView(t.locale);
        o.set({ id: e, ariaDescribedById: n, inputMode: "numeric" });
        o.bind("isReadOnly").to(t, "isEnabled", (t) => !t);
        o.bind("hasError").to(t, "errorText", (t) => !!t);
        o.on("input", () => {
          t.errorText = null;
        });
        t.bind("isEmpty", "isFocused", "placeholder").to(o);
        return o;
      };
      const My = (t, e, n) => {
        const o = new TextareaView(t.locale);
        o.set({ id: e, ariaDescribedById: n });
        o.bind("isReadOnly").to(t, "isEnabled", (t) => !t);
        o.bind("hasError").to(t, "errorText", (t) => !!t);
        o.on("input", () => {
          t.errorText = null;
        });
        t.bind("isEmpty", "isFocused", "placeholder").to(o);
        return o;
      };
      const Ny = (t, e, n) => {
        const o = createDropdown(t.locale);
        o.set({ id: e, ariaDescribedById: n });
        o.bind("isEnabled").to(t);
        return o;
      };
      const Vy = (t, e = 0, n = 1) => (t > n ? n : t < e ? e : t);
      const Ly = (t, e = 0, n = Math.pow(10, e)) => Math.round(n * t) / n;
      const Hy = { grad: 360 / 400, turn: 360, rad: 360 / (Math.PI * 2) };
      const jy = (t) => lx(qy(t));
      const qy = (t) => {
        if (t[0] === "#") t = t.substring(1);
        if (t.length < 6) {
          return {
            r: parseInt(t[0] + t[0], 16),
            g: parseInt(t[1] + t[1], 16),
            b: parseInt(t[2] + t[2], 16),
            a: t.length === 4 ? Ly(parseInt(t[3] + t[3], 16) / 255, 2) : 1,
          };
        }
        return {
          r: parseInt(t.substring(0, 2), 16),
          g: parseInt(t.substring(2, 4), 16),
          b: parseInt(t.substring(4, 6), 16),
          a: t.length === 8 ? Ly(parseInt(t.substring(6, 8), 16) / 255, 2) : 1,
        };
      };
      const $y = (t, e = "deg") => Number(t) * (Hy[e] || 1);
      const Wy = (t) => {
        const e =
          /hsla?\(?\s*(-?\d*\.?\d+)(deg|rad|grad|turn)?[,\s]+(-?\d*\.?\d+)%?[,\s]+(-?\d*\.?\d+)%?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i;
        const n = e.exec(t);
        if (!n) return { h: 0, s: 0, v: 0, a: 1 };
        return Ky({
          h: $y(n[1], n[2]),
          s: Number(n[3]),
          l: Number(n[4]),
          a: n[5] === undefined ? 1 : Number(n[5]) / (n[6] ? 100 : 1),
        });
      };
      const Gy = null && Wy;
      const Ky = ({ h: t, s: e, l: n, a: o }) => {
        e *= (n < 50 ? n : 100 - n) / 100;
        return { h: t, s: e > 0 ? ((2 * e) / (n + e)) * 100 : 0, v: n + e, a: o };
      };
      const Uy = (t) => cx(tx(t));
      const Zy = ({ h: t, s: e, v: n, a: o }) => {
        const i = ((200 - e) * n) / 100;
        return {
          h: Ly(t),
          s: Ly(i > 0 && i < 200 ? ((e * n) / 100 / (i <= 100 ? i : 200 - i)) * 100 : 0),
          l: Ly(i / 2),
          a: Ly(o, 2),
        };
      };
      const Jy = (t) => {
        const { h: e, s: n, v: o } = dx(t);
        return `hsv(${e}, ${n}%, ${o}%)`;
      };
      const Yy = (t) => {
        const { h: e, s: n, v: o, a: i } = dx(t);
        return `hsva(${e}, ${n}%, ${o}%, ${i})`;
      };
      const Qy = (t) => {
        const { h: e, s: n, l: o } = Zy(t);
        return `hsl(${e}, ${n}%, ${o}%)`;
      };
      const Xy = (t) => {
        const { h: e, s: n, l: o, a: i } = Zy(t);
        return `hsla(${e}, ${n}%, ${o}%, ${i})`;
      };
      const tx = ({ h: t, s: e, v: n, a: o }) => {
        t = (t / 360) * 6;
        e = e / 100;
        n = n / 100;
        const i = Math.floor(t),
          r = n * (1 - e),
          s = n * (1 - (t - i) * e),
          a = n * (1 - (1 - t + i) * e),
          c = i % 6;
        return {
          r: Ly([n, s, r, r, a, n][c] * 255),
          g: Ly([a, n, n, s, r, r][c] * 255),
          b: Ly([r, r, a, n, n, s][c] * 255),
          a: Ly(o, 2),
        };
      };
      const ex = (t) => {
        const { r: e, g: n, b: o } = tx(t);
        return `rgb(${e}, ${n}, ${o})`;
      };
      const nx = (t) => {
        const { r: e, g: n, b: o, a: i } = tx(t);
        return `rgba(${e}, ${n}, ${o}, ${i})`;
      };
      const ox = (t) => {
        const e =
          /hsva?\(?\s*(-?\d*\.?\d+)(deg|rad|grad|turn)?[,\s]+(-?\d*\.?\d+)%?[,\s]+(-?\d*\.?\d+)%?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i;
        const n = e.exec(t);
        if (!n) return { h: 0, s: 0, v: 0, a: 1 };
        return dx({
          h: $y(n[1], n[2]),
          s: Number(n[3]),
          v: Number(n[4]),
          a: n[5] === undefined ? 1 : Number(n[5]) / (n[6] ? 100 : 1),
        });
      };
      const ix = null && ox;
      const rx = (t) => {
        const e =
          /rgba?\(?\s*(-?\d*\.?\d+)(%)?[,\s]+(-?\d*\.?\d+)(%)?[,\s]+(-?\d*\.?\d+)(%)?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i;
        const n = e.exec(t);
        if (!n) return { h: 0, s: 0, v: 0, a: 1 };
        return lx({
          r: Number(n[1]) / (n[2] ? 100 / 255 : 1),
          g: Number(n[3]) / (n[4] ? 100 / 255 : 1),
          b: Number(n[5]) / (n[6] ? 100 / 255 : 1),
          a: n[7] === undefined ? 1 : Number(n[7]) / (n[8] ? 100 : 1),
        });
      };
      const sx = null && rx;
      const ax = (t) => {
        const e = t.toString(16);
        return e.length < 2 ? "0" + e : e;
      };
      const cx = ({ r: t, g: e, b: n, a: o }) => {
        const i = o < 1 ? ax(Ly(o * 255)) : "";
        return "#" + ax(t) + ax(e) + ax(n) + i;
      };
      const lx = ({ r: t, g: e, b: n, a: o }) => {
        const i = Math.max(t, e, n);
        const r = i - Math.min(t, e, n);
        const s = r ? (i === t ? (e - n) / r : i === e ? 2 + (n - t) / r : 4 + (t - e) / r) : 0;
        return {
          h: Ly(60 * (s < 0 ? s + 6 : s)),
          s: Ly(i ? (r / i) * 100 : 0),
          v: Ly((i / 255) * 100),
          a: o,
        };
      };
      const dx = (t) => ({ h: round(t.h), s: round(t.s), v: round(t.v), a: round(t.a, 2) });
      const hx = ({ r: t, g: e, b: n }) => ({ r: t, g: e, b: n });
      const ux = ({ h: t, s: e, l: n }) => ({ h: t, s: e, l: n });
      const fx = (t) => {
        const { h: e, s: n, v: o } = dx(t);
        return { h: e, s: n, v: o };
      };
      const px = (t, e) => {
        if (t === e) return true;
        for (const n in t) {
          if (t[n] !== e[n]) return false;
        }
        return true;
      };
      const gx = (t, e) => t.replace(/\s/g, "") === e.replace(/\s/g, "");
      const mx = (t, e) => {
        if (t.toLowerCase() === e.toLowerCase()) return true;
        return px(qy(t), qy(e));
      };
      const kx = {};
      const bx = (t) => {
        let e = kx[t];
        if (!e) {
          e = document.createElement("template");
          e.innerHTML = t;
          kx[t] = e;
        }
        return e;
      };
      const wx = (t, e, n) => {
        t.dispatchEvent(new CustomEvent(e, { bubbles: true, detail: n }));
      };
      let _x = false;
      const vx = (t) => "touches" in t;
      const Ax = (t) => {
        if (_x && !vx(t)) return false;
        if (!_x) _x = vx(t);
        return true;
      };
      const Cx = (t, e) => {
        const n = vx(e) ? e.touches[0] : e;
        const o = t.el.getBoundingClientRect();
        wx(
          t.el,
          "move",
          t.getMove({
            x: Vy((n.pageX - (o.left + window.pageXOffset)) / o.width),
            y: Vy((n.pageY - (o.top + window.pageYOffset)) / o.height),
          })
        );
      };
      const yx = (t, e) => {
        const n = e.keyCode;
        if (n > 40 || (t.xy && n < 37) || n < 33) return;
        e.preventDefault();
        wx(
          t.el,
          "move",
          t.getMove(
            {
              x:
                n === 39
                  ? 0.01
                  : n === 37
                  ? -0.01
                  : n === 34
                  ? 0.05
                  : n === 33
                  ? -0.05
                  : n === 35
                  ? 1
                  : n === 36
                  ? -1
                  : 0,
              y: n === 40 ? 0.01 : n === 38 ? -0.01 : 0,
            },
            true
          )
        );
      };
      class xx {
        constructor(t, e, n, o) {
          const i = bx(
            `<div role="slider" tabindex="0" part="${e}" ${n}><div part="${e}-pointer"></div></div>`
          );
          t.appendChild(i.content.cloneNode(true));
          const r = t.querySelector(`[part=${e}]`);
          r.addEventListener("mousedown", this);
          r.addEventListener("touchstart", this);
          r.addEventListener("keydown", this);
          this.el = r;
          this.xy = o;
          this.nodes = [r.firstChild, r];
        }
        set dragging(t) {
          const e = t ? document.addEventListener : document.removeEventListener;
          e(_x ? "touchmove" : "mousemove", this);
          e(_x ? "touchend" : "mouseup", this);
        }
        handleEvent(t) {
          switch (t.type) {
            case "mousedown":
            case "touchstart":
              t.preventDefault();
              if (!Ax(t) || (!_x && t.button != 0)) return;
              this.el.focus();
              Cx(this, t);
              this.dragging = true;
              break;
            case "mousemove":
            case "touchmove":
              t.preventDefault();
              Cx(this, t);
              break;
            case "mouseup":
            case "touchend":
              this.dragging = false;
              break;
            case "keydown":
              yx(this, t);
              break;
          }
        }
        style(t) {
          t.forEach((t, e) => {
            for (const n in t) {
              this.nodes[e].style.setProperty(n, t[n]);
            }
          });
        }
      }
      class Ex extends xx {
        constructor(t) {
          super(t, "hue", 'aria-label="Hue" aria-valuemin="0" aria-valuemax="360"', false);
        }
        update({ h: t }) {
          this.h = t;
          this.style([{ left: `${(t / 360) * 100}%`, color: Qy({ h: t, s: 100, v: 100, a: 1 }) }]);
          this.el.setAttribute("aria-valuenow", `${Ly(t)}`);
        }
        getMove(t, e) {
          return { h: e ? Vy(this.h + t.x * 360, 0, 360) : 360 * t.x };
        }
      }
      class Dx extends xx {
        constructor(t) {
          super(t, "saturation", 'aria-label="Color"', true);
        }
        update(t) {
          this.hsva = t;
          this.style([
            { top: `${100 - t.v}%`, left: `${t.s}%`, color: Qy(t) },
            { "background-color": Qy({ h: t.h, s: 100, v: 100, a: 1 }) },
          ]);
          this.el.setAttribute("aria-valuetext", `Saturation ${Ly(t.s)}%, Brightness ${Ly(t.v)}%`);
        }
        getMove(t, e) {
          return {
            s: e ? Vy(this.hsva.s + t.x * 100, 0, 100) : t.x * 100,
            v: e ? Vy(this.hsva.v - t.y * 100, 0, 100) : Math.round(100 - t.y * 100),
          };
        }
      }
      const Sx = `:host{display:flex;flex-direction:column;position:relative;width:200px;height:200px;user-select:none;-webkit-user-select:none;cursor:default}:host([hidden]){display:none!important}[role=slider]{position:relative;touch-action:none;user-select:none;-webkit-user-select:none;outline:0}[role=slider]:last-child{border-radius:0 0 8px 8px}[part$=pointer]{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;display:flex;place-content:center center;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}[part$=pointer]::after{content:"";width:100%;height:100%;border-radius:inherit;background-color:currentColor}[role=slider]:focus [part$=pointer]{transform:translate(-50%,-50%) scale(1.1)}`;
      const Tx = `[part=hue]{flex:0 0 24px;background:linear-gradient(to right,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red 100%)}[part=hue-pointer]{top:50%;z-index:2}`;
      const Px = `[part=saturation]{flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(to top,#000,transparent),linear-gradient(to right,#fff,rgba(255,255,255,0));box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}[part=saturation-pointer]{z-index:3}`;
      const Bx = Symbol("same");
      const Ox = Symbol("color");
      const Rx = Symbol("hsva");
      const Ix = Symbol("update");
      const zx = Symbol("parts");
      const Fx = Symbol("css");
      const Mx = Symbol("sliders");
      class Nx extends HTMLElement {
        static get observedAttributes() {
          return ["color"];
        }
        get [Fx]() {
          return [Sx, Tx, Px];
        }
        get [Mx]() {
          return [Dx, Ex];
        }
        get color() {
          return this[Ox];
        }
        set color(t) {
          if (!this[Bx](t)) {
            const e = this.colorModel.toHsva(t);
            this[Ix](e);
            this[Ox] = t;
          }
        }
        constructor() {
          super();
          const t = bx(`<style>${this[Fx].join("")}</style>`);
          const e = this.attachShadow({ mode: "open" });
          e.appendChild(t.content.cloneNode(true));
          e.addEventListener("move", this);
          this[zx] = this[Mx].map((t) => new t(e));
        }
        connectedCallback() {
          if (this.hasOwnProperty("color")) {
            const t = this.color;
            delete this["color"];
            this.color = t;
          } else if (!this.color) {
            this.color = this.colorModel.defaultColor;
          }
        }
        attributeChangedCallback(t, e, n) {
          const o = this.colorModel.fromAttr(n);
          if (!this[Bx](o)) {
            this.color = o;
          }
        }
        handleEvent(t) {
          const e = this[Rx];
          const n = { ...e, ...t.detail };
          this[Ix](n);
          let o;
          if (!px(n, e) && !this[Bx]((o = this.colorModel.fromHsva(n)))) {
            this[Ox] = o;
            wx(this, "color-changed", { value: o });
          }
        }
        [Bx](t) {
          return this.color && this.colorModel.equal(t, this.color);
        }
        [Ix](t) {
          this[Rx] = t;
          this[zx].forEach((e) => e.update(t));
        }
      }
      const Vx = {
        defaultColor: "#000",
        toHsva: jy,
        fromHsva: ({ h: t, s: e, v: n }) => Uy({ h: t, s: e, v: n, a: 1 }),
        equal: mx,
        fromAttr: (t) => t,
      };
      class Lx extends Nx {
        get colorModel() {
          return Vx;
        }
      }
      class Hx extends Lx {}
      customElements.define("hex-color-picker", Hx);
      var jx = n(257);
      var qx = { injectType: "singletonStyleTag", attributes: { "data-cke": true } };
      qx.insert = "head";
      qx.singleton = true;
      var $x = Pl()(jx.Z, qx);
      const Wx = jx.Z.locals || {};
      const Gx = 150;
      class Kx extends zl {
        constructor(t, e = {}) {
          super(t);
          this.set({ color: "", _hexColor: "" });
          this.hexInputRow = this._createInputRow();
          const n = this.createCollection();
          if (!e.hideInput) {
            n.add(this.hexInputRow);
          }
          this.setTemplate({
            tag: "div",
            attributes: { class: ["ck", "ck-color-picker"], tabindex: -1 },
            children: n,
          });
          this._config = e;
          this._debounceColorPickerEvent = mh(
            (t) => {
              this.set("color", t);
              this.fire("colorSelected", { color: this.color });
            },
            Gx,
            { leading: true }
          );
          this.on("set:color", (t, e, n) => {
            t.return = qd(n, this._config.format || "hsl");
          });
          this.on("change:color", () => {
            this._hexColor = Ux(this.color);
          });
          this.on("change:_hexColor", () => {
            if (document.activeElement !== this.picker) {
              this.picker.setAttribute("color", this._hexColor);
            }
            if (Ux(this.color) != Ux(this._hexColor)) {
              this.color = this._hexColor;
            }
          });
        }
        render() {
          super.render();
          this.picker = Qa.document.createElement("hex-color-picker");
          this.picker.setAttribute("class", "hex-color-picker");
          this.picker.setAttribute("tabindex", "-1");
          this._createSlidersView();
          if (this.element) {
            if (this.hexInputRow.element) {
              this.element.insertBefore(this.picker, this.hexInputRow.element);
            } else {
              this.element.appendChild(this.picker);
            }
            const t = document.createElement("style");
            t.textContent =
              '[role="slider"]:focus [part$="pointer"] {' +
              "border: 1px solid #fff;" +
              "outline: 1px solid var(--ck-color-focus-border);" +
              "box-shadow: 0 0 0 2px #fff;" +
              "}";
            this.picker.shadowRoot.appendChild(t);
          }
          this.picker.addEventListener("color-changed", (t) => {
            const e = t;
            const n = e.detail.value;
            this._debounceColorPickerEvent(n);
          });
        }
        focus() {
          if (!this._config.hideInput && (r.isGecko || r.isiOS || r.isSafari)) {
            const t = this.hexInputRow.children.get(1);
            t.focus();
          }
          const t = this.slidersView.first;
          t.focus();
        }
        _createSlidersView() {
          const t = [...this.picker.shadowRoot.children];
          const e = t.filter((t) => t.getAttribute("role") === "slider");
          const n = e.map((t) => {
            const e = new Zx(t);
            return e;
          });
          this.slidersView = this.createCollection();
          n.forEach((t) => {
            this.slidersView.add(t);
          });
        }
        _createInputRow() {
          const t = new Jx();
          const e = this._createColorInput();
          return new Yx(this.locale, [t, e]);
        }
        _createColorInput() {
          const t = new Eh(this.locale, zy);
          const { t: e } = this.locale;
          t.set({ label: e("HEX"), class: "color-picker-hex-input" });
          t.fieldView.bind("value").to(this, "_hexColor", (e) => {
            if (t.isFocused) {
              return t.fieldView.value;
            } else {
              return e.startsWith("#") ? e.substring(1) : e;
            }
          });
          t.fieldView.on("input", () => {
            const e = t.fieldView.element.value;
            if (e) {
              const t = e.trim();
              const n = t.startsWith("#") ? t.substring(1) : t;
              const o =
                [3, 4, 6, 8].includes(n.length) &&
                /(([0-9a-fA-F]{2}){3,4}|([0-9a-fA-F]){3,4})/.test(n);
              if (o) {
                this._debounceColorPickerEvent("#" + n);
              }
            }
          });
          return t;
        }
      }
      function Ux(t) {
        let e = $d(t);
        if (!e) {
          e = "#000";
        }
        if (e.length === 4) {
          e = "#" + [e[1], e[1], e[2], e[2], e[3], e[3]].join("");
        }
        return e.toLowerCase();
      }
      class Zx extends zl {
        constructor(t) {
          super();
          this.element = t;
        }
        focus() {
          this.element.focus();
        }
      }
      class Jx extends zl {
        constructor(t) {
          super(t);
          this.setTemplate({
            tag: "div",
            attributes: { class: ["ck", "ck-color-picker__hash-view"] },
            children: "#",
          });
        }
      }
      class Yx extends zl {
        constructor(t, e) {
          super(t);
          this.children = this.createCollection(e);
          this.setTemplate({
            tag: "div",
            attributes: { class: ["ck", "ck-color-picker__row"] },
            children: this.children,
          });
        }
      }
      class Qx extends lt(ll) {
        constructor(t) {
          super(t);
          this.set("isEmpty", true);
          this.on("change", () => {
            this.set("isEmpty", this.length === 0);
          });
        }
        add(t, e) {
          if (this.find((e) => e.color === t.color)) {
            return this;
          }
          return super.add(t, e);
        }
        hasColor(t) {
          return !!this.find((e) => e.color === t);
        }
      }
      const Xx =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.209 18.717A8.5 8.5 0 1 1 18.686 9.6h-.008l.002.12a3 3 0 0 1-2.866 2.997h-.268l-.046-.002v.002h-4.791a2 2 0 1 0 0 4 1 1 0 1 1-.128 1.992 8.665 8.665 0 0 1-.372.008Zm-3.918-7.01a1.25 1.25 0 1 0-2.415-.648 1.25 1.25 0 0 0 2.415.647ZM5.723 8.18a1.25 1.25 0 1 0 .647-2.414 1.25 1.25 0 0 0-.647 2.414ZM9.76 6.155a1.25 1.25 0 1 0 .647-2.415 1.25 1.25 0 0 0-.647 2.415Zm4.028 1.759a1.25 1.25 0 1 0 .647-2.415 1.25 1.25 0 0 0-.647 2.415Z"/></svg>';
      class tE extends zl {
        constructor(
          t,
          {
            colors: e,
            columns: n,
            removeButtonLabel: o,
            documentColorsLabel: i,
            documentColorsCount: r,
            colorPickerLabel: s,
            focusTracker: a,
            focusables: c,
          }
        ) {
          super(t);
          const l = this.bindTemplate;
          this.set("isVisible", true);
          this.focusTracker = a;
          this.items = this.createCollection();
          this.colorDefinitions = e;
          this.columns = n;
          this.documentColors = new Qx();
          this.documentColorsCount = r;
          this._focusables = c;
          this._removeButtonLabel = o;
          this._colorPickerLabel = s;
          this._documentColorsLabel = i;
          this.setTemplate({
            tag: "div",
            attributes: {
              class: ["ck-color-grids-fragment", l.if("isVisible", "ck-hidden", (t) => !t)],
            },
            children: this.items,
          });
          this.removeColorButtonView = this._createRemoveColorButton();
          this.items.add(this.removeColorButtonView);
        }
        updateDocumentColors(t, e) {
          const n = t.document;
          const o = this.documentColorsCount;
          this.documentColors.clear();
          for (const i of n.getRoots()) {
            const n = t.createRangeIn(i);
            for (const t of n.getItems()) {
              if (t.is("$textProxy") && t.hasAttribute(e)) {
                this._addColorToDocumentColors(t.getAttribute(e));
                if (this.documentColors.length >= o) {
                  return;
                }
              }
            }
          }
        }
        updateSelectedColors() {
          const t = this.documentColorsGrid;
          const e = this.staticColorsGrid;
          const n = this.selectedColor;
          e.selectedColor = n;
          if (t) {
            t.selectedColor = n;
          }
        }
        render() {
          super.render();
          this.staticColorsGrid = this._createStaticColorsGrid();
          this.items.add(this.staticColorsGrid);
          if (this.documentColorsCount) {
            const t = Ml.bind(this.documentColors, this.documentColors);
            const e = new vh(this.locale);
            e.text = this._documentColorsLabel;
            e.extendTemplate({
              attributes: { class: ["ck", "ck-color-grid__label", t.if("isEmpty", "ck-hidden")] },
            });
            this.items.add(e);
            this.documentColorsGrid = this._createDocumentColorsGrid();
            this.items.add(this.documentColorsGrid);
          }
          this._createColorPickerButton();
          this._addColorSelectorElementsToFocusTracker();
          this.focus();
        }
        focus() {
          this.removeColorButtonView.focus();
        }
        destroy() {
          super.destroy();
        }
        addColorPickerButton() {
          if (this.colorPickerButtonView) {
            this.items.add(this.colorPickerButtonView);
            this.focusTracker.add(this.colorPickerButtonView.element);
            this._focusables.add(this.colorPickerButtonView);
          }
        }
        _addColorSelectorElementsToFocusTracker() {
          this.focusTracker.add(this.removeColorButtonView.element);
          this._focusables.add(this.removeColorButtonView);
          if (this.staticColorsGrid) {
            this.focusTracker.add(this.staticColorsGrid.element);
            this._focusables.add(this.staticColorsGrid);
          }
          if (this.documentColorsGrid) {
            this.focusTracker.add(this.documentColorsGrid.element);
            this._focusables.add(this.documentColorsGrid);
          }
        }
        _createColorPickerButton() {
          this.colorPickerButtonView = new vd();
          this.colorPickerButtonView.set({
            label: this._colorPickerLabel,
            withText: true,
            icon: Xx,
            class: "ck-color-selector__color-picker",
          });
          this.colorPickerButtonView.on("execute", () => {
            this.fire("colorPicker:show");
          });
        }
        _createRemoveColorButton() {
          const t = new vd();
          t.set({ withText: true, icon: lC, label: this._removeButtonLabel });
          t.class = "ck-color-selector__remove-color";
          t.on("execute", () => {
            this.fire("execute", { value: null, source: "removeColorButton" });
          });
          t.render();
          return t;
        }
        _createStaticColorsGrid() {
          const t = new Md(this.locale, {
            colorDefinitions: this.colorDefinitions,
            columns: this.columns,
          });
          t.on("execute", (t, e) => {
            this.fire("execute", { value: e.value, source: "staticColorsGrid" });
          });
          return t;
        }
        _createDocumentColorsGrid() {
          const t = Ml.bind(this.documentColors, this.documentColors);
          const e = new Md(this.locale, { columns: this.columns });
          e.extendTemplate({ attributes: { class: t.if("isEmpty", "ck-hidden") } });
          e.items.bindTo(this.documentColors).using((t) => {
            const e = new Bd();
            e.set({ color: t.color, hasBorder: t.options && t.options.hasBorder });
            if (t.label) {
              e.set({ label: t.label, tooltip: true });
            }
            e.on("execute", () => {
              this.fire("execute", { value: t.color, source: "documentColorsGrid" });
            });
            return e;
          });
          this.documentColors.on("change:isEmpty", (t, n, o) => {
            if (o) {
              e.selectedColor = null;
            }
          });
          return e;
        }
        _addColorToDocumentColors(t) {
          const e = this.colorDefinitions.find((e) => e.color === t);
          if (!e) {
            this.documentColors.add({ color: t, label: t, options: { hasBorder: false } });
          } else {
            this.documentColors.add(Object.assign({}, e));
          }
        }
      }
      class eE extends zl {
        constructor(
          t,
          { focusTracker: e, focusables: n, keystrokes: o, colorPickerViewConfig: i }
        ) {
          super(t);
          this.items = this.createCollection();
          this.focusTracker = e;
          this.keystrokes = o;
          this.set("isVisible", false);
          this.set("selectedColor", undefined);
          this._focusables = n;
          this._colorPickerViewConfig = i;
          const r = this.bindTemplate;
          const { saveButtonView: s, cancelButtonView: a } = this._createActionButtons();
          this.saveButtonView = s;
          this.cancelButtonView = a;
          this.actionBarView = this._createActionBarView({
            saveButtonView: s,
            cancelButtonView: a,
          });
          this.setTemplate({
            tag: "div",
            attributes: {
              class: ["ck-color-picker-fragment", r.if("isVisible", "ck-hidden", (t) => !t)],
            },
            children: this.items,
          });
        }
        render() {
          super.render();
          const t = new Kx(this.locale, { ...this._colorPickerViewConfig });
          this.colorPickerView = t;
          this.colorPickerView.render();
          if (this.selectedColor) {
            t.color = this.selectedColor;
          }
          this.listenTo(this, "change:selectedColor", (e, n, o) => {
            t.color = o;
          });
          this.items.add(this.colorPickerView);
          this.items.add(this.actionBarView);
          this._addColorPickersElementsToFocusTracker();
          this._stopPropagationOnArrowsKeys();
          this._executeOnEnterPress();
          this._executeUponColorChange();
        }
        destroy() {
          super.destroy();
        }
        focus() {
          this.colorPickerView.focus();
        }
        _executeOnEnterPress() {
          this.keystrokes.set("enter", (t) => {
            if (
              this.isVisible &&
              this.focusTracker.focusedElement !== this.cancelButtonView.element
            ) {
              this.fire("execute", { value: this.selectedColor });
              t.stopPropagation();
              t.preventDefault();
            }
          });
        }
        _stopPropagationOnArrowsKeys() {
          const t = (t) => t.stopPropagation();
          this.keystrokes.set("arrowright", t);
          this.keystrokes.set("arrowleft", t);
          this.keystrokes.set("arrowup", t);
          this.keystrokes.set("arrowdown", t);
        }
        _addColorPickersElementsToFocusTracker() {
          for (const t of this.colorPickerView.slidersView) {
            this.focusTracker.add(t.element);
            this._focusables.add(t);
          }
          const t = this.colorPickerView.hexInputRow.children.get(1);
          if (t.element) {
            this.focusTracker.add(t.element);
            this._focusables.add(t);
          }
          this.focusTracker.add(this.saveButtonView.element);
          this._focusables.add(this.saveButtonView);
          this.focusTracker.add(this.cancelButtonView.element);
          this._focusables.add(this.cancelButtonView);
        }
        _createActionBarView({ saveButtonView: t, cancelButtonView: e }) {
          const n = new zl();
          const o = this.createCollection();
          o.add(t);
          o.add(e);
          n.setTemplate({
            tag: "div",
            attributes: { class: ["ck", "ck-color-selector_action-bar"] },
            children: o,
          });
          return n;
        }
        _createActionButtons() {
          const t = this.locale;
          const e = t.t;
          const n = new vd(t);
          const o = new vd(t);
          n.set({
            icon: aC,
            class: "ck-button-save",
            type: "button",
            withText: false,
            label: e("Accept"),
          });
          o.set({
            icon: rC,
            class: "ck-button-cancel",
            type: "button",
            withText: false,
            label: e("Cancel"),
          });
          n.on("execute", () => {
            this.fire("execute", { source: "colorPickerSaveButton", value: this.selectedColor });
          });
          o.on("execute", () => {
            this.fire("colorPicker:cancel");
          });
          return { saveButtonView: n, cancelButtonView: o };
        }
        _executeUponColorChange() {
          this.colorPickerView.on("colorSelected", (t, e) => {
            this.fire("execute", { value: e.color, source: "colorPicker" });
            this.set("selectedColor", e.color);
          });
        }
      }
      var nE = n(306);
      var oE = { injectType: "singletonStyleTag", attributes: { "data-cke": true } };
      oE.insert = "head";
      oE.singleton = true;
      var iE = Pl()(nE.Z, oE);
      const rE = nE.Z.locals || {};
      class sE extends zl {
        constructor(
          t,
          {
            colors: e,
            columns: n,
            removeButtonLabel: o,
            documentColorsLabel: i,
            documentColorsCount: r,
            colorPickerLabel: s,
            colorPickerViewConfig: a,
          }
        ) {
          super(t);
          this.items = this.createCollection();
          this.focusTracker = new hl();
          this.keystrokes = new ul();
          this._focusables = new Dl();
          this._colorPickerViewConfig = a;
          this._focusCycler = new Jh({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: { focusPrevious: "shift + tab", focusNext: "tab" },
          });
          this.colorGridsFragmentView = new tE(t, {
            colors: e,
            columns: n,
            removeButtonLabel: o,
            documentColorsLabel: i,
            documentColorsCount: r,
            colorPickerLabel: s,
            focusTracker: this.focusTracker,
            focusables: this._focusables,
          });
          this.colorPickerFragmentView = new eE(t, {
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokes: this.keystrokes,
            colorPickerViewConfig: a,
          });
          this.set("_isColorGridsFragmentVisible", true);
          this.set("_isColorPickerFragmentVisible", false);
          this.set("selectedColor", undefined);
          this.colorGridsFragmentView.bind("isVisible").to(this, "_isColorGridsFragmentVisible");
          this.colorPickerFragmentView.bind("isVisible").to(this, "_isColorPickerFragmentVisible");
          this.on("change:selectedColor", (t, e, n) => {
            this.colorGridsFragmentView.set("selectedColor", n);
            this.colorPickerFragmentView.set("selectedColor", n);
          });
          this.colorGridsFragmentView.on("change:selectedColor", (t, e, n) => {
            this.set("selectedColor", n);
          });
          this.colorPickerFragmentView.on("change:selectedColor", (t, e, n) => {
            this.set("selectedColor", n);
          });
          this.setTemplate({
            tag: "div",
            attributes: { class: ["ck", "ck-color-selector"] },
            children: this.items,
          });
        }
        render() {
          super.render();
          this.keystrokes.listenTo(this.element);
        }
        destroy() {
          super.destroy();
          this.focusTracker.destroy();
          this.keystrokes.destroy();
        }
        appendUI() {
          this._appendColorGridsFragment();
          if (this._colorPickerViewConfig) {
            this._appendColorPickerFragment();
          }
        }
        showColorPickerFragment() {
          if (!this.colorPickerFragmentView.colorPickerView || this._isColorPickerFragmentVisible) {
            return;
          }
          this._isColorPickerFragmentVisible = true;
          this.colorPickerFragmentView.focus();
          this._isColorGridsFragmentVisible = false;
        }
        showColorGridsFragment() {
          if (this._isColorGridsFragmentVisible) {
            return;
          }
          this._isColorGridsFragmentVisible = true;
          this.colorGridsFragmentView.focus();
          this._isColorPickerFragmentVisible = false;
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        focusLast() {
          this._focusCycler.focusLast();
        }
        updateDocumentColors(t, e) {
          this.colorGridsFragmentView.updateDocumentColors(t, e);
        }
        updateSelectedColors() {
          this.colorGridsFragmentView.updateSelectedColors();
        }
        _appendColorGridsFragment() {
          if (this.items.length) {
            return;
          }
          this.items.add(this.colorGridsFragmentView);
          this.colorGridsFragmentView.delegate("execute").to(this);
          this.colorGridsFragmentView.delegate("colorPicker:show").to(this);
        }
        _appendColorPickerFragment() {
          if (this.items.length === 2) {
            return;
          }
          this.items.add(this.colorPickerFragmentView);
          if (this.colorGridsFragmentView.colorPickerButtonView) {
            this.colorGridsFragmentView.colorPickerButtonView.on("execute", () => {
              this.showColorPickerFragment();
            });
          }
          this.colorGridsFragmentView.addColorPickerButton();
          this.colorPickerFragmentView.delegate("execute").to(this);
          this.colorPickerFragmentView.delegate("colorPicker:cancel").to(this);
        }
      }
      class aE {
        constructor(t) {
          this._components = new Map();
          this.editor = t;
        }
        *names() {
          for (const t of this._components.values()) {
            yield t.originalName;
          }
        }
        add(t, e) {
          this._components.set(cE(t), { callback: e, originalName: t });
        }
        create(t) {
          if (!this.has(t)) {
            throw new P("componentfactory-item-missing", this, { name: t });
          }
          return this._components.get(cE(t)).callback(this.editor.locale);
        }
        has(t) {
          return this._components.has(cE(t));
        }
      }
      function cE(t) {
        return String(t).toLowerCase();
      }
      var lE = n(460);
      var dE = { injectType: "singletonStyleTag", attributes: { "data-cke": true } };
      dE.insert = "head";
      dE.singleton = true;
      var hE = Pl()(lE.Z, dE);
      const uE = lE.Z.locals || {};
      const fE = mc("px");
      const pE = Qa.document.body;
      const gE = { top: -99999, left: -99999, name: "arrowless", config: { withArrow: false } };
      class mE extends zl {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          this.set("top", 0);
          this.set("left", 0);
          this.set("position", "arrow_nw");
          this.set("isVisible", false);
          this.set("withArrow", true);
          this.set("class", undefined);
          this._pinWhenIsVisibleCallback = null;
          this.content = this.createCollection();
          this.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-balloon-panel",
                e.to("position", (t) => `ck-balloon-panel_${t}`),
                e.if("isVisible", "ck-balloon-panel_visible"),
                e.if("withArrow", "ck-balloon-panel_with-arrow"),
                e.to("class"),
              ],
              style: { top: e.to("top", fE), left: e.to("left", fE) },
            },
            children: this.content,
          });
        }
        show() {
          this.isVisible = true;
        }
        hide() {
          this.isVisible = false;
        }
        attachTo(t) {
          this.show();
          const e = mE.defaultPositions;
          const n = Object.assign(
            {},
            {
              element: this.element,
              positions: [
                e.southArrowNorth,
                e.southArrowNorthMiddleWest,
                e.southArrowNorthMiddleEast,
                e.southArrowNorthWest,
                e.southArrowNorthEast,
                e.northArrowSouth,
                e.northArrowSouthMiddleWest,
                e.northArrowSouthMiddleEast,
                e.northArrowSouthWest,
                e.northArrowSouthEast,
                e.viewportStickyNorth,
              ],
              limiter: pE,
              fitInViewport: true,
            },
            t
          );
          const o = mE._getOptimalPosition(n) || gE;
          const i = parseInt(o.left);
          const r = parseInt(o.top);
          const s = o.name;
          const a = o.config || {};
          const { withArrow: c = true } = a;
          this.top = r;
          this.left = i;
          this.position = s;
          this.withArrow = c;
        }
        pin(t) {
          this.unpin();
          this._pinWhenIsVisibleCallback = () => {
            if (this.isVisible) {
              this._startPinning(t);
            } else {
              this._stopPinning();
            }
          };
          this._startPinning(t);
          this.listenTo(this, "change:isVisible", this._pinWhenIsVisibleCallback);
        }
        unpin() {
          if (this._pinWhenIsVisibleCallback) {
            this._stopPinning();
            this.stopListening(this, "change:isVisible", this._pinWhenIsVisibleCallback);
            this._pinWhenIsVisibleCallback = null;
            this.hide();
          }
        }
        _startPinning(t) {
          this.attachTo(t);
          const e = kE(t.target);
          const n = t.limiter ? kE(t.limiter) : pE;
          this.listenTo(
            Qa.document,
            "scroll",
            (o, i) => {
              const r = i.target;
              const s = e && r.contains(e);
              const a = n && r.contains(n);
              if (s || a || !e || !n) {
                this.attachTo(t);
              }
            },
            { useCapture: true }
          );
          this.listenTo(Qa.window, "resize", () => {
            this.attachTo(t);
          });
        }
        _stopPinning() {
          this.stopListening(Qa.document, "scroll");
          this.stopListening(Qa.window, "resize");
        }
      }
      mE.arrowSideOffset = 25;
      mE.arrowHeightOffset = 10;
      mE.stickyVerticalOffset = 20;
      mE._getOptimalPosition = Ac;
      mE.defaultPositions = bE();
      function kE(t) {
        if (La(t)) {
          return t;
        }
        if (oc(t)) {
          return t.commonAncestorContainer;
        }
        if (typeof t == "function") {
          return kE(t());
        }
        return null;
      }
      function bE(t = {}) {
        const {
          sideOffset: e = mE.arrowSideOffset,
          heightOffset: n = mE.arrowHeightOffset,
          stickyVerticalOffset: o = mE.stickyVerticalOffset,
          config: i,
        } = t;
        return {
          northWestArrowSouthWest: (t, n) => ({
            top: r(t, n),
            left: t.left - e,
            name: "arrow_sw",
            ...(i && { config: i }),
          }),
          northWestArrowSouthMiddleWest: (t, n) => ({
            top: r(t, n),
            left: t.left - n.width * 0.25 - e,
            name: "arrow_smw",
            ...(i && { config: i }),
          }),
          northWestArrowSouth: (t, e) => ({
            top: r(t, e),
            left: t.left - e.width / 2,
            name: "arrow_s",
            ...(i && { config: i }),
          }),
          northWestArrowSouthMiddleEast: (t, n) => ({
            top: r(t, n),
            left: t.left - n.width * 0.75 + e,
            name: "arrow_sme",
            ...(i && { config: i }),
          }),
          northWestArrowSouthEast: (t, n) => ({
            top: r(t, n),
            left: t.left - n.width + e,
            name: "arrow_se",
            ...(i && { config: i }),
          }),
          northArrowSouthWest: (t, n) => ({
            top: r(t, n),
            left: t.left + t.width / 2 - e,
            name: "arrow_sw",
            ...(i && { config: i }),
          }),
          northArrowSouthMiddleWest: (t, n) => ({
            top: r(t, n),
            left: t.left + t.width / 2 - n.width * 0.25 - e,
            name: "arrow_smw",
            ...(i && { config: i }),
          }),
          northArrowSouth: (t, e) => ({
            top: r(t, e),
            left: t.left + t.width / 2 - e.width / 2,
            name: "arrow_s",
            ...(i && { config: i }),
          }),
          northArrowSouthMiddleEast: (t, n) => ({
            top: r(t, n),
            left: t.left + t.width / 2 - n.width * 0.75 + e,
            name: "arrow_sme",
            ...(i && { config: i }),
          }),
          northArrowSouthEast: (t, n) => ({
            top: r(t, n),
            left: t.left + t.width / 2 - n.width + e,
            name: "arrow_se",
            ...(i && { config: i }),
          }),
          northEastArrowSouthWest: (t, n) => ({
            top: r(t, n),
            left: t.right - e,
            name: "arrow_sw",
            ...(i && { config: i }),
          }),
          northEastArrowSouthMiddleWest: (t, n) => ({
            top: r(t, n),
            left: t.right - n.width * 0.25 - e,
            name: "arrow_smw",
            ...(i && { config: i }),
          }),
          northEastArrowSouth: (t, e) => ({
            top: r(t, e),
            left: t.right - e.width / 2,
            name: "arrow_s",
            ...(i && { config: i }),
          }),
          northEastArrowSouthMiddleEast: (t, n) => ({
            top: r(t, n),
            left: t.right - n.width * 0.75 + e,
            name: "arrow_sme",
            ...(i && { config: i }),
          }),
          northEastArrowSouthEast: (t, n) => ({
            top: r(t, n),
            left: t.right - n.width + e,
            name: "arrow_se",
            ...(i && { config: i }),
          }),
          southWestArrowNorthWest: (t) => ({
            top: s(t),
            left: t.left - e,
            name: "arrow_nw",
            ...(i && { config: i }),
          }),
          southWestArrowNorthMiddleWest: (t, n) => ({
            top: s(t),
            left: t.left - n.width * 0.25 - e,
            name: "arrow_nmw",
            ...(i && { config: i }),
          }),
          southWestArrowNorth: (t, e) => ({
            top: s(t),
            left: t.left - e.width / 2,
            name: "arrow_n",
            ...(i && { config: i }),
          }),
          southWestArrowNorthMiddleEast: (t, n) => ({
            top: s(t),
            left: t.left - n.width * 0.75 + e,
            name: "arrow_nme",
            ...(i && { config: i }),
          }),
          southWestArrowNorthEast: (t, n) => ({
            top: s(t),
            left: t.left - n.width + e,
            name: "arrow_ne",
            ...(i && { config: i }),
          }),
          southArrowNorthWest: (t) => ({
            top: s(t),
            left: t.left + t.width / 2 - e,
            name: "arrow_nw",
            ...(i && { config: i }),
          }),
          southArrowNorthMiddleWest: (t, n) => ({
            top: s(t),
            left: t.left + t.width / 2 - n.width * 0.25 - e,
            name: "arrow_nmw",
            ...(i && { config: i }),
          }),
          southArrowNorth: (t, e) => ({
            top: s(t),
            left: t.left + t.width / 2 - e.width / 2,
            name: "arrow_n",
            ...(i && { config: i }),
          }),
          southArrowNorthMiddleEast: (t, n) => ({
            top: s(t),
            left: t.left + t.width / 2 - n.width * 0.75 + e,
            name: "arrow_nme",
            ...(i && { config: i }),
          }),
          southArrowNorthEast: (t, n) => ({
            top: s(t),
            left: t.left + t.width / 2 - n.width + e,
            name: "arrow_ne",
            ...(i && { config: i }),
          }),
          southEastArrowNorthWest: (t) => ({
            top: s(t),
            left: t.right - e,
            name: "arrow_nw",
            ...(i && { config: i }),
          }),
          southEastArrowNorthMiddleWest: (t, n) => ({
            top: s(t),
            left: t.right - n.width * 0.25 - e,
            name: "arrow_nmw",
            ...(i && { config: i }),
          }),
          southEastArrowNorth: (t, e) => ({
            top: s(t),
            left: t.right - e.width / 2,
            name: "arrow_n",
            ...(i && { config: i }),
          }),
          southEastArrowNorthMiddleEast: (t, n) => ({
            top: s(t),
            left: t.right - n.width * 0.75 + e,
            name: "arrow_nme",
            ...(i && { config: i }),
          }),
          southEastArrowNorthEast: (t, n) => ({
            top: s(t),
            left: t.right - n.width + e,
            name: "arrow_ne",
            ...(i && { config: i }),
          }),
          westArrowEast: (t, e) => ({
            top: t.top + t.height / 2 - e.height / 2,
            left: t.left - e.width - n,
            name: "arrow_e",
            ...(i && { config: i }),
          }),
          eastArrowWest: (t, e) => ({
            top: t.top + t.height / 2 - e.height / 2,
            left: t.right + n,
            name: "arrow_w",
            ...(i && { config: i }),
          }),
          viewportStickyNorth: (t, e, n, r) => {
            const s = r || n;
            if (!t.getIntersection(s)) {
              return null;
            }
            if (s.height - t.height > o) {
              return null;
            }
            return {
              top: s.top + o,
              left: t.left + t.width / 2 - e.width / 2,
              name: "arrowless",
              config: { withArrow: false, ...i },
            };
          },
        };
        function r(t, e) {
          return t.top - e.height - n;
        }
        function s(t) {
          return t.bottom + n;
        }
      }
      var wE = n(888);
      var _E = { injectType: "singletonStyleTag", attributes: { "data-cke": true } };
      _E.insert = "head";
      _E.singleton = true;
      var vE = Pl()(wE.Z, _E);
      const AE = wE.Z.locals || {};
      const CE = "ck-tooltip";
      class yE extends Ka() {
        constructor(t) {
          super();
          this._currentElementWithTooltip = null;
          this._currentTooltipPosition = null;
          this._resizeObserver = null;
          yE._editors.add(t);
          if (yE._instance) {
            return yE._instance;
          }
          yE._instance = this;
          this.tooltipTextView = new zl(t.locale);
          this.tooltipTextView.set("text", "");
          this.tooltipTextView.setTemplate({
            tag: "span",
            attributes: { class: ["ck", "ck-tooltip__text"] },
            children: [{ text: this.tooltipTextView.bindTemplate.to("text") }],
          });
          this.balloonPanelView = new mE(t.locale);
          this.balloonPanelView.class = CE;
          this.balloonPanelView.content.add(this.tooltipTextView);
          this._pinTooltipDebounced = mh(this._pinTooltip, 600);
          this.listenTo(Qa.document, "mouseenter", this._onEnterOrFocus.bind(this), {
            useCapture: true,
          });
          this.listenTo(Qa.document, "mouseleave", this._onLeaveOrBlur.bind(this), {
            useCapture: true,
          });
          this.listenTo(Qa.document, "focus", this._onEnterOrFocus.bind(this), {
            useCapture: true,
          });
          this.listenTo(Qa.document, "blur", this._onLeaveOrBlur.bind(this), { useCapture: true });
          this.listenTo(Qa.document, "scroll", this._onScroll.bind(this), { useCapture: true });
          this._watchdogExcluded = true;
        }
        destroy(t) {
          const e = t.ui.view && t.ui.view.body;
          yE._editors.delete(t);
          this.stopListening(t.ui);
          if (e && e.has(this.balloonPanelView)) {
            e.remove(this.balloonPanelView);
          }
          if (!yE._editors.size) {
            this._unpinTooltip();
            this.balloonPanelView.destroy();
            this.stopListening();
            yE._instance = null;
          }
        }
        static getPositioningFunctions(t) {
          const e = yE.defaultBalloonPositions;
          return {
            s: [e.southArrowNorth, e.southArrowNorthEast, e.southArrowNorthWest],
            n: [e.northArrowSouth],
            e: [e.eastArrowWest],
            w: [e.westArrowEast],
            sw: [e.southArrowNorthEast],
            se: [e.southArrowNorthWest],
          }[t];
        }
        _onEnterOrFocus(t, { target: e }) {
          const n = xE(e);
          if (!n) {
            return;
          }
          if (n === this._currentElementWithTooltip) {
            return;
          }
          this._unpinTooltip();
          this._pinTooltipDebounced(n, EE(n));
        }
        _onLeaveOrBlur(t, { target: e, relatedTarget: n }) {
          if (t.name === "mouseleave") {
            if (!La(e)) {
              return;
            }
            if (this._currentElementWithTooltip && e !== this._currentElementWithTooltip) {
              return;
            }
            const t = xE(e);
            const o = xE(n);
            if (t && t !== o) {
              this._unpinTooltip();
            }
          } else {
            if (this._currentElementWithTooltip && e !== this._currentElementWithTooltip) {
              return;
            }
            this._unpinTooltip();
          }
        }
        _onScroll(t, { target: e }) {
          if (!this._currentElementWithTooltip) {
            return;
          }
          if (
            e.contains(this.balloonPanelView.element) &&
            e.contains(this._currentElementWithTooltip)
          ) {
            return;
          }
          this._unpinTooltip();
        }
        _pinTooltip(t, { text: e, position: n, cssClass: o }) {
          const i = dl(yE._editors.values()).ui.view.body;
          if (!i.has(this.balloonPanelView)) {
            i.add(this.balloonPanelView);
          }
          this.tooltipTextView.text = e;
          this.balloonPanelView.pin({ target: t, positions: yE.getPositioningFunctions(n) });
          this._resizeObserver = new pc(t, () => {
            if (!vc(t)) {
              this._unpinTooltip();
            }
          });
          this.balloonPanelView.class = [CE, o].filter((t) => t).join(" ");
          for (const t of yE._editors) {
            this.listenTo(t.ui, "update", this._updateTooltipPosition.bind(this), {
              priority: "low",
            });
          }
          this._currentElementWithTooltip = t;
          this._currentTooltipPosition = n;
        }
        _unpinTooltip() {
          this._pinTooltipDebounced.cancel();
          this.balloonPanelView.unpin();
          for (const t of yE._editors) {
            this.stopListening(t.ui, "update");
          }
          this._currentElementWithTooltip = null;
          this._currentTooltipPosition = null;
          if (this._resizeObserver) {
            this._resizeObserver.destroy();
          }
        }
        _updateTooltipPosition() {
          if (!vc(this._currentElementWithTooltip)) {
            this._unpinTooltip();
            return;
          }
          this.balloonPanelView.pin({
            target: this._currentElementWithTooltip,
            positions: yE.getPositioningFunctions(this._currentTooltipPosition),
          });
        }
      }
      yE.defaultBalloonPositions = bE({ heightOffset: 5, sideOffset: 13 });
      yE._editors = new Set();
      yE._instance = null;
      function xE(t) {
        if (!La(t)) {
          return null;
        }
        return t.closest("[data-cke-tooltip-text]:not([data-cke-tooltip-disabled])");
      }
      function EE(t) {
        return {
          text: t.dataset.ckeTooltipText,
          position: t.dataset.ckeTooltipPosition || "s",
          cssClass: t.dataset.ckeTooltipClass || "",
        };
      }
      var DE = "Expected a function";
      function SE(t, e, n) {
        var o = true,
          i = true;
        if (typeof t != "function") {
          throw new TypeError(DE);
        }
        if (nt(n)) {
          o = "leading" in n ? !!n.leading : o;
          i = "trailing" in n ? !!n.trailing : i;
        }
        return mh(t, e, { leading: o, maxWait: e, trailing: i });
      }
      const TE = SE;
      const PE =
        '<svg xmlns="http://www.w3.org/2000/svg" width="53" height="10" viewBox="0 0 53 10"><path fill="#1C2331" d="M31.724 1.492a15.139 15.139 0 0 0 .045 1.16 2.434 2.434 0 0 0-.687-.34 3.68 3.68 0 0 0-1.103-.166 2.332 2.332 0 0 0-1.14.255 1.549 1.549 0 0 0-.686.87c-.15.41-.225.98-.225 1.712 0 .939.148 1.659.444 2.161.297.503.792.754 1.487.754.452.015.9-.094 1.294-.316.296-.174.557-.4.771-.669l.14.852h1.282V.007h-1.623v1.485ZM31 6.496a1.77 1.77 0 0 1-.494.061.964.964 0 0 1-.521-.127.758.758 0 0 1-.296-.466 3.984 3.984 0 0 1-.093-.992 4.208 4.208 0 0 1 .098-1.052.753.753 0 0 1 .307-.477 1.08 1.08 0 0 1 .55-.122c.233-.004.466.026.69.089l.483.144v2.553c-.11.076-.213.143-.307.2a1.73 1.73 0 0 1-.417.189ZM35.68 0l-.702.004c-.322.002-.482.168-.48.497l.004.581c.002.33.164.493.486.49l.702-.004c.322-.002.481-.167.48-.496L36.165.49c-.002-.33-.164-.493-.486-.491ZM36.145 2.313l-1.612.01.034 5.482 1.613-.01-.035-5.482ZM39.623.79 37.989.8 38 2.306l-.946.056.006 1.009.949-.006.024 2.983c.003.476.143.844.419 1.106.275.26.658.39 1.148.387.132 0 .293-.01.483-.03.19-.02.38-.046.57-.08.163-.028.324-.068.482-.119l-.183-1.095-.702.004a.664.664 0 0 1-.456-.123.553.553 0 0 1-.14-.422l-.016-2.621 1.513-.01-.006-1.064-1.514.01-.01-1.503ZM46.226 2.388c-.41-.184-.956-.274-1.636-.27-.673.004-1.215.101-1.627.29-.402.179-.72.505-.888.91-.18.419-.268.979-.264 1.68.004.688.1 1.24.285 1.655.172.404.495.724.9.894.414.18.957.268 1.63.264.68-.004 1.224-.099 1.632-.284.4-.176.714-.501.878-.905.176-.418.263-.971.258-1.658-.004-.702-.097-1.261-.28-1.677a1.696 1.696 0 0 0-.888-.9Zm-.613 3.607a.77.77 0 0 1-.337.501 1.649 1.649 0 0 1-1.317.009.776.776 0 0 1-.343-.497 4.066 4.066 0 0 1-.105-1.02 4.136 4.136 0 0 1 .092-1.03.786.786 0 0 1 .337-.507 1.59 1.59 0 0 1 1.316-.008.79.79 0 0 1 .344.502c.078.337.113.683.105 1.03.012.343-.019.685-.092 1.02ZM52.114 2.07a2.67 2.67 0 0 0-1.128.278c-.39.191-.752.437-1.072.73l-.157-.846-1.273.008.036 5.572 1.623-.01-.024-3.78c.35-.124.646-.22.887-.286.26-.075.53-.114.8-.118l.45-.003.144-1.546-.286.001ZM22.083 7.426l-1.576-2.532a2.137 2.137 0 0 0-.172-.253 1.95 1.95 0 0 0-.304-.29.138.138 0 0 1 .042-.04 1.7 1.7 0 0 0 .328-.374l1.75-2.71c.01-.015.025-.028.024-.048-.01-.01-.021-.007-.031-.007L20.49 1.17a.078.078 0 0 0-.075.045l-.868 1.384c-.23.366-.46.732-.688 1.099a.108.108 0 0 1-.112.06c-.098-.005-.196-.001-.294-.002-.018 0-.038.006-.055-.007.002-.02.002-.039.005-.058a4.6 4.6 0 0 0 .046-.701V1.203c0-.02-.009-.032-.03-.03h-.033L16.93 1.17c-.084 0-.073-.01-.073.076v6.491c-.001.018.006.028.025.027h1.494c.083 0 .072.007.072-.071v-2.19c0-.055-.003-.11-.004-.166a3.366 3.366 0 0 0-.05-.417h.06c.104 0 .209.002.313-.002a.082.082 0 0 1 .084.05c.535.913 1.07 1.824 1.607 2.736a.104.104 0 0 0 .103.062c.554-.003 1.107-.002 1.66-.002l.069-.003-.019-.032-.188-.304ZM27.112 6.555c-.005-.08-.004-.08-.082-.08h-2.414c-.053 0-.106-.003-.159-.011a.279.279 0 0 1-.246-.209.558.558 0 0 1-.022-.15c0-.382 0-.762-.002-1.143 0-.032.007-.049.042-.044h2.504c.029.003.037-.012.034-.038V3.814c0-.089.013-.078-.076-.078h-2.44c-.07 0-.062.003-.062-.06v-.837c0-.047.004-.093.013-.14a.283.283 0 0 1 .241-.246.717.717 0 0 1 .146-.011h2.484c.024.002.035-.009.036-.033l.003-.038.03-.496c.01-.183.024-.365.034-.548.005-.085.003-.087-.082-.094-.218-.018-.437-.038-.655-.05a17.845 17.845 0 0 0-.657-.026 72.994 72.994 0 0 0-1.756-.016 1.7 1.7 0 0 0-.471.064 1.286 1.286 0 0 0-.817.655c-.099.196-.149.413-.145.633v3.875c0 .072.003.144.011.216a1.27 1.27 0 0 0 .711 1.029c.228.113.48.167.734.158.757-.005 1.515.002 2.272-.042.274-.016.548-.034.82-.053.03-.002.043-.008.04-.041-.008-.104-.012-.208-.019-.312a69.964 69.964 0 0 1-.05-.768ZM16.14 7.415l-.127-1.075c-.004-.03-.014-.04-.044-.037a13.125 13.125 0 0 1-.998.073c-.336.01-.672.02-1.008.016-.116-.001-.233-.014-.347-.039a.746.746 0 0 1-.45-.262c-.075-.1-.132-.211-.167-.33a3.324 3.324 0 0 1-.126-.773 9.113 9.113 0 0 1-.015-.749c0-.285.022-.57.065-.852.023-.158.066-.312.127-.46a.728.728 0 0 1 .518-.443 1.64 1.64 0 0 1 .397-.048c.628-.001 1.255.003 1.882.05.022.001.033-.006.036-.026l.003-.031.06-.55c.019-.177.036-.355.057-.532.004-.034-.005-.046-.04-.056a5.595 5.595 0 0 0-1.213-.21 10.783 10.783 0 0 0-.708-.02c-.24-.003-.48.01-.719.041a3.477 3.477 0 0 0-.625.14 1.912 1.912 0 0 0-.807.497c-.185.2-.33.433-.424.688a4.311 4.311 0 0 0-.24 1.096c-.031.286-.045.572-.042.86-.006.43.024.86.091 1.286.04.25.104.497.193.734.098.279.26.53.473.734.214.205.473.358.756.446.344.11.702.17 1.063.177a8.505 8.505 0 0 0 1.578-.083 6.11 6.11 0 0 0 .766-.18c.03-.008.047-.023.037-.057a.157.157 0 0 1-.003-.025Z"/><path fill="#AFE229" d="M6.016 6.69a1.592 1.592 0 0 0-.614.21c-.23.132-.422.32-.56.546-.044.072-.287.539-.287.539l-.836 1.528.009.006c.038.025.08.046.123.063.127.046.26.07.395.073.505.023 1.011-.007 1.517-.003.29.009.58.002.869-.022a.886.886 0 0 0 .395-.116.962.962 0 0 0 .312-.286c.056-.083.114-.163.164-.249.24-.408.48-.816.718-1.226.075-.128.148-.257.222-.386l.112-.192a1.07 1.07 0 0 0 .153-.518l-1.304.023s-1.258-.005-1.388.01Z"/><path fill="#771BFF" d="m2.848 9.044.76-1.39.184-.352c-.124-.067-.245-.14-.367-.21-.346-.204-.706-.384-1.045-.6a.984.984 0 0 1-.244-.207c-.108-.134-.136-.294-.144-.46-.021-.409-.002-.818-.009-1.227-.003-.195 0-.39.003-.585.004-.322.153-.553.427-.713l.833-.488c.22-.13.44-.257.662-.385.05-.029.105-.052.158-.077.272-.128.519-.047.76.085l.044.028c.123.06.242.125.358.196.318.178.635.357.952.537.095.056.187.117.275.184.194.144.254.35.266.578.016.284.007.569.006.853-.001.28.004.558 0 .838.592-.003 1.259 0 1.259 0l.723-.013c-.003-.292-.007-.584-.007-.876 0-.524.015-1.048-.016-1.571-.024-.42-.135-.8-.492-1.067a5.02 5.02 0 0 0-.506-.339A400.52 400.52 0 0 0 5.94.787C5.722.664 5.513.524 5.282.423 5.255.406 5.228.388 5.2.373 4.758.126 4.305-.026 3.807.21c-.097.046-.197.087-.29.14A699.896 699.896 0 0 0 .783 1.948c-.501.294-.773.717-.778 1.31-.004.36-.009.718-.001 1.077.016.754-.017 1.508.024 2.261.016.304.07.6.269.848.127.15.279.28.448.382.622.4 1.283.734 1.92 1.11l.183.109Z"/></svg>\n';
      const BE = 53;
      const OE = 10;
      const RE = 50;
      const IE = 350;
      const zE = "Powered by";
      class FE extends Ka() {
        constructor(t) {
          super();
          this.editor = t;
          this._balloonView = null;
          this._lastFocusedEditableElement = null;
          this._showBalloonThrottled = TE(this._showBalloon.bind(this), 50, { leading: true });
          t.on("ready", this._handleEditorReady.bind(this));
        }
        destroy() {
          const t = this._balloonView;
          if (t) {
            t.unpin();
            this._balloonView = null;
          }
          this._showBalloonThrottled.cancel();
          this.stopListening();
        }
        _handleEditorReady() {
          const t = this.editor;
          const e = !!t.config.get("ui.poweredBy.forceVisible");
          if (!e && bl(t.config.get("licenseKey")) === "VALID") {
            return;
          }
          if (!t.ui.view) {
            return;
          }
          t.ui.focusTracker.on("change:isFocused", (t, e, n) => {
            this._updateLastFocusedEditableElement();
            if (n) {
              this._showBalloon();
            } else {
              this._hideBalloon();
            }
          });
          t.ui.focusTracker.on("change:focusedElement", (t, e, n) => {
            this._updateLastFocusedEditableElement();
            if (n) {
              this._showBalloon();
            }
          });
          t.ui.on("update", () => {
            this._showBalloonThrottled();
          });
        }
        _createBalloonView() {
          const t = this.editor;
          const e = (this._balloonView = new mE());
          const n = jE(t);
          const o = new ME(t.locale, n.label);
          e.content.add(o);
          e.set({ class: "ck-powered-by-balloon" });
          t.ui.view.body.add(e);
          t.ui.focusTracker.add(e.element);
          this._balloonView = e;
        }
        _showBalloon() {
          if (!this._lastFocusedEditableElement) {
            return;
          }
          const t = NE(this.editor, this._lastFocusedEditableElement);
          if (t) {
            if (!this._balloonView) {
              this._createBalloonView();
            }
            this._balloonView.pin(t);
          }
        }
        _hideBalloon() {
          if (this._balloonView) {
            this._balloonView.unpin();
          }
        }
        _updateLastFocusedEditableElement() {
          const t = this.editor;
          const e = t.ui.focusTracker.isFocused;
          const n = t.ui.focusTracker.focusedElement;
          if (!e || !n) {
            this._lastFocusedEditableElement = null;
            return;
          }
          const o = Array.from(t.ui.getEditableElementsNames()).map((e) =>
            t.ui.getEditableElement(e)
          );
          if (o.includes(n)) {
            this._lastFocusedEditableElement = n;
          } else {
            this._lastFocusedEditableElement = o[0];
          }
        }
      }
      class ME extends zl {
        constructor(t, e) {
          super(t);
          const n = new gd();
          const o = this.bindTemplate;
          n.set({ content: PE, isColorInherited: false });
          n.extendTemplate({ attributes: { style: { width: BE + "px", height: OE + "px" } } });
          this.setTemplate({
            tag: "div",
            attributes: { class: ["ck", "ck-powered-by"], "aria-hidden": true },
            children: [
              {
                tag: "a",
                attributes: {
                  href:
                    "https://ckeditor.com/?utm_source=ckeditor&" +
                    "utm_medium=referral&utm_campaign=701Dn000000hVgmIAE_powered_by_ckeditor_logo",
                  target: "_blank",
                  tabindex: "-1",
                },
                children: [
                  ...(e
                    ? [
                        {
                          tag: "span",
                          attributes: { class: ["ck", "ck-powered-by__label"] },
                          children: [e],
                        },
                      ]
                    : []),
                  n,
                ],
                on: { dragstart: o.to((t) => t.preventDefault()) },
              },
            ],
          });
        }
      }
      function NE(t, e) {
        const n = jE(t);
        const o = n.side === "right" ? VE(e, n) : LE(e, n);
        return { target: e, positions: [o] };
      }
      function VE(t, e) {
        return HE(t, e, (t, n) => t.left + t.width - n.width - e.horizontalOffset);
      }
      function LE(t, e) {
        return HE(t, e, (t) => t.left + e.horizontalOffset);
      }
      function HE(t, e, n) {
        return (o, i) => {
          const r = new ac(t);
          if (r.width < IE || r.height < RE) {
            return null;
          }
          let s;
          if (e.position === "inside") {
            s = r.bottom - i.height;
          } else {
            s = r.bottom - i.height / 2;
          }
          s -= e.verticalOffset;
          const a = n(r, i);
          const c = o.clone().moveTo(a, s).getIntersection(i.clone().moveTo(a, s));
          const l = c.getVisible();
          if (!l || l.getArea() < i.getArea()) {
            return null;
          }
          return {
            top: s,
            left: a,
            name: `position_${e.position}-side_${e.side}`,
            config: { withArrow: false },
          };
        };
      }
      function jE(t) {
        const e = t.config.get("ui.poweredBy");
        const n = (e && e.position) || "border";
        return {
          position: n,
          label: zE,
          verticalOffset: n === "inside" ? 5 : 0,
          horizontalOffset: 5,
          side: t.locale.contentLanguageDirection === "ltr" ? "right" : "left",
          ...e,
        };
      }
      class qE extends lt() {
        constructor(t) {
          super();
          this.isReady = false;
          this._editableElementsMap = new Map();
          this._focusableToolbarDefinitions = [];
          const e = t.editing.view;
          this.editor = t;
          this.componentFactory = new aE(t);
          this.focusTracker = new hl();
          this.tooltipManager = new yE(t);
          this.poweredBy = new FE(t);
          this.set("viewportOffset", this._readViewportOffsetFromConfig());
          this.once("ready", () => {
            this.isReady = true;
          });
          this.listenTo(e.document, "layoutChanged", this.update.bind(this));
          this.listenTo(e, "scrollToTheSelection", this._handleScrollToTheSelection.bind(this));
          this._initFocusTracking();
        }
        get element() {
          return null;
        }
        update() {
          this.fire("update");
        }
        destroy() {
          this.stopListening();
          this.focusTracker.destroy();
          this.tooltipManager.destroy(this.editor);
          this.poweredBy.destroy();
          for (const t of this._editableElementsMap.values()) {
            t.ckeditorInstance = null;
            this.editor.keystrokes.stopListening(t);
          }
          this._editableElementsMap = new Map();
          this._focusableToolbarDefinitions = [];
        }
        setEditableElement(t, e) {
          this._editableElementsMap.set(t, e);
          if (!e.ckeditorInstance) {
            e.ckeditorInstance = this.editor;
          }
          this.focusTracker.add(e);
          const n = () => {
            if (this.editor.editing.view.getDomRoot(t)) {
              return;
            }
            this.editor.keystrokes.listenTo(e);
          };
          if (this.isReady) {
            n();
          } else {
            this.once("ready", n);
          }
        }
        removeEditableElement(t) {
          const e = this._editableElementsMap.get(t);
          if (!e) {
            return;
          }
          this._editableElementsMap.delete(t);
          this.editor.keystrokes.stopListening(e);
          this.focusTracker.remove(e);
          e.ckeditorInstance = null;
        }
        getEditableElement(t = "main") {
          return this._editableElementsMap.get(t);
        }
        getEditableElementsNames() {
          return this._editableElementsMap.keys();
        }
        addToolbar(t, e = {}) {
          if (t.isRendered) {
            this.focusTracker.add(t.element);
            this.editor.keystrokes.listenTo(t.element);
          } else {
            t.once("render", () => {
              this.focusTracker.add(t.element);
              this.editor.keystrokes.listenTo(t.element);
            });
          }
          this._focusableToolbarDefinitions.push({ toolbarView: t, options: e });
        }
        get _editableElements() {
          console.warn(
            "editor-ui-deprecated-editable-elements: " +
              "The EditorUI#_editableElements property has been deprecated and will be removed in the near future.",
            { editorUI: this }
          );
          return this._editableElementsMap;
        }
        _readViewportOffsetFromConfig() {
          const t = this.editor;
          const e = t.config.get("ui.viewportOffset");
          if (e) {
            return e;
          }
          const n = t.config.get("toolbar.viewportTopOffset");
          if (n) {
            console.warn(
              "editor-ui-deprecated-viewport-offset-config: " +
                "The `toolbar.vieportTopOffset` configuration option is deprecated. " +
                "It will be removed from future CKEditor versions. Use `ui.viewportOffset.top` instead."
            );
            return { top: n };
          }
          return { top: 0 };
        }
        _initFocusTracking() {
          const t = this.editor;
          const e = t.editing.view;
          let n;
          let o;
          t.keystrokes.set("Alt+F10", (t, i) => {
            const r = this.focusTracker.focusedElement;
            if (
              Array.from(this._editableElementsMap.values()).includes(r) &&
              !Array.from(e.domRoots.values()).includes(r)
            ) {
              n = r;
            }
            const s = this._getCurrentFocusedToolbarDefinition();
            if (!s || !o) {
              o = this._getFocusableCandidateToolbarDefinitions();
            }
            for (let t = 0; t < o.length; t++) {
              const t = o.shift();
              o.push(t);
              if (t !== s && this._focusFocusableCandidateToolbar(t)) {
                if (s && s.options.afterBlur) {
                  s.options.afterBlur();
                }
                break;
              }
            }
            i();
          });
          t.keystrokes.set("Esc", (e, o) => {
            const i = this._getCurrentFocusedToolbarDefinition();
            if (!i) {
              return;
            }
            if (n) {
              n.focus();
              n = null;
            } else {
              t.editing.view.focus();
            }
            if (i.options.afterBlur) {
              i.options.afterBlur();
            }
            o();
          });
        }
        _getFocusableCandidateToolbarDefinitions() {
          const t = [];
          for (const e of this._focusableToolbarDefinitions) {
            const { toolbarView: n, options: o } = e;
            if (vc(n.element) || o.beforeFocus) {
              t.push(e);
            }
          }
          t.sort((t, e) => $E(t) - $E(e));
          return t;
        }
        _getCurrentFocusedToolbarDefinition() {
          for (const t of this._focusableToolbarDefinitions) {
            if (
              t.toolbarView.element &&
              t.toolbarView.element.contains(this.focusTracker.focusedElement)
            ) {
              return t;
            }
          }
          return null;
        }
        _focusFocusableCandidateToolbar(t) {
          const {
            toolbarView: e,
            options: { beforeFocus: n },
          } = t;
          if (n) {
            n();
          }
          if (!vc(e.element)) {
            return false;
          }
          e.focus();
          return true;
        }
        _handleScrollToTheSelection(t, e) {
          const n = { top: 0, bottom: 0, left: 0, right: 0, ...this.viewportOffset };
          e.viewportOffset.top += n.top;
          e.viewportOffset.bottom += n.bottom;
          e.viewportOffset.left += n.left;
          e.viewportOffset.right += n.right;
        }
      }
      function $E(t) {
        const { toolbarView: e, options: n } = t;
        let o = 10;
        if (vc(e.element)) {
          o--;
        }
        if (n.isContextual) {
          o--;
        }
        return o;
      }
      var WE = n(847);
      var GE = { injectType: "singletonStyleTag", attributes: { "data-cke": true } };
      GE.insert = "head";
      GE.singleton = true;
      var KE = Pl()(WE.Z, GE);
      const UE = WE.Z.locals || {};
      class ZE extends zl {
        constructor(t) {
          super(t);
          this.body = new dd(t);
        }
        render() {
          super.render();
          this.body.attachToDom();
        }
        destroy() {
          this.body.detachFromDom();
          return super.destroy();
        }
      }
      class JE extends ZE {
        constructor(t) {
          super(t);
          this.top = this.createCollection();
          this.main = this.createCollection();
          this._voiceLabelView = this._createVoiceLabel();
          this.setTemplate({
            tag: "div",
            attributes: {
              class: ["ck", "ck-reset", "ck-editor", "ck-rounded-corners"],
              role: "application",
              dir: t.uiLanguageDirection,
              lang: t.uiLanguage,
              "aria-labelledby": this._voiceLabelView.id,
            },
            children: [
              this._voiceLabelView,
              {
                tag: "div",
                attributes: {
                  class: ["ck", "ck-editor__top", "ck-reset_all"],
                  role: "presentation",
                },
                children: this.top,
              },
              {
                tag: "div",
                attributes: { class: ["ck", "ck-editor__main"], role: "presentation" },
                children: this.main,
              },
            ],
          });
        }
        _createVoiceLabel() {
          const t = this.t;
          const e = new vh();
          e.text = t("Rich Text Editor");
          e.extendTemplate({ attributes: { class: "ck-voice-label" } });
          return e;
        }
      }
      class YE extends zl {
        constructor(t, e, n) {
          super(t);
          this.name = null;
          this.setTemplate({
            tag: "div",
            attributes: {
              class: ["ck", "ck-content", "ck-editor__editable", "ck-rounded-corners"],
              lang: t.contentLanguage,
              dir: t.contentLanguageDirection,
            },
          });
          this.set("isFocused", false);
          this._editableElement = n;
          this._hasExternalElement = !!this._editableElement;
          this._editingView = e;
        }
        render() {
          super.render();
          if (this._hasExternalElement) {
            this.template.apply((this.element = this._editableElement));
          } else {
            this._editableElement = this.element;
          }
          this.on("change:isFocused", () => this._updateIsFocusedClasses());
          this._updateIsFocusedClasses();
        }
        destroy() {
          if (this._hasExternalElement) {
            this.template.revert(this._editableElement);
          }
          super.destroy();
        }
        get hasExternalElement() {
          return this._hasExternalElement;
        }
        _updateIsFocusedClasses() {
          const t = this._editingView;
          if (t.isRenderingInProgress) {
            n(this);
          } else {
            e(this);
          }
          function e(e) {
            t.change((n) => {
              const o = t.document.getRoot(e.name);
              n.addClass(e.isFocused ? "ck-focused" : "ck-blurred", o);
              n.removeClass(e.isFocused ? "ck-blurred" : "ck-focused", o);
            });
          }
          function n(o) {
            t.once("change:isRenderingInProgress", (t, i, r) => {
              if (!r) {
                e(o);
              } else {
                n(o);
              }
            });
          }
        }
      }
      class QE extends YE {
        constructor(t, e, n, o = {}) {
          super(t, e, n);
          const i = t.t;
          this.extendTemplate({
            attributes: { role: "textbox", class: "ck-editor__editable_inline" },
          });
          this._generateLabel = o.label || (() => i("Editor editing area: %0", this.name));
        }
        render() {
          super.render();
          const t = this._editingView;
          t.change((e) => {
            const n = t.document.getRoot(this.name);
            e.setAttribute("aria-label", this._generateLabel(this), n);
          });
        }
      }
      var XE = n(668);
      var tD = { injectType: "singletonStyleTag", attributes: { "data-cke": true } };
      tD.insert = "head";
      tD.singleton = true;
      var eD = Pl()(XE.Z, tD);
      const nD = XE.Z.locals || {};
      class oD extends (null && View) {
        constructor(t, e = {}) {
          super(t);
          const n = this.bindTemplate;
          this.set("label", e.label || "");
          this.set("class", e.class || null);
          this.children = this.createCollection();
          this.setTemplate({
            tag: "div",
            attributes: { class: ["ck", "ck-form__header", n.to("class")] },
            children: this.children,
          });
          if (e.icon) {
            this.iconView = new IconView();
            this.iconView.content = e.icon;
            this.children.add(this.iconView);
          }
          const o = new View(t);
          o.setTemplate({
            tag: "h2",
            attributes: { class: ["ck", "ck-form__header__label"] },
            children: [{ text: n.to("label") }],
          });
          this.children.add(o);
        }
      }
      class iD extends (null && View) {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          this.setTemplate({
            tag: "iframe",
            attributes: {
              class: ["ck", "ck-reset_all"],
              sandbox: "allow-same-origin allow-scripts",
            },
            on: { load: e.to("loaded") },
          });
        }
        render() {
          return new Promise((t) => {
            this.on("loaded", t);
            return super.render();
          });
        }
      }
      class rD extends (null && ContextPlugin) {
        static get pluginName() {
          return "Notification";
        }
        init() {
          this.on(
            "show:warning",
            (t, e) => {
              window.alert(e.message);
            },
            { priority: "lowest" }
          );
        }
        showSuccess(t, e = {}) {
          this._showNotification({
            message: t,
            type: "success",
            namespace: e.namespace,
            title: e.title,
          });
        }
        showInfo(t, e = {}) {
          this._showNotification({
            message: t,
            type: "info",
            namespace: e.namespace,
            title: e.title,
          });
        }
        showWarning(t, e = {}) {
          this._showNotification({
            message: t,
            type: "warning",
            namespace: e.namespace,
            title: e.title,
          });
        }
        _showNotification(t) {
          const e = t.namespace ? `show:${t.type}:${t.namespace}` : `show:${t.type}`;
          this.fire(e, { message: t.message, type: t.type, title: t.title || "" });
        }
      }
      class sD extends lt() {
        constructor(t, e) {
          super();
          if (e) {
            cm(this, e);
          }
          if (t) {
            this.set(t);
          }
        }
      }
      var aD = n(592);
      var cD = { injectType: "singletonStyleTag", attributes: { "data-cke": true } };
      cD.insert = "head";
      cD.singleton = true;
      var lD = Pl()(aD.Z, cD);
      const dD = aD.Z.locals || {};
      var hD = n(356);
      var uD = { injectType: "singletonStyleTag", attributes: { "data-cke": true } };
      uD.insert = "head";
      uD.singleton = true;
      var fD = Pl()(hD.Z, uD);
      const pD = hD.Z.locals || {};
      const gD = mc("px");
      class mD extends (null && Plugin) {
        static get pluginName() {
          return "ContextualBalloon";
        }
        constructor(t) {
          super(t);
          this._viewToStack = new Map();
          this._idToStack = new Map();
          this._view = null;
          this._rotatorView = null;
          this._fakePanelsView = null;
          this.positionLimiter = () => {
            const t = this.editor.editing.view;
            const e = t.document;
            const n = e.selection.editableElement;
            if (n) {
              return t.domConverter.mapViewToDom(n.root);
            }
            return null;
          };
          this.set("visibleView", null);
          this.set("_numberOfStacks", 0);
          this.set("_singleViewMode", false);
        }
        destroy() {
          super.destroy();
          if (this._view) {
            this._view.destroy();
          }
          if (this._rotatorView) {
            this._rotatorView.destroy();
          }
          if (this._fakePanelsView) {
            this._fakePanelsView.destroy();
          }
        }
        get view() {
          if (!this._view) {
            this._createPanelView();
          }
          return this._view;
        }
        hasView(t) {
          return Array.from(this._viewToStack.keys()).includes(t);
        }
        add(t) {
          if (!this._view) {
            this._createPanelView();
          }
          if (this.hasView(t.view)) {
            throw new CKEditorError("contextualballoon-add-view-exist", [this, t]);
          }
          const e = t.stackId || "main";
          if (!this._idToStack.has(e)) {
            this._idToStack.set(e, new Map([[t.view, t]]));
            this._viewToStack.set(t.view, this._idToStack.get(e));
            this._numberOfStacks = this._idToStack.size;
            if (!this._visibleStack || t.singleViewMode) {
              this.showStack(e);
            }
            return;
          }
          const n = this._idToStack.get(e);
          if (t.singleViewMode) {
            this.showStack(e);
          }
          n.set(t.view, t);
          this._viewToStack.set(t.view, n);
          if (n === this._visibleStack) {
            this._showView(t);
          }
        }
        remove(t) {
          if (!this.hasView(t)) {
            throw new CKEditorError("contextualballoon-remove-view-not-exist", [this, t]);
          }
          const e = this._viewToStack.get(t);
          if (this._singleViewMode && this.visibleView === t) {
            this._singleViewMode = false;
          }
          if (this.visibleView === t) {
            if (e.size === 1) {
              if (this._idToStack.size > 1) {
                this._showNextStack();
              } else {
                this.view.hide();
                this.visibleView = null;
                this._rotatorView.hideView();
              }
            } else {
              this._showView(Array.from(e.values())[e.size - 2]);
            }
          }
          if (e.size === 1) {
            this._idToStack.delete(this._getStackId(e));
            this._numberOfStacks = this._idToStack.size;
          } else {
            e.delete(t);
          }
          this._viewToStack.delete(t);
        }
        updatePosition(t) {
          if (t) {
            this._visibleStack.get(this.visibleView).position = t;
          }
          this.view.pin(this._getBalloonPosition());
          this._fakePanelsView.updatePosition();
        }
        showStack(t) {
          this.visibleStack = t;
          const e = this._idToStack.get(t);
          if (!e) {
            throw new CKEditorError("contextualballoon-showstack-stack-not-exist", this);
          }
          if (this._visibleStack === e) {
            return;
          }
          this._showView(Array.from(e.values()).pop());
        }
        _createPanelView() {
          this._view = new BalloonPanelView(this.editor.locale);
          this.editor.ui.view.body.add(this._view);
          this.editor.ui.focusTracker.add(this._view.element);
          this._rotatorView = this._createRotatorView();
          this._fakePanelsView = this._createFakePanelsView();
        }
        get _visibleStack() {
          return this._viewToStack.get(this.visibleView);
        }
        _getStackId(t) {
          const e = Array.from(this._idToStack.entries()).find((e) => e[1] === t);
          return e[0];
        }
        _showNextStack() {
          const t = Array.from(this._idToStack.values());
          let e = t.indexOf(this._visibleStack) + 1;
          if (!t[e]) {
            e = 0;
          }
          this.showStack(this._getStackId(t[e]));
        }
        _showPrevStack() {
          const t = Array.from(this._idToStack.values());
          let e = t.indexOf(this._visibleStack) - 1;
          if (!t[e]) {
            e = t.length - 1;
          }
          this.showStack(this._getStackId(t[e]));
        }
        _createRotatorView() {
          const t = new kD(this.editor.locale);
          const e = this.editor.locale.t;
          this.view.content.add(t);
          t.bind("isNavigationVisible").to(
            this,
            "_numberOfStacks",
            this,
            "_singleViewMode",
            (t, e) => !e && t > 1
          );
          t.on("change:isNavigationVisible", () => this.updatePosition(), { priority: "low" });
          t.bind("counter").to(this, "visibleView", this, "_numberOfStacks", (t, n) => {
            if (n < 2) {
              return "";
            }
            const o = Array.from(this._idToStack.values()).indexOf(this._visibleStack) + 1;
            return e("%0 of %1", [o, n]);
          });
          t.buttonNextView.on("execute", () => {
            if (t.focusTracker.isFocused) {
              this.editor.editing.view.focus();
            }
            this._showNextStack();
          });
          t.buttonPrevView.on("execute", () => {
            if (t.focusTracker.isFocused) {
              this.editor.editing.view.focus();
            }
            this._showPrevStack();
          });
          return t;
        }
        _createFakePanelsView() {
          const t = new bD(this.editor.locale, this.view);
          t.bind("numberOfPanels").to(this, "_numberOfStacks", this, "_singleViewMode", (t, e) => {
            const n = !e && t >= 2;
            return n ? Math.min(t - 1, 2) : 0;
          });
          t.listenTo(this.view, "change:top", () => t.updatePosition());
          t.listenTo(this.view, "change:left", () => t.updatePosition());
          this.editor.ui.view.body.add(t);
          return t;
        }
        _showView({
          view: t,
          balloonClassName: e = "",
          withArrow: n = true,
          singleViewMode: o = false,
        }) {
          this.view.class = e;
          this.view.withArrow = n;
          this._rotatorView.showView(t);
          this.visibleView = t;
          this.view.pin(this._getBalloonPosition());
          this._fakePanelsView.updatePosition();
          if (o) {
            this._singleViewMode = true;
          }
        }
        _getBalloonPosition() {
          let t = Array.from(this._visibleStack.values()).pop().position;
          if (t) {
            if (!t.limiter) {
              t = Object.assign({}, t, { limiter: this.positionLimiter });
            }
            t = Object.assign({}, t, { viewportOffsetConfig: this.editor.ui.viewportOffset });
          }
          return t;
        }
      }
      class kD extends (null && View) {
        constructor(t) {
          super(t);
          const e = t.t;
          const n = this.bindTemplate;
          this.set("isNavigationVisible", true);
          this.focusTracker = new FocusTracker();
          this.buttonPrevView = this._createButtonView(e("Previous"), prevIcon);
          this.buttonNextView = this._createButtonView(e("Next"), nextIcon);
          this.content = this.createCollection();
          this.setTemplate({
            tag: "div",
            attributes: { class: ["ck", "ck-balloon-rotator"], "z-index": "-1" },
            children: [
              {
                tag: "div",
                attributes: {
                  class: [
                    "ck-balloon-rotator__navigation",
                    n.to("isNavigationVisible", (t) => (t ? "" : "ck-hidden")),
                  ],
                },
                children: [
                  this.buttonPrevView,
                  {
                    tag: "span",
                    attributes: { class: ["ck-balloon-rotator__counter"] },
                    children: [{ text: n.to("counter") }],
                  },
                  this.buttonNextView,
                ],
              },
              {
                tag: "div",
                attributes: { class: "ck-balloon-rotator__content" },
                children: this.content,
              },
            ],
          });
        }
        render() {
          super.render();
          this.focusTracker.add(this.element);
        }
        destroy() {
          super.destroy();
          this.focusTracker.destroy();
        }
        showView(t) {
          this.hideView();
          this.content.add(t);
        }
        hideView() {
          this.content.clear();
        }
        _createButtonView(t, e) {
          const n = new ButtonView(this.locale);
          n.set({ label: t, icon: e, tooltip: true });
          return n;
        }
      }
      class bD extends (null && View) {
        constructor(t, e) {
          super(t);
          const n = this.bindTemplate;
          this.set("top", 0);
          this.set("left", 0);
          this.set("height", 0);
          this.set("width", 0);
          this.set("numberOfPanels", 0);
          this.content = this.createCollection();
          this._balloonPanelView = e;
          this.setTemplate({
            tag: "div",
            attributes: {
              class: ["ck-fake-panel", n.to("numberOfPanels", (t) => (t ? "" : "ck-hidden"))],
              style: {
                top: n.to("top", gD),
                left: n.to("left", gD),
                width: n.to("width", gD),
                height: n.to("height", gD),
              },
            },
            children: this.content,
          });
          this.on("change:numberOfPanels", (t, e, n, o) => {
            if (n > o) {
              this._addPanels(n - o);
            } else {
              this._removePanels(o - n);
            }
            this.updatePosition();
          });
        }
        _addPanels(t) {
          while (t--) {
            const t = new View();
            t.setTemplate({ tag: "div" });
            this.content.add(t);
            this.registerChild(t);
          }
        }
        _removePanels(t) {
          while (t--) {
            const t = this.content.last;
            this.content.remove(t);
            this.deregisterChild(t);
            t.destroy();
          }
        }
        updatePosition() {
          if (this.numberOfPanels) {
            const { top: t, left: e } = this._balloonPanelView;
            const { width: n, height: o } = new Rect(this._balloonPanelView.element);
            Object.assign(this, { top: t, left: e, width: n, height: o });
          }
        }
      }
      var wD = n(707);
      var _D = { injectType: "singletonStyleTag", attributes: { "data-cke": true } };
      _D.insert = "head";
      _D.singleton = true;
      var vD = Pl()(wD.Z, _D);
      const AD = wD.Z.locals || {};
      const CD = mc("px");
      class yD extends zl {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          this.set("isActive", false);
          this.set("isSticky", false);
          this.set("limiterElement", null);
          this.set("limiterBottomOffset", 50);
          this.set("viewportTopOffset", 0);
          this.set("_marginLeft", null);
          this.set("_isStickyToTheBottomOfLimiter", false);
          this.set("_stickyTopOffset", null);
          this.set("_stickyBottomOffset", null);
          this.content = this.createCollection();
          this._contentPanelPlaceholder = new Ml({
            tag: "div",
            attributes: {
              class: ["ck", "ck-sticky-panel__placeholder"],
              style: {
                display: e.to("isSticky", (t) => (t ? "block" : "none")),
                height: e.to("isSticky", (t) => (t ? CD(this._contentPanelRect.height) : null)),
              },
            },
          }).render();
          this._contentPanel = new Ml({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-sticky-panel__content",
                e.if("isSticky", "ck-sticky-panel__content_sticky"),
                e.if(
                  "_isStickyToTheBottomOfLimiter",
                  "ck-sticky-panel__content_sticky_bottom-limit"
                ),
              ],
              style: {
                width: e.to("isSticky", (t) =>
                  t ? CD(this._contentPanelPlaceholder.getBoundingClientRect().width) : null
                ),
                top: e.to("_stickyTopOffset", (t) => (t ? CD(t) : t)),
                bottom: e.to("_stickyBottomOffset", (t) => (t ? CD(t) : t)),
                marginLeft: e.to("_marginLeft"),
              },
            },
            children: this.content,
          }).render();
          this.setTemplate({
            tag: "div",
            attributes: { class: ["ck", "ck-sticky-panel"] },
            children: [this._contentPanelPlaceholder, this._contentPanel],
          });
        }
        render() {
          super.render();
          this.checkIfShouldBeSticky();
          this.listenTo(
            Qa.document,
            "scroll",
            () => {
              this.checkIfShouldBeSticky();
            },
            { useCapture: true }
          );
          this.listenTo(this, "change:isActive", () => {
            this.checkIfShouldBeSticky();
          });
        }
        checkIfShouldBeSticky() {
          if (!this.limiterElement || !this.isActive) {
            this._unstick();
            return;
          }
          const t = new ac(this.limiterElement);
          let e = t.getVisible();
          if (e) {
            const t = new ac(Qa.window);
            t.top += this.viewportTopOffset;
            t.height -= this.viewportTopOffset;
            e = e.getIntersection(t);
          }
          if (e && t.top < e.top) {
            const n = e.top;
            if (n + this._contentPanelRect.height + this.limiterBottomOffset > e.bottom) {
              const n = Math.max(t.bottom - e.bottom, 0) + this.limiterBottomOffset;
              if (t.bottom - n > t.top + this._contentPanelRect.height) {
                this._stickToBottomOfLimiter(n);
              } else {
                this._unstick();
              }
            } else {
              if (this._contentPanelRect.height + this.limiterBottomOffset < t.height) {
                this._stickToTopOfAncestors(n);
              } else {
                this._unstick();
              }
            }
          } else {
            this._unstick();
          }
        }
        _stickToTopOfAncestors(t) {
          this.isSticky = true;
          this._isStickyToTheBottomOfLimiter = false;
          this._stickyTopOffset = t;
          this._stickyBottomOffset = null;
          this._marginLeft = CD(-Qa.window.scrollX);
        }
        _stickToBottomOfLimiter(t) {
          this.isSticky = true;
          this._isStickyToTheBottomOfLimiter = true;
          this._stickyTopOffset = null;
          this._stickyBottomOffset = t;
          this._marginLeft = CD(-Qa.window.scrollX);
        }
        _unstick() {
          this.isSticky = false;
          this._isStickyToTheBottomOfLimiter = false;
          this._stickyTopOffset = null;
          this._stickyBottomOffset = null;
          this._marginLeft = null;
        }
        get _contentPanelRect() {
          return new ac(this._contentPanel);
        }
      }
      class xD extends Eh {
        constructor(t, e) {
          const n = t.t;
          const o = Object.assign({}, { showResetButton: true, showIcon: true, creator: zy }, e);
          super(t, o.creator);
          this.label = e.label;
          this._viewConfig = o;
          if (this._viewConfig.showIcon) {
            this.iconView = new gd();
            this.iconView.content = jC.loupe;
            this.fieldWrapperChildren.add(this.iconView, 0);
            this.extendTemplate({ attributes: { class: "ck-search__query_with-icon" } });
          }
          if (this._viewConfig.showResetButton) {
            this.resetButtonView = new vd(t);
            this.resetButtonView.set({
              label: n("Clear"),
              icon: jC.cancel,
              class: "ck-search__reset",
              isVisible: false,
              tooltip: true,
            });
            this.resetButtonView.on("execute", () => {
              this.reset();
              this.focus();
              this.fire("reset");
            });
            this.resetButtonView.bind("isVisible").to(this.fieldView, "isEmpty", (t) => !t);
            this.fieldWrapperChildren.add(this.resetButtonView);
            this.extendTemplate({ attributes: { class: "ck-search__query_with-reset" } });
          }
        }
        reset() {
          this.fieldView.reset();
          if (this._viewConfig.showResetButton) {
            this.resetButtonView.isVisible = false;
          }
        }
      }
      class ED extends zl {
        constructor() {
          super();
          const t = this.bindTemplate;
          this.set({ isVisible: false, primaryText: "", secondaryText: "" });
          this.setTemplate({
            tag: "div",
            attributes: {
              class: ["ck", "ck-search__info", t.if("isVisible", "ck-hidden", (t) => !t)],
              tabindex: -1,
            },
            children: [
              { tag: "span", children: [{ text: [t.to("primaryText")] }] },
              { tag: "span", children: [{ text: [t.to("secondaryText")] }] },
            ],
          });
        }
        focus() {
          this.element.focus();
        }
      }
      class DD extends zl {
        constructor(t) {
          super(t);
          this.children = this.createCollection();
          this.focusTracker = new hl();
          this.setTemplate({
            tag: "div",
            attributes: { class: ["ck", "ck-search__results"], tabindex: -1 },
            children: this.children,
          });
          this._focusCycler = new Jh({
            focusables: this.children,
            focusTracker: this.focusTracker,
          });
        }
        render() {
          super.render();
          for (const t of this.children) {
            this.focusTracker.add(t.element);
          }
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        focusFirst() {
          this._focusCycler.focusFirst();
        }
        focusLast() {
          this._focusCycler.focusLast();
        }
      }
      var SD = /[\\^$.*+?()[\]{}|]/g,
        TD = RegExp(SD.source);
      function PD(t) {
        t = hf(t);
        return t && TD.test(t) ? t.replace(SD, "\\$&") : t;
      }
      const BD = PD;
      var OD = n(332);
      var RD = { injectType: "singletonStyleTag", attributes: { "data-cke": true } };
      RD.insert = "head";
      RD.singleton = true;
      var ID = Pl()(OD.Z, RD);
      const zD = OD.Z.locals || {};
      class FD extends zl {
        constructor(t, e) {
          super(t);
          this._config = e;
          this.filteredView = e.filteredView;
          this.queryView = this._createSearchTextQueryView();
          this.focusTracker = new hl();
          this.keystrokes = new ul();
          this.resultsView = new DD(t);
          this.children = this.createCollection();
          this.focusableChildren = this.createCollection([this.queryView, this.resultsView]);
          this.set("isEnabled", true);
          this.set("resultsCount", 0);
          this.set("totalItemsCount", 0);
          if (e.infoView && e.infoView.instance) {
            this.infoView = e.infoView.instance;
          } else {
            this.infoView = new ED();
            this._enableDefaultInfoViewBehavior();
            this.on("render", () => {
              this.search("");
            });
          }
          this.resultsView.children.addMany([this.infoView, this.filteredView]);
          this.focusCycler = new Jh({
            focusables: this.focusableChildren,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: { focusPrevious: "shift + tab", focusNext: "tab" },
          });
          this.on("search", (t, { resultsCount: e, totalItemsCount: n }) => {
            this.resultsCount = e;
            this.totalItemsCount = n;
          });
          this.setTemplate({
            tag: "div",
            attributes: { class: ["ck", "ck-search", e.class || null], tabindex: "-1" },
            children: this.children,
          });
        }
        render() {
          super.render();
          this.children.addMany([this.queryView, this.resultsView]);
          const t = (t) => t.stopPropagation();
          for (const t of this.focusableChildren) {
            this.focusTracker.add(t.element);
          }
          this.keystrokes.listenTo(this.element);
          this.keystrokes.set("arrowright", t);
          this.keystrokes.set("arrowleft", t);
          this.keystrokes.set("arrowup", t);
          this.keystrokes.set("arrowdown", t);
        }
        focus() {
          this.queryView.focus();
        }
        reset() {
          this.queryView.reset();
          this.search("");
        }
        search(t) {
          const e = t ? new RegExp(BD(t), "ig") : null;
          const n = this.filteredView.filter(e);
          this.fire("search", { query: t, ...n });
        }
        _createSearchTextQueryView() {
          const t = new xD(this.locale, this._config.queryView);
          this.listenTo(t.fieldView, "input", () => {
            this.search(t.fieldView.element.value);
          });
          t.on("reset", () => this.reset());
          t.bind("isEnabled").to(this);
          return t;
        }
        _enableDefaultInfoViewBehavior() {
          const t = this.locale.t;
          const e = this.infoView;
          this.on("search", (o, i) => {
            if (!i.resultsCount) {
              const o = this._config.infoView && this._config.infoView.text;
              let r, s;
              if (i.totalItemsCount) {
                if (o && o.notFound) {
                  r = o.notFound.primary;
                  s = o.notFound.secondary;
                } else {
                  r = t("No results found");
                  s = "";
                }
              } else {
                if (o && o.noSearchableItems) {
                  r = o.noSearchableItems.primary;
                  s = o.noSearchableItems.secondary;
                } else {
                  r = t("No searchable items");
                  s = "";
                }
              }
              e.set({ primaryText: n(r, i), secondaryText: n(s, i), isVisible: true });
            } else {
              e.set({ isVisible: false });
            }
          });
          function n(t, { query: e, resultsCount: n, totalItemsCount: o }) {
            return typeof t === "function" ? t(e, n, o) : t;
          }
        }
      }
      var MD = n(29);
      var ND = { injectType: "singletonStyleTag", attributes: { "data-cke": true } };
      ND.insert = "head";
      ND.singleton = true;
      var VD = Pl()(MD.Z, ND);
      const LD = MD.Z.locals || {};
      class HD extends FD {
        constructor(t, e) {
          super(t, e);
          this._config = e;
          const n = mc("px");
          this.extendTemplate({ attributes: { class: ["ck-autocomplete"] } });
          const o = this.resultsView.bindTemplate;
          this.resultsView.set("isVisible", false);
          this.resultsView.set("_position", "s");
          this.resultsView.set("_width", 0);
          this.resultsView.extendTemplate({
            attributes: {
              class: [
                o.if("isVisible", "ck-hidden", (t) => !t),
                o.to("_position", (t) => `ck-search__results_${t}`),
              ],
              style: { width: o.to("_width", n) },
            },
          });
          this.focusTracker.on("change:isFocused", (t, n, o) => {
            this._updateResultsVisibility();
            if (o) {
              this.resultsView.element.scrollTop = 0;
            } else if (e.resetOnBlur) {
              this.queryView.reset();
            }
          });
          this.on("search", () => {
            this._updateResultsVisibility();
            this._updateResultsViewWidthAndPosition();
          });
          this.keystrokes.set("esc", (t, e) => {
            this.resultsView.isVisible = false;
            e();
          });
          this.listenTo(Qa.document, "scroll", () => {
            this._updateResultsViewWidthAndPosition();
          });
          this.on("change:isEnabled", () => {
            this._updateResultsVisibility();
          });
          this.filteredView.on("execute", (t, { value: e }) => {
            this.focus();
            this.reset();
            this.queryView.fieldView.value = this.queryView.fieldView.element.value = e;
            this.resultsView.isVisible = false;
          });
          this.resultsView.on("change:isVisible", () => {
            this._updateResultsViewWidthAndPosition();
          });
        }
        _updateResultsViewWidthAndPosition() {
          if (!this.resultsView.isVisible) {
            return;
          }
          this.resultsView._width = new ac(this.queryView.fieldView.element).width;
          const t = HD._getOptimalPosition({
            element: this.resultsView.element,
            target: this.queryView.element,
            fitInViewport: true,
            positions: HD.defaultResultsPositions,
          });
          this.resultsView._position = t ? t.name : "s";
        }
        _updateResultsVisibility() {
          const t =
            typeof this._config.queryMinChars === "undefined" ? 0 : this._config.queryMinChars;
          const e = this.queryView.fieldView.element.value.length;
          this.resultsView.isVisible = this.focusTracker.isFocused && this.isEnabled && e >= t;
        }
      }
      HD.defaultResultsPositions = [
        (t) => ({ top: t.bottom, left: t.left, name: "s" }),
        (t, e) => ({ top: t.top - e.height, left: t.left, name: "n" }),
      ];
      HD._getOptimalPosition = Ac;
      var jD = n(746);
      var qD = { injectType: "singletonStyleTag", attributes: { "data-cke": true } };
      qD.insert = "head";
      qD.singleton = true;
      var $D = Pl()(jD.Z, qD);
      const WD = jD.Z.locals || {};
      class GD extends (null && View) {
        constructor() {
          super();
          this.set("text", undefined);
          this.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-highlighted-text"] } });
          this.on("render", () => {
            this.on("change:text", () => {
              this._updateInnerHTML(this.text);
            });
            this._updateInnerHTML(this.text);
          });
        }
        highlightText(t) {
          this._updateInnerHTML(KD(this.text || "", t));
        }
        _updateInnerHTML(t) {
          this.element.innerHTML = t || "";
        }
      }
      function KD(t, e) {
        if (!e) {
          return escape(t);
        }
        const n = [];
        let o = 0;
        let i = e.exec(t);
        while (i !== null) {
          const r = i.index;
          if (r !== o) {
            n.push({ text: t.substring(o, r), isMatch: false });
          }
          n.push({ text: i[0], isMatch: true });
          o = e.lastIndex;
          i = e.exec(t);
        }
        if (o !== t.length) {
          n.push({ text: t.substring(o), isMatch: false });
        }
        const r = n
          .map((t) => {
            t.text = escape(t.text);
            return t;
          })
          .map((t) => (t.isMatch ? `<mark>${t.text}</mark>` : t.text))
          .join("");
        return r;
      }
      var UD = n(446);
      var ZD = { injectType: "singletonStyleTag", attributes: { "data-cke": true } };
      ZD.insert = "head";
      ZD.singleton = true;
      var JD = Pl()(UD.Z, ZD);
      const YD = UD.Z.locals || {};
      class QD extends (null && View) {
        constructor() {
          super();
          this.set("isVisible", false);
          const t = this.bindTemplate;
          this.setTemplate({
            tag: "span",
            attributes: {
              class: ["ck", "ck-spinner-container", t.if("isVisible", "ck-hidden", (t) => !t)],
            },
            children: [{ tag: "span", attributes: { class: ["ck", "ck-spinner"] } }],
          });
        }
      }
      const XD = mc("px");
      class tS extends (null && Plugin) {
        static get pluginName() {
          return "BalloonToolbar";
        }
        static get requires() {
          return [ContextualBalloon];
        }
        constructor(t) {
          super(t);
          this._resizeObserver = null;
          this._balloonConfig = normalizeToolbarConfig(t.config.get("balloonToolbar"));
          this.toolbarView = this._createToolbarView();
          this.focusTracker = new FocusTracker();
          t.ui.once("ready", () => {
            this.focusTracker.add(t.ui.getEditableElement());
            this.focusTracker.add(this.toolbarView.element);
          });
          t.ui.addToolbar(this.toolbarView, {
            beforeFocus: () => this.show(true),
            afterBlur: () => this.hide(),
            isContextual: true,
          });
          this._balloon = t.plugins.get(ContextualBalloon);
          this._fireSelectionChangeDebounced = debounce(
            () => this.fire("_selectionChangeDebounced"),
            200
          );
          this.decorate("show");
        }
        init() {
          const t = this.editor;
          const e = t.model.document.selection;
          this.listenTo(this.focusTracker, "change:isFocused", (t, e, n) => {
            const o = this._balloon.visibleView === this.toolbarView;
            if (!n && o) {
              this.hide();
            } else if (n) {
              this.show();
            }
          });
          this.listenTo(e, "change:range", (t, n) => {
            if (n.directChange || e.isCollapsed) {
              this.hide();
            }
            this._fireSelectionChangeDebounced();
          });
          this.listenTo(this, "_selectionChangeDebounced", () => {
            if (this.editor.editing.view.document.isFocused) {
              this.show();
            }
          });
          if (!this._balloonConfig.shouldNotGroupWhenFull) {
            this.listenTo(t, "ready", () => {
              const e = t.ui.view.editable.element;
              this._resizeObserver = new ResizeObserver(e, (t) => {
                this.toolbarView.maxWidth = XD(t.contentRect.width * 0.9);
              });
            });
          }
          this.listenTo(this.toolbarView, "groupedItemsUpdate", () => {
            this._updatePosition();
          });
        }
        afterInit() {
          const t = this.editor.ui.componentFactory;
          this.toolbarView.fillFromConfig(this._balloonConfig, t);
        }
        _createToolbarView() {
          const t = this.editor.locale.t;
          const e = !this._balloonConfig.shouldNotGroupWhenFull;
          const n = new ToolbarView(this.editor.locale, {
            shouldGroupWhenFull: e,
            isFloating: true,
          });
          n.ariaLabel = t("Editor contextual toolbar");
          n.render();
          return n;
        }
        show(t = false) {
          const e = this.editor;
          const n = e.model.document.selection;
          const o = e.model.schema;
          if (this._balloon.hasView(this.toolbarView)) {
            return;
          }
          if (n.isCollapsed && !t) {
            return;
          }
          if (eS(n, o)) {
            return;
          }
          if (
            Array.from(this.toolbarView.items).every(
              (t) => t.isEnabled !== undefined && !t.isEnabled
            )
          ) {
            return;
          }
          this.listenTo(this.editor.ui, "update", () => {
            this._updatePosition();
          });
          this._balloon.add({
            view: this.toolbarView,
            position: this._getBalloonPositionData(),
            balloonClassName: "ck-toolbar-container",
          });
        }
        hide() {
          if (this._balloon.hasView(this.toolbarView)) {
            this.stopListening(this.editor.ui, "update");
            this._balloon.remove(this.toolbarView);
          }
        }
        _getBalloonPositionData() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document;
          const o = n.selection;
          const i = n.selection.isBackward;
          return {
            target: () => {
              const t = i ? o.getFirstRange() : o.getLastRange();
              const n = Rect.getDomRangeRects(e.domConverter.viewRangeToDom(t));
              if (i) {
                return n[0];
              } else {
                if (n.length > 1 && n[n.length - 1].width === 0) {
                  n.pop();
                }
                return n[n.length - 1];
              }
            },
            positions: this._getBalloonPositions(i),
          };
        }
        _updatePosition() {
          this._balloon.updatePosition(this._getBalloonPositionData());
        }
        destroy() {
          super.destroy();
          this.stopListening();
          this._fireSelectionChangeDebounced.cancel();
          this.toolbarView.destroy();
          this.focusTracker.destroy();
          if (this._resizeObserver) {
            this._resizeObserver.destroy();
          }
        }
        _getBalloonPositions(t) {
          const e = env.isSafari && env.isiOS;
          const n = e
            ? generatePositions({
                heightOffset: Math.max(
                  BalloonPanelView.arrowHeightOffset,
                  Math.round(20 / global.window.visualViewport.scale)
                ),
              })
            : BalloonPanelView.defaultPositions;
          return t
            ? [
                n.northWestArrowSouth,
                n.northWestArrowSouthWest,
                n.northWestArrowSouthEast,
                n.northWestArrowSouthMiddleEast,
                n.northWestArrowSouthMiddleWest,
                n.southWestArrowNorth,
                n.southWestArrowNorthWest,
                n.southWestArrowNorthEast,
                n.southWestArrowNorthMiddleWest,
                n.southWestArrowNorthMiddleEast,
              ]
            : [
                n.southEastArrowNorth,
                n.southEastArrowNorthEast,
                n.southEastArrowNorthWest,
                n.southEastArrowNorthMiddleEast,
                n.southEastArrowNorthMiddleWest,
                n.northEastArrowSouth,
                n.northEastArrowSouthEast,
                n.northEastArrowSouthWest,
                n.northEastArrowSouthMiddleEast,
                n.northEastArrowSouthMiddleWest,
              ];
        }
      }
      function eS(t, e) {
        if (t.rangeCount === 1) {
          return false;
        }
        return [...t.getRanges()].every((t) => {
          const n = t.getContainedElement();
          return n && e.isSelectable(n);
        });
      }
      var nS = n(176);
      var oS = { injectType: "singletonStyleTag", attributes: { "data-cke": true } };
      oS.insert = "head";
      oS.singleton = true;
      var iS = Pl()(nS.Z, oS);
      const rS = nS.Z.locals || {};
      const sS = mc("px");
      class aS extends (null && ButtonView) {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          this.isVisible = false;
          this.isToggleable = true;
          this.set("top", 0);
          this.set("left", 0);
          this.extendTemplate({
            attributes: {
              class: "ck-block-toolbar-button",
              style: { top: e.to("top", (t) => sS(t)), left: e.to("left", (t) => sS(t)) },
            },
          });
        }
      }
      const cS = mc("px");
      class lS extends (null && Plugin) {
        static get pluginName() {
          return "BlockToolbar";
        }
        constructor(t) {
          super(t);
          this._resizeObserver = null;
          this._blockToolbarConfig = normalizeToolbarConfig(this.editor.config.get("blockToolbar"));
          this.toolbarView = this._createToolbarView();
          this.panelView = this._createPanelView();
          this.buttonView = this._createButtonView();
          clickOutsideHandler({
            emitter: this.panelView,
            contextElements: [this.panelView.element, this.buttonView.element],
            activator: () => this.panelView.isVisible,
            callback: () => this._hidePanel(),
          });
        }
        init() {
          const t = this.editor;
          const e = t.t;
          const n = e("Click to edit block");
          const o = e("Drag to move");
          const i = e("Edit block");
          const r = t.plugins.has("DragDropBlockToolbar");
          const s = r ? `${n}\n${o}` : i;
          this.buttonView.label = s;
          if (r) {
            this.buttonView.element.dataset.ckeTooltipClass = "ck-tooltip_multi-line";
          }
          this.listenTo(t.model.document.selection, "change:range", (t, e) => {
            if (e.directChange) {
              this._hidePanel();
            }
          });
          this.listenTo(t.ui, "update", () => this._updateButton());
          this.listenTo(t, "change:isReadOnly", () => this._updateButton(), { priority: "low" });
          this.listenTo(t.ui.focusTracker, "change:isFocused", () => this._updateButton());
          this.listenTo(this.buttonView, "change:isVisible", (t, e, n) => {
            if (n) {
              this.buttonView.listenTo(window, "resize", () => this._updateButton());
            } else {
              this.buttonView.stopListening(window, "resize");
              this._hidePanel();
            }
          });
          t.ui.addToolbar(this.toolbarView, {
            beforeFocus: () => this._showPanel(),
            afterBlur: () => this._hidePanel(),
          });
        }
        afterInit() {
          this.toolbarView.fillFromConfig(
            this._blockToolbarConfig,
            this.editor.ui.componentFactory
          );
          for (const t of this.toolbarView.items) {
            t.on("execute", () => this._hidePanel(true), { priority: "high" });
          }
        }
        destroy() {
          super.destroy();
          this.panelView.destroy();
          this.buttonView.destroy();
          this.toolbarView.destroy();
          if (this._resizeObserver) {
            this._resizeObserver.destroy();
          }
        }
        _createToolbarView() {
          const t = this.editor.locale.t;
          const e = !this._blockToolbarConfig.shouldNotGroupWhenFull;
          const n = new ToolbarView(this.editor.locale, {
            shouldGroupWhenFull: e,
            isFloating: true,
          });
          n.ariaLabel = t("Editor block content toolbar");
          return n;
        }
        _createPanelView() {
          const t = this.editor;
          const e = new BalloonPanelView(t.locale);
          e.content.add(this.toolbarView);
          e.class = "ck-toolbar-container";
          t.ui.view.body.add(e);
          t.ui.focusTracker.add(e.element);
          this.toolbarView.keystrokes.set("Esc", (t, e) => {
            this._hidePanel(true);
            e();
          });
          return e;
        }
        _createButtonView() {
          const t = this.editor;
          const e = t.t;
          const n = new BlockButtonView(t.locale);
          const o = this._blockToolbarConfig.icon;
          const i = NESTED_TOOLBAR_ICONS[o] || o || NESTED_TOOLBAR_ICONS.dragIndicator;
          n.set({ label: e("Edit block"), icon: i, withText: false });
          n.bind("isOn").to(this.panelView, "isVisible");
          n.bind("tooltip").to(this.panelView, "isVisible", (t) => !t);
          this.listenTo(n, "execute", () => {
            if (!this.panelView.isVisible) {
              this._showPanel();
            } else {
              this._hidePanel(true);
            }
          });
          t.ui.view.body.add(n);
          t.ui.focusTracker.add(n.element);
          return n;
        }
        _updateButton() {
          const t = this.editor;
          const e = t.model;
          const n = t.editing.view;
          if (!t.ui.focusTracker.isFocused) {
            this._hideButton();
            return;
          }
          if (!t.model.canEditAt(t.model.document.selection)) {
            this._hideButton();
            return;
          }
          const o = Array.from(e.document.selection.getSelectedBlocks())[0];
          if (!o || Array.from(this.toolbarView.items).every((t) => !t.isEnabled)) {
            this._hideButton();
            return;
          }
          const i = n.domConverter.mapViewToDom(t.editing.mapper.toViewElement(o));
          this.buttonView.isVisible = true;
          this._setupToolbarResize();
          this._attachButtonToElement(i);
          if (this.panelView.isVisible) {
            this._showPanel();
          }
        }
        _hideButton() {
          this.buttonView.isVisible = false;
        }
        _showPanel() {
          if (!this.buttonView.isVisible) {
            return;
          }
          const t = this.panelView.isVisible;
          this.panelView.show();
          const e = this._getSelectedEditableElement();
          this.toolbarView.maxWidth = this._getToolbarMaxWidth(e);
          this.panelView.pin({ target: this.buttonView.element, limiter: e });
          if (!t) {
            this.toolbarView.items.get(0).focus();
          }
        }
        _getSelectedEditableElement() {
          const t = this.editor.model.document.selection.getFirstRange().root.rootName;
          return this.editor.ui.getEditableElement(t);
        }
        _hidePanel(t) {
          this.panelView.isVisible = false;
          if (t) {
            this.editor.editing.view.focus();
          }
        }
        _attachButtonToElement(t) {
          const e = window.getComputedStyle(t);
          const n = new Rect(this._getSelectedEditableElement());
          const o = parseInt(e.paddingTop, 10);
          const i = parseInt(e.lineHeight, 10) || parseInt(e.fontSize, 10) * 1.2;
          const r = new Rect(this.buttonView.element);
          const s = new Rect(t);
          let a;
          if (this.editor.locale.uiLanguageDirection === "ltr") {
            a = n.left - r.width;
          } else {
            a = n.right;
          }
          const c = s.top + o + (i - r.height) / 2;
          r.moveTo(a, c);
          const l = r.toAbsoluteRect();
          this.buttonView.top = l.top;
          this.buttonView.left = l.left;
        }
        _setupToolbarResize() {
          const t = this._getSelectedEditableElement();
          if (!this._blockToolbarConfig.shouldNotGroupWhenFull) {
            if (this._resizeObserver && this._resizeObserver.element !== t) {
              this._resizeObserver.destroy();
              this._resizeObserver = null;
            }
            if (!this._resizeObserver) {
              this._resizeObserver = new ResizeObserver(t, () => {
                this.toolbarView.maxWidth = this._getToolbarMaxWidth(t);
              });
            }
          }
        }
        _getToolbarMaxWidth(t) {
          const e = new Rect(t);
          const n = new Rect(this.buttonView.element);
          const o = this.editor.locale.uiLanguageDirection === "rtl";
          const i = o ? n.left - e.right + n.width : e.left - n.left;
          return cS(e.width + i);
        }
      }
      const dS = { colorPaletteIcon: Xx };
      class hS extends qE {
        constructor(t, e) {
          super(t);
          this.view = e;
          this._toolbarConfig = eu(t.config.get("toolbar"));
          this._elementReplacer = new _t();
          this.listenTo(
            t.editing.view,
            "scrollToTheSelection",
            this._handleScrollToTheSelectionWithStickyPanel.bind(this)
          );
        }
        get element() {
          return this.view.element;
        }
        init(t) {
          const e = this.editor;
          const n = this.view;
          const o = e.editing.view;
          const i = n.editable;
          const r = o.document.getRoot();
          i.name = r.rootName;
          n.render();
          const s = i.element;
          this.setEditableElement(i.name, s);
          n.editable.bind("isFocused").to(this.focusTracker);
          o.attachDomRoot(s);
          if (t) {
            this._elementReplacer.replace(t, this.element);
          }
          this._initPlaceholder();
          this._initToolbar();
          this.fire("ready");
        }
        destroy() {
          super.destroy();
          const t = this.view;
          const e = this.editor.editing.view;
          this._elementReplacer.restore();
          e.detachDomRoot(t.editable.name);
          t.destroy();
        }
        _initToolbar() {
          const t = this.view;
          t.stickyPanel.bind("isActive").to(this.focusTracker, "isFocused");
          t.stickyPanel.limiterElement = t.element;
          t.stickyPanel
            .bind("viewportTopOffset")
            .to(this, "viewportOffset", ({ top: t }) => t || 0);
          t.toolbar.fillFromConfig(this._toolbarConfig, this.componentFactory);
          this.addToolbar(t.toolbar);
        }
        _initPlaceholder() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document.getRoot();
          const o = t.sourceElement;
          let i;
          const r = t.config.get("placeholder");
          if (r) {
            i = typeof r === "string" ? r : r[this.view.editable.name];
          }
          if (!i && o && o.tagName.toLowerCase() === "textarea") {
            i = o.getAttribute("placeholder");
          }
          if (i) {
            n.placeholder = i;
          }
          mu({ view: e, element: n, isDirectHost: false, keepOnFocus: true });
        }
        _handleScrollToTheSelectionWithStickyPanel(t, e, n) {
          const o = this.view.stickyPanel;
          if (o.isSticky) {
            const t = new ac(o.element).height;
            e.viewportOffset.top += t;
          } else {
            const t = () => {
              this.editor.editing.view.scrollToTheSelection(n);
            };
            this.listenTo(o, "change:isSticky", t);
            setTimeout(() => {
              this.stopListening(o, "change:isSticky", t);
            }, 20);
          }
        }
      }
      var uS = n(624);
      var fS = { injectType: "singletonStyleTag", attributes: { "data-cke": true } };
      fS.insert = "head";
      fS.singleton = true;
      var pS = Pl()(uS.Z, fS);
      const gS = uS.Z.locals || {};
      class mS extends JE {
        constructor(t, e, n = {}) {
          super(t);
          this.stickyPanel = new yD(t);
          this.toolbar = new ZC(t, { shouldGroupWhenFull: n.shouldToolbarGroupWhenFull });
          this.editable = new QE(t, e);
        }
        render() {
          super.render();
          this.stickyPanel.content.add(this.toolbar);
          this.top.add(this.stickyPanel);
          this.main.add(this.editable);
        }
      }
      class kS {
        constructor(t) {
          this.crashes = [];
          this.state = "initializing";
          this._now = Date.now;
          this.crashes = [];
          this._crashNumberLimit = typeof t.crashNumberLimit === "number" ? t.crashNumberLimit : 3;
          this._minimumNonErrorTimePeriod =
            typeof t.minimumNonErrorTimePeriod === "number" ? t.minimumNonErrorTimePeriod : 5e3;
          this._boundErrorHandler = (t) => {
            const e = "error" in t ? t.error : t.reason;
            if (e instanceof Error) {
              this._handleError(e, t);
            }
          };
          this._listeners = {};
          if (!this._restart) {
            throw new Error(
              "The Watchdog class was split into the abstract `Watchdog` class and the `EditorWatchdog` class. " +
                "Please, use `EditorWatchdog` if you have used the `Watchdog` class previously."
            );
          }
        }
        destroy() {
          this._stopErrorHandling();
          this._listeners = {};
        }
        on(t, e) {
          if (!this._listeners[t]) {
            this._listeners[t] = [];
          }
          this._listeners[t].push(e);
        }
        off(t, e) {
          this._listeners[t] = this._listeners[t].filter((t) => t !== e);
        }
        _fire(t, ...e) {
          const n = this._listeners[t] || [];
          for (const t of n) {
            t.apply(this, [null, ...e]);
          }
        }
        _startErrorHandling() {
          window.addEventListener("error", this._boundErrorHandler);
          window.addEventListener("unhandledrejection", this._boundErrorHandler);
        }
        _stopErrorHandling() {
          window.removeEventListener("error", this._boundErrorHandler);
          window.removeEventListener("unhandledrejection", this._boundErrorHandler);
        }
        _handleError(t, e) {
          if (this._shouldReactToError(t)) {
            this.crashes.push({
              message: t.message,
              stack: t.stack,
              filename: e instanceof ErrorEvent ? e.filename : undefined,
              lineno: e instanceof ErrorEvent ? e.lineno : undefined,
              colno: e instanceof ErrorEvent ? e.colno : undefined,
              date: this._now(),
            });
            const n = this._shouldRestart();
            this.state = "crashed";
            this._fire("stateChange");
            this._fire("error", { error: t, causesRestart: n });
            if (n) {
              this._restart();
            } else {
              this.state = "crashedPermanently";
              this._fire("stateChange");
            }
          }
        }
        _shouldReactToError(t) {
          return (
            t.is &&
            t.is("CKEditorError") &&
            t.context !== undefined &&
            t.context !== null &&
            this.state === "ready" &&
            this._isErrorComingFromThisItem(t)
          );
        }
        _shouldRestart() {
          if (this.crashes.length <= this._crashNumberLimit) {
            return true;
          }
          const t = this.crashes[this.crashes.length - 1].date;
          const e = this.crashes[this.crashes.length - 1 - this._crashNumberLimit].date;
          const n = (t - e) / this._crashNumberLimit;
          return n > this._minimumNonErrorTimePeriod;
        }
      }
      function bS(t, e = new Set()) {
        const n = [t];
        const o = new Set();
        let i = 0;
        while (n.length > i) {
          const t = n[i++];
          if (o.has(t) || !wS(t) || e.has(t)) {
            continue;
          }
          o.add(t);
          if (Symbol.iterator in t) {
            try {
              for (const e of t) {
                n.push(e);
              }
            } catch (t) {}
          } else {
            for (const e in t) {
              if (e === "defaultValue") {
                continue;
              }
              n.push(t[e]);
            }
          }
        }
        return o;
      }
      function wS(t) {
        const e = Object.prototype.toString.call(t);
        const n = typeof t;
        return !(
          n === "number" ||
          n === "boolean" ||
          n === "string" ||
          n === "symbol" ||
          n === "function" ||
          e === "[object Date]" ||
          e === "[object RegExp]" ||
          e === "[object Module]" ||
          t === undefined ||
          t === null ||
          t._watchdogExcluded ||
          t instanceof EventTarget ||
          t instanceof Event
        );
      }
      function _S(t, e, n = new Set()) {
        if (t === e && AS(t)) {
          return true;
        }
        const o = bS(t, n);
        const i = bS(e, n);
        for (const t of o) {
          if (i.has(t)) {
            return true;
          }
        }
        return false;
      }
      function vS(t, e, n) {
        const { subNodes: o, prevNodeMap: i } = getSubNodes(t, n.subNodes);
        const { subNodes: r, prevNodeMap: s } = getSubNodes(e, n.subNodes);
        for (const n of o) {
          if (r.has(n)) {
            const o = [];
            o.push(n);
            let r = i.get(n);
            while (r && r !== t) {
              o.push(r);
              r = i.get(r);
            }
            r = s.get(n);
            while (r && r !== e) {
              o.unshift(r);
              r = s.get(r);
            }
            console.log("--------");
            console.log({ target1: t });
            console.log({ sharedNode: n });
            console.log({ target2: e });
            console.log({ connection: o });
            return true;
          }
        }
        return false;
      }
      function AS(t) {
        return typeof t === "object" && t !== null;
      }
      class CS extends kS {
        constructor(t, e = {}) {
          super(e);
          this._editor = null;
          this._initUsingData = true;
          this._editables = {};
          this._throttledSave = TE(
            this._save.bind(this),
            typeof e.saveInterval === "number" ? e.saveInterval : 5e3
          );
          if (t) {
            this._creator = (e, n) => t.create(e, n);
          }
          this._destructor = (t) => t.destroy();
        }
        get editor() {
          return this._editor;
        }
        get _item() {
          return this._editor;
        }
        setCreator(t) {
          this._creator = t;
        }
        setDestructor(t) {
          this._destructor = t;
        }
        _restart() {
          return Promise.resolve()
            .then(() => {
              this.state = "initializing";
              this._fire("stateChange");
              return this._destroy();
            })
            .catch((t) => {
              console.error("An error happened during the editor destroying.", t);
            })
            .then(() => {
              const t = {};
              const e = [];
              const n = this._config.rootsAttributes || {};
              const o = {};
              for (const [i, r] of Object.entries(this._data.roots)) {
                if (r.isLoaded) {
                  t[i] = "";
                  o[i] = n[i] || {};
                } else {
                  e.push(i);
                }
              }
              const i = {
                ...this._config,
                extraPlugins: this._config.extraPlugins || [],
                lazyRoots: e,
                rootsAttributes: o,
                _watchdogInitialData: this._data,
              };
              delete i.initialData;
              i.extraPlugins.push(yS);
              if (this._initUsingData) {
                return this.create(t, i, i.context);
              } else {
                if (La(this._elementOrData)) {
                  return this.create(this._elementOrData, i, i.context);
                } else {
                  return this.create(this._editables, i, i.context);
                }
              }
            })
            .then(() => {
              this._fire("restart");
            });
        }
        create(t = this._elementOrData, e = this._config, n) {
          return Promise.resolve()
            .then(() => {
              super._startErrorHandling();
              this._elementOrData = t;
              this._initUsingData =
                typeof t == "string" ||
                (Object.keys(t).length > 0 && typeof Object.values(t)[0] == "string");
              this._config = this._cloneEditorConfiguration(e) || {};
              this._config.context = n;
              return this._creator(t, this._config);
            })
            .then((t) => {
              this._editor = t;
              t.model.document.on("change:data", this._throttledSave);
              this._lastDocumentVersion = t.model.document.version;
              this._data = this._getData();
              if (!this._initUsingData) {
                this._editables = this._getEditables();
              }
              this.state = "ready";
              this._fire("stateChange");
            });
        }
        destroy() {
          return Promise.resolve().then(() => {
            this.state = "destroyed";
            this._fire("stateChange");
            super.destroy();
            return this._destroy();
          });
        }
        _destroy() {
          return Promise.resolve().then(() => {
            this._stopErrorHandling();
            this._throttledSave.cancel();
            const t = this._editor;
            this._editor = null;
            t.model.document.off("change:data", this._throttledSave);
            return this._destructor(t);
          });
        }
        _save() {
          const t = this._editor.model.document.version;
          try {
            this._data = this._getData();
            if (!this._initUsingData) {
              this._editables = this._getEditables();
            }
            this._lastDocumentVersion = t;
          } catch (t) {
            console.error(
              t,
              "An error happened during restoring editor data. " +
                "Editor will be restored from the previously saved data."
            );
          }
        }
        _setExcludedProperties(t) {
          this._excludedProps = t;
        }
        _getData() {
          const t = this._editor;
          const e = t.model.document.roots.filter(
            (t) => t.isAttached() && t.rootName != "$graveyard"
          );
          const { plugins: n } = t;
          const o = n.has("CommentsRepository") && n.get("CommentsRepository");
          const i = n.has("TrackChanges") && n.get("TrackChanges");
          const r = {
            roots: {},
            markers: {},
            commentThreads: JSON.stringify([]),
            suggestions: JSON.stringify([]),
          };
          e.forEach((t) => {
            r.roots[t.rootName] = {
              content: JSON.stringify(Array.from(t.getChildren())),
              attributes: JSON.stringify(Array.from(t.getAttributes())),
              isLoaded: t._isLoaded,
            };
          });
          for (const e of t.model.markers) {
            if (!e._affectsData) {
              continue;
            }
            r.markers[e.name] = {
              rangeJSON: e.getRange().toJSON(),
              usingOperation: e._managedUsingOperations,
              affectsData: e._affectsData,
            };
          }
          if (o) {
            r.commentThreads = JSON.stringify(
              o.getCommentThreads({ toJSON: true, skipNotAttached: true })
            );
          }
          if (i) {
            r.suggestions = JSON.stringify(
              i.getSuggestions({ toJSON: true, skipNotAttached: true })
            );
          }
          return r;
        }
        _getEditables() {
          const t = {};
          for (const e of this.editor.model.document.getRootNames()) {
            const n = this.editor.ui.getEditableElement(e);
            if (n) {
              t[e] = n;
            }
          }
          return t;
        }
        _isErrorComingFromThisItem(t) {
          return _S(this._editor, t.context, this._excludedProps);
        }
        _cloneEditorConfiguration(t) {
          return Na(t, (t, e) => {
            if (La(t)) {
              return t;
            }
            if (e === "context") {
              return t;
            }
          });
        }
      }
      class yS {
        constructor(t) {
          this.editor = t;
          this._data = t.config.get("_watchdogInitialData");
        }
        init() {
          this.editor.data.on(
            "init",
            (t) => {
              t.stop();
              this.editor.model.enqueueChange({ isUndoable: false }, (t) => {
                this._restoreCollaborationData();
                this._restoreEditorData(t);
              });
              this.editor.data.fire("ready");
            },
            { priority: 1e3 - 1 }
          );
        }
        _createNode(t, e) {
          if ("name" in e) {
            const n = t.createElement(e.name, e.attributes);
            if (e.children) {
              for (const o of e.children) {
                n._appendChild(this._createNode(t, o));
              }
            }
            return n;
          } else {
            return t.createText(e.data, e.attributes);
          }
        }
        _restoreEditorData(t) {
          const e = this.editor;
          Object.entries(this._data.roots).forEach(([n, { content: o, attributes: i }]) => {
            const r = JSON.parse(o);
            const s = JSON.parse(i);
            const a = e.model.document.getRoot(n);
            for (const [e, n] of s) {
              t.setAttribute(e, n, a);
            }
            for (const e of r) {
              const n = this._createNode(t, e);
              t.insert(n, a, "end");
            }
          });
          Object.entries(this._data.markers).forEach(([n, o]) => {
            const { document: i } = e.model;
            const {
              rangeJSON: { start: r, end: s },
              ...a
            } = o;
            const c = i.getRoot(r.root);
            const l = t.createPositionFromPath(c, r.path, r.stickiness);
            const d = t.createPositionFromPath(c, s.path, s.stickiness);
            const h = t.createRange(l, d);
            t.addMarker(n, { range: h, ...a });
          });
        }
        _restoreCollaborationData() {
          const t = JSON.parse(this._data.commentThreads);
          const e = JSON.parse(this._data.suggestions);
          t.forEach((t) => {
            const e = this.editor.config.get("collaboration.channelId");
            const n = this.editor.plugins.get("CommentsRepository");
            if (n.hasCommentThread(t.threadId)) {
              const e = n.getCommentThread(t.threadId);
              e.remove();
            }
            n.addCommentThread({ channelId: e, ...t });
          });
          e.forEach((t) => {
            const e = this.editor.plugins.get("TrackChangesEditing");
            if (e.hasSuggestion(t.id)) {
              const n = e.getSuggestion(t.id);
              n.attributes = t.attributes;
            } else {
              e.addSuggestionData(t);
            }
          });
        }
      }
      const xS = Symbol("MainQueueId");
      class ES extends kS {
        constructor(t, e = {}) {
          super(e);
          this._watchdogs = new Map();
          this._context = null;
          this._contextProps = new Set();
          this._actionQueues = new DS();
          this._watchdogConfig = e;
          this._creator = (e) => t.create(e);
          this._destructor = (t) => t.destroy();
          this._actionQueues.onEmpty(() => {
            if (this.state === "initializing") {
              this.state = "ready";
              this._fire("stateChange");
            }
          });
        }
        setCreator(t) {
          this._creator = t;
        }
        setDestructor(t) {
          this._destructor = t;
        }
        get context() {
          return this._context;
        }
        create(t = {}) {
          return this._actionQueues.enqueue(xS, () => {
            this._contextConfig = t;
            return this._create();
          });
        }
        getItem(t) {
          const e = this._getWatchdog(t);
          return e._item;
        }
        getItemState(t) {
          const e = this._getWatchdog(t);
          return e.state;
        }
        add(t) {
          const e = SS(t);
          return Promise.all(
            e.map((t) =>
              this._actionQueues.enqueue(t.id, () => {
                if (this.state === "destroyed") {
                  throw new Error("Cannot add items to destroyed watchdog.");
                }
                if (!this._context) {
                  throw new Error(
                    "Context was not created yet. You should call the `ContextWatchdog#create()` method first."
                  );
                }
                let e;
                if (this._watchdogs.has(t.id)) {
                  throw new Error(`Item with the given id is already added: '${t.id}'.`);
                }
                if (t.type === "editor") {
                  e = new CS(null, this._watchdogConfig);
                  e.setCreator(t.creator);
                  e._setExcludedProperties(this._contextProps);
                  if (t.destructor) {
                    e.setDestructor(t.destructor);
                  }
                  this._watchdogs.set(t.id, e);
                  e.on("error", (n, { error: o, causesRestart: i }) => {
                    this._fire("itemError", { itemId: t.id, error: o });
                    if (!i) {
                      return;
                    }
                    this._actionQueues.enqueue(
                      t.id,
                      () =>
                        new Promise((n) => {
                          const o = () => {
                            e.off("restart", o);
                            this._fire("itemRestart", { itemId: t.id });
                            n();
                          };
                          e.on("restart", o);
                        })
                    );
                  });
                  return e.create(t.sourceElementOrData, t.config, this._context);
                } else {
                  throw new Error(`Not supported item type: '${t.type}'.`);
                }
              })
            )
          );
        }
        remove(t) {
          const e = SS(t);
          return Promise.all(
            e.map((t) =>
              this._actionQueues.enqueue(t, () => {
                const e = this._getWatchdog(t);
                this._watchdogs.delete(t);
                return e.destroy();
              })
            )
          );
        }
        destroy() {
          return this._actionQueues.enqueue(xS, () => {
            this.state = "destroyed";
            this._fire("stateChange");
            super.destroy();
            return this._destroy();
          });
        }
        _restart() {
          return this._actionQueues.enqueue(xS, () => {
            this.state = "initializing";
            this._fire("stateChange");
            return this._destroy()
              .catch((t) => {
                console.error("An error happened during destroying the context or items.", t);
              })
              .then(() => this._create())
              .then(() => this._fire("restart"));
          });
        }
        _create() {
          return Promise.resolve()
            .then(() => {
              this._startErrorHandling();
              return this._creator(this._contextConfig);
            })
            .then((t) => {
              this._context = t;
              this._contextProps = bS(this._context);
              return Promise.all(
                Array.from(this._watchdogs.values()).map((t) => {
                  t._setExcludedProperties(this._contextProps);
                  return t.create(undefined, undefined, this._context);
                })
              );
            });
        }
        _destroy() {
          return Promise.resolve().then(() => {
            this._stopErrorHandling();
            const t = this._context;
            this._context = null;
            this._contextProps = new Set();
            return Promise.all(Array.from(this._watchdogs.values()).map((t) => t.destroy())).then(
              () => this._destructor(t)
            );
          });
        }
        _getWatchdog(t) {
          const e = this._watchdogs.get(t);
          if (!e) {
            throw new Error(`Item with the given id was not registered: ${t}.`);
          }
          return e;
        }
        _isErrorComingFromThisItem(t) {
          for (const e of this._watchdogs.values()) {
            if (e._isErrorComingFromThisItem(t)) {
              return false;
            }
          }
          return _S(this._context, t.context);
        }
      }
      class DS {
        constructor() {
          this._onEmptyCallbacks = [];
          this._queues = new Map();
          this._activeActions = 0;
        }
        onEmpty(t) {
          this._onEmptyCallbacks.push(t);
        }
        enqueue(t, e) {
          const n = t === xS;
          this._activeActions++;
          if (!this._queues.get(t)) {
            this._queues.set(t, Promise.resolve());
          }
          const o = n
            ? Promise.all(this._queues.values())
            : Promise.all([this._queues.get(xS), this._queues.get(t)]);
          const i = o.then(e);
          const r = i.catch(() => {});
          this._queues.set(t, r);
          return i.finally(() => {
            this._activeActions--;
            if (this._queues.get(t) === r && this._activeActions === 0) {
              this._onEmptyCallbacks.forEach((t) => t());
            }
          });
        }
      }
      function SS(t) {
        return Array.isArray(t) ? t : [t];
      }
      class TS extends eC(nC(QA)) {
        constructor(t, e = {}) {
          if (!BS(t) && e.initialData !== undefined) {
            throw new P("editor-create-initial-data", null);
          }
          super(e);
          if (this.config.get("initialData") === undefined) {
            this.config.set("initialData", PS(t));
          }
          if (BS(t)) {
            this.sourceElement = t;
          }
          this.model.document.createRoot();
          const n = !this.config.get("toolbar.shouldNotGroupWhenFull");
          const o = new mS(this.locale, this.editing.view, { shouldToolbarGroupWhenFull: n });
          this.ui = new hS(this, o);
          XA(this);
        }
        destroy() {
          if (this.sourceElement) {
            this.updateSourceElement();
          }
          this.ui.destroy();
          return super.destroy();
        }
        static create(t, e = {}) {
          return new Promise((n) => {
            const o = new this(t, e);
            n(
              o
                .initPlugins()
                .then(() => o.ui.init(BS(t) ? t : null))
                .then(() => o.data.init(o.config.get("initialData")))
                .then(() => o.fire("ready"))
                .then(() => o)
            );
          });
        }
      }
      TS.Context = cu;
      TS.EditorWatchdog = CS;
      TS.ContextWatchdog = ES;
      function PS(t) {
        return BS(t) ? ec(t) : t;
      }
      function BS(t) {
        return La(t);
      }
      class OS extends iu {
        constructor(t, e) {
          super(t);
          this.attributeKey = e;
        }
        refresh() {
          const t = this.editor.model;
          const e = t.document;
          this.value = this._getValueFromFirstAllowedNode();
          this.isEnabled = t.schema.checkAttributeInSelection(e.selection, this.attributeKey);
        }
        execute(t = {}) {
          const e = this.editor.model;
          const n = e.document;
          const o = n.selection;
          const i = t.forceValue === undefined ? !this.value : t.forceValue;
          e.change((t) => {
            if (o.isCollapsed) {
              if (i) {
                t.setSelectionAttribute(this.attributeKey, true);
              } else {
                t.removeSelectionAttribute(this.attributeKey);
              }
            } else {
              const n = e.schema.getValidRanges(o.getRanges(), this.attributeKey);
              for (const e of n) {
                if (i) {
                  t.setAttribute(this.attributeKey, i, e);
                } else {
                  t.removeAttribute(this.attributeKey, e);
                }
              }
            }
          });
        }
        _getValueFromFirstAllowedNode() {
          const t = this.editor.model;
          const e = t.schema;
          const n = t.document.selection;
          if (n.isCollapsed) {
            return n.hasAttribute(this.attributeKey);
          }
          for (const t of n.getRanges()) {
            for (const n of t.getItems()) {
              if (e.checkAttribute(n, this.attributeKey)) {
                return n.hasAttribute(this.attributeKey);
              }
            }
          }
          return false;
        }
      }
      const RS = "bold";
      class IS extends nu {
        static get pluginName() {
          return "BoldEditing";
        }
        init() {
          const t = this.editor;
          t.model.schema.extend("$text", { allowAttributes: RS });
          t.model.schema.setAttributeProperties(RS, { isFormatting: true, copyOnEnter: true });
          t.conversion.attributeToElement({
            model: RS,
            view: "strong",
            upcastAlso: [
              "b",
              (t) => {
                const e = t.getStyle("font-weight");
                if (!e) {
                  return null;
                }
                if (e == "bold" || Number(e) >= 600) {
                  return { name: true, styles: ["font-weight"] };
                }
                return null;
              },
            ],
          });
          t.commands.add(RS, new OS(t, RS));
          t.keystrokes.set("CTRL+B", RS);
        }
      }
      const zS = "bold";
      class FS extends nu {
        static get pluginName() {
          return "BoldUI";
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.ui.componentFactory.add(zS, (n) => {
            const o = t.commands.get(zS);
            const i = new vd(n);
            i.set({
              label: e("Bold"),
              icon: jC.bold,
              keystroke: "CTRL+B",
              tooltip: true,
              isToggleable: true,
            });
            i.bind("isOn", "isEnabled").to(o, "value", "isEnabled");
            this.listenTo(i, "execute", () => {
              t.execute(zS);
              t.editing.view.focus();
            });
            return i;
          });
        }
      }
      class MS extends nu {
        static get requires() {
          return [IS, FS];
        }
        static get pluginName() {
          return "Bold";
        }
      }
      class NS {
        constructor(t, e = 20) {
          this._batch = null;
          this.model = t;
          this._size = 0;
          this.limit = e;
          this._isLocked = false;
          this._changeCallback = (t, e) => {
            if (e.isLocal && e.isUndoable && e !== this._batch) {
              this._reset(true);
            }
          };
          this._selectionChangeCallback = () => {
            this._reset();
          };
          this.model.document.on("change", this._changeCallback);
          this.model.document.selection.on("change:range", this._selectionChangeCallback);
          this.model.document.selection.on("change:attribute", this._selectionChangeCallback);
        }
        get batch() {
          if (!this._batch) {
            this._batch = this.model.createBatch({ isTyping: true });
          }
          return this._batch;
        }
        get size() {
          return this._size;
        }
        input(t) {
          this._size += t;
          if (this._size >= this.limit) {
            this._reset(true);
          }
        }
        get isLocked() {
          return this._isLocked;
        }
        lock() {
          this._isLocked = true;
        }
        unlock() {
          this._isLocked = false;
        }
        destroy() {
          this.model.document.off("change", this._changeCallback);
          this.model.document.selection.off("change:range", this._selectionChangeCallback);
          this.model.document.selection.off("change:attribute", this._selectionChangeCallback);
        }
        _reset(t = false) {
          if (!this.isLocked || t) {
            this._batch = null;
            this._size = 0;
          }
        }
      }
      class VS extends iu {
        constructor(t, e) {
          super(t);
          this._buffer = new NS(t.model, e);
          this._isEnabledBasedOnSelection = false;
        }
        get buffer() {
          return this._buffer;
        }
        destroy() {
          super.destroy();
          this._buffer.destroy();
        }
        execute(t = {}) {
          const e = this.editor.model;
          const n = e.document;
          const o = t.text || "";
          const i = o.length;
          let r = n.selection;
          if (t.selection) {
            r = t.selection;
          } else if (t.range) {
            r = e.createSelection(t.range);
          }
          if (!e.canEditAt(r)) {
            return;
          }
          const s = t.resultRange;
          e.enqueueChange(this._buffer.batch, (t) => {
            this._buffer.lock();
            e.deleteContent(r);
            if (o) {
              e.insertContent(t.createText(o, n.selection.getAttributes()), r);
            }
            if (s) {
              t.setSelection(s);
            } else if (!r.is("documentSelection")) {
              t.setSelection(r);
            }
            this._buffer.unlock();
            this._buffer.input(i);
          });
        }
      }
      const LS = ["insertText", "insertReplacementText"];
      class HS extends sm {
        constructor(t) {
          super(t);
          this.focusObserver = t.getObserver(pk);
          if (r.isAndroid) {
            LS.push("insertCompositionText");
          }
          const e = t.document;
          e.on("beforeinput", (n, o) => {
            if (!this.isEnabled) {
              return;
            }
            const { data: i, targetRanges: r, inputType: s, domEvent: a } = o;
            if (!LS.includes(s)) {
              return;
            }
            this.focusObserver.flush();
            const c = new C(e, "insertText");
            e.fire(c, new lm(t, a, { text: i, selection: t.createSelection(r) }));
            if (c.stop.called) {
              n.stop();
            }
          });
          e.on(
            "compositionend",
            (n, { data: o, domEvent: i }) => {
              if (!this.isEnabled || r.isAndroid) {
                return;
              }
              if (!o) {
                return;
              }
              e.fire("insertText", new lm(t, i, { text: o, selection: e.selection }));
            },
            { priority: "lowest" }
          );
        }
        observe() {}
        stopObserving() {}
      }
      class jS extends nu {
        static get pluginName() {
          return "Input";
        }
        init() {
          const t = this.editor;
          const e = t.model;
          const n = t.editing.view;
          const o = e.document.selection;
          n.addObserver(HS);
          const i = new VS(t, t.config.get("typing.undoStep") || 20);
          t.commands.add("insertText", i);
          t.commands.add("input", i);
          this.listenTo(n.document, "insertText", (o, i) => {
            if (!n.document.isComposing) {
              i.preventDefault();
            }
            const { text: s, selection: a, resultRange: c } = i;
            const l = Array.from(a.getRanges()).map((e) => t.editing.mapper.toModelRange(e));
            let d = s;
            if (r.isAndroid) {
              const t = Array.from(l[0].getItems()).reduce(
                (t, e) => t + (e.is("$textProxy") ? e.data : ""),
                ""
              );
              if (t) {
                if (t.length <= d.length) {
                  if (d.startsWith(t)) {
                    d = d.substring(t.length);
                    l[0].start = l[0].start.getShiftedBy(t.length);
                  }
                } else {
                  if (t.startsWith(d)) {
                    l[0].start = l[0].start.getShiftedBy(d.length);
                    d = "";
                  }
                }
              }
            }
            const h = { text: d, selection: e.createSelection(l) };
            if (c) {
              h.resultRange = t.editing.mapper.toModelRange(c);
            }
            t.execute("insertText", h);
            n.scrollToTheSelection();
          });
          if (r.isAndroid) {
            this.listenTo(n.document, "keydown", (t, r) => {
              if (o.isCollapsed || r.keyCode != 229 || !n.document.isComposing) {
                return;
              }
              qS(e, i);
            });
          } else {
            this.listenTo(n.document, "compositionstart", () => {
              if (o.isCollapsed) {
                return;
              }
              qS(e, i);
            });
          }
        }
      }
      function qS(t, e) {
        if (!e.isEnabled) {
          return;
        }
        const n = e.buffer;
        n.lock();
        t.enqueueChange(n.batch, () => {
          t.deleteContent(t.document.selection);
        });
        n.unlock();
      }
      class $S extends iu {
        constructor(t, e) {
          super(t);
          this.direction = e;
          this._buffer = new NS(t.model, t.config.get("typing.undoStep"));
          this._isEnabledBasedOnSelection = false;
        }
        get buffer() {
          return this._buffer;
        }
        execute(t = {}) {
          const e = this.editor.model;
          const n = e.document;
          e.enqueueChange(this._buffer.batch, (o) => {
            this._buffer.lock();
            const i = o.createSelection(t.selection || n.selection);
            if (!e.canEditAt(i)) {
              return;
            }
            const r = t.sequence || 1;
            const s = i.isCollapsed;
            if (i.isCollapsed) {
              e.modifySelection(i, {
                direction: this.direction,
                unit: t.unit,
                treatEmojiAsSingleUnit: true,
              });
            }
            if (this._shouldEntireContentBeReplacedWithParagraph(r)) {
              this._replaceEntireContentWithParagraph(o);
              return;
            }
            if (this._shouldReplaceFirstBlockWithParagraph(i, r)) {
              this.editor.execute("paragraph", { selection: i });
              return;
            }
            if (i.isCollapsed) {
              return;
            }
            let a = 0;
            i.getFirstRange()
              .getMinimalFlatRanges()
              .forEach((t) => {
                a += vt(
                  t.getWalker({ singleCharacters: true, ignoreElementEnd: true, shallow: true })
                );
              });
            e.deleteContent(i, { doNotResetEntireContent: s, direction: this.direction });
            this._buffer.input(a);
            o.setSelection(i);
            this._buffer.unlock();
          });
        }
        _shouldEntireContentBeReplacedWithParagraph(t) {
          if (t > 1) {
            return false;
          }
          const e = this.editor.model;
          const n = e.document;
          const o = n.selection;
          const i = e.schema.getLimitElement(o);
          const r = o.isCollapsed && o.containsEntireContent(i);
          if (!r) {
            return false;
          }
          if (!e.schema.checkChild(i, "paragraph")) {
            return false;
          }
          const s = i.getChild(0);
          if (s && s.is("element", "paragraph")) {
            return false;
          }
          return true;
        }
        _replaceEntireContentWithParagraph(t) {
          const e = this.editor.model;
          const n = e.document;
          const o = n.selection;
          const i = e.schema.getLimitElement(o);
          const r = t.createElement("paragraph");
          t.remove(t.createRangeIn(i));
          t.insert(r, i);
          t.setSelection(r, 0);
        }
        _shouldReplaceFirstBlockWithParagraph(t, e) {
          const n = this.editor.model;
          if (e > 1 || this.direction != "backward") {
            return false;
          }
          if (!t.isCollapsed) {
            return false;
          }
          const o = t.getFirstPosition();
          const i = n.schema.getLimitElement(o);
          const r = i.getChild(0);
          if (o.parent != r) {
            return false;
          }
          if (!t.containsEntireContent(r)) {
            return false;
          }
          if (!n.schema.checkChild(i, "paragraph")) {
            return false;
          }
          if (r.name == "paragraph") {
            return false;
          }
          return true;
        }
      }
      const WS = "character";
      const GS = "word";
      const KS = "codePoint";
      const US = "selection";
      const ZS = "backward";
      const JS = "forward";
      const YS = {
        deleteContent: { unit: US, direction: ZS },
        deleteContentBackward: { unit: KS, direction: ZS },
        deleteWordBackward: { unit: GS, direction: ZS },
        deleteHardLineBackward: { unit: US, direction: ZS },
        deleteSoftLineBackward: { unit: US, direction: ZS },
        deleteContentForward: { unit: WS, direction: JS },
        deleteWordForward: { unit: GS, direction: JS },
        deleteHardLineForward: { unit: US, direction: JS },
        deleteSoftLineForward: { unit: US, direction: JS },
      };
      class QS extends sm {
        constructor(t) {
          super(t);
          const e = t.document;
          let n = 0;
          e.on("keydown", () => {
            n++;
          });
          e.on("keyup", () => {
            n = 0;
          });
          e.on("beforeinput", (o, i) => {
            if (!this.isEnabled) {
              return;
            }
            const { targetRanges: s, domEvent: a, inputType: c } = i;
            const l = YS[c];
            if (!l) {
              return;
            }
            const d = { direction: l.direction, unit: l.unit, sequence: n };
            if (d.unit == US) {
              d.selectionToRemove = t.createSelection(s[0]);
            }
            if (c === "deleteContentBackward") {
              if (r.isAndroid) {
                d.sequence = 1;
              }
              if (tT(s)) {
                d.unit = US;
                d.selectionToRemove = t.createSelection(s);
              }
            }
            const h = new qp(e, "delete", s[0]);
            e.fire(h, new lm(t, a, d));
            if (h.stop.called) {
              o.stop();
            }
          });
          if (r.isBlink) {
            XS(this);
          }
        }
        observe() {}
        stopObserving() {}
      }
      function XS(t) {
        const e = t.view;
        const n = e.document;
        let o = null;
        let i = false;
        n.on("keydown", (t, { keyCode: e }) => {
          o = e;
          i = false;
        });
        n.on("keyup", (a, { keyCode: c, domEvent: l }) => {
          const d = n.selection;
          const h = t.isEnabled && c == o && r(c) && !d.isCollapsed && !i;
          o = null;
          if (h) {
            const t = d.getFirstRange();
            const o = new qp(n, "delete", t);
            const i = { unit: US, direction: s(c), selectionToRemove: d };
            n.fire(o, new lm(e, l, i));
          }
        });
        n.on(
          "beforeinput",
          (t, { inputType: e }) => {
            const n = YS[e];
            const a = r(o) && n && n.direction == s(o);
            if (a) {
              i = true;
            }
          },
          { priority: "high" }
        );
        n.on(
          "beforeinput",
          (t, { inputType: e, data: n }) => {
            const i = o == jc.delete && e == "insertText" && n == "";
            if (i) {
              t.stop();
            }
          },
          { priority: "high" }
        );
        function r(t) {
          return t == jc.backspace || t == jc.delete;
        }
        function s(t) {
          return t == jc.backspace ? ZS : JS;
        }
      }
      function tT(t) {
        if (t.length != 1 || t[0].isCollapsed) {
          return false;
        }
        const e = t[0].getWalker({
          direction: "backward",
          singleCharacters: true,
          ignoreElementEnd: true,
        });
        let n = 0;
        for (const { nextPosition: t } of e) {
          if (!t.parent.is("$text")) {
            n++;
          } else {
            const e = t.parent.data;
            const o = t.offset;
            if (Al(e, o) || Cl(e, o) || xl(e, o)) {
              continue;
            }
            n++;
          }
          if (n > 1) {
            return true;
          }
        }
        return false;
      }
      class eT extends nu {
        static get pluginName() {
          return "Delete";
        }
        init() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document;
          const o = t.model.document;
          e.addObserver(QS);
          this._undoOnBackspace = false;
          const i = new $S(t, "forward");
          t.commands.add("deleteForward", i);
          t.commands.add("forwardDelete", i);
          t.commands.add("delete", new $S(t, "backward"));
          this.listenTo(
            n,
            "delete",
            (o, i) => {
              if (!n.isComposing) {
                i.preventDefault();
              }
              const { direction: r, sequence: s, selectionToRemove: a, unit: c } = i;
              const l = r === "forward" ? "deleteForward" : "delete";
              const d = { sequence: s };
              if (c == "selection") {
                const e = Array.from(a.getRanges()).map((e) => t.editing.mapper.toModelRange(e));
                d.selection = t.model.createSelection(e);
              } else {
                d.unit = c;
              }
              t.execute(l, d);
              e.scrollToTheSelection();
            },
            { priority: "low" }
          );
          if (this.editor.plugins.has("UndoEditing")) {
            this.listenTo(
              n,
              "delete",
              (e, n) => {
                if (
                  this._undoOnBackspace &&
                  n.direction == "backward" &&
                  n.sequence == 1 &&
                  n.unit == "codePoint"
                ) {
                  this._undoOnBackspace = false;
                  t.execute("undo");
                  n.preventDefault();
                  e.stop();
                }
              },
              { context: "$capture" }
            );
            this.listenTo(o, "change", () => {
              this._undoOnBackspace = false;
            });
          }
        }
        requestUndoOnBackspace() {
          if (this.editor.plugins.has("UndoEditing")) {
            this._undoOnBackspace = true;
          }
        }
      }
      class nT extends nu {
        static get requires() {
          return [jS, eT];
        }
        static get pluginName() {
          return "Typing";
        }
      }
      function oT(t, e) {
        let n = t.start;
        const o = Array.from(t.getWalker({ ignoreElementEnd: false })).reduce((t, { item: o }) => {
          if (!(o.is("$text") || o.is("$textProxy"))) {
            n = e.createPositionAfter(o);
            return "";
          }
          return t + o.data;
        }, "");
        return { text: o, range: e.createRange(n, t.end) };
      }
      class iT extends lt() {
        constructor(t, e) {
          super();
          this.model = t;
          this.testCallback = e;
          this._hasMatch = false;
          this.set("isEnabled", true);
          this.on("change:isEnabled", () => {
            if (this.isEnabled) {
              this._startListening();
            } else {
              this.stopListening(t.document.selection);
              this.stopListening(t.document);
            }
          });
          this._startListening();
        }
        get hasMatch() {
          return this._hasMatch;
        }
        _startListening() {
          const t = this.model;
          const e = t.document;
          this.listenTo(e.selection, "change:range", (t, { directChange: n }) => {
            if (!n) {
              return;
            }
            if (!e.selection.isCollapsed) {
              if (this.hasMatch) {
                this.fire("unmatched");
                this._hasMatch = false;
              }
              return;
            }
            this._evaluateTextBeforeSelection("selection");
          });
          this.listenTo(e, "change:data", (t, e) => {
            if (e.isUndo || !e.isLocal) {
              return;
            }
            this._evaluateTextBeforeSelection("data", { batch: e });
          });
        }
        _evaluateTextBeforeSelection(t, e = {}) {
          const n = this.model;
          const o = n.document;
          const i = o.selection;
          const r = n.createRange(n.createPositionAt(i.focus.parent, 0), i.focus);
          const { text: s, range: a } = oT(r, n);
          const c = this.testCallback(s);
          if (!c && this.hasMatch) {
            this.fire("unmatched");
          }
          this._hasMatch = !!c;
          if (c) {
            const n = Object.assign(e, { text: s, range: a });
            if (typeof c == "object") {
              Object.assign(n, c);
            }
            this.fire(`matched:${t}`, n);
          }
        }
      }
      class rT extends (null && Plugin) {
        static get pluginName() {
          return "TwoStepCaretMovement";
        }
        constructor(t) {
          super(t);
          this.attributes = new Set();
          this._overrideUid = null;
        }
        init() {
          const t = this.editor;
          const e = t.model;
          const n = t.editing.view;
          const o = t.locale;
          const i = e.document.selection;
          this.listenTo(
            n.document,
            "arrowKey",
            (t, e) => {
              if (!i.isCollapsed) {
                return;
              }
              if (e.shiftKey || e.altKey || e.ctrlKey) {
                return;
              }
              const n = e.keyCode == keyCodes.arrowright;
              const r = e.keyCode == keyCodes.arrowleft;
              if (!n && !r) {
                return;
              }
              const s = o.contentLanguageDirection;
              let a = false;
              if ((s === "ltr" && n) || (s === "rtl" && r)) {
                a = this._handleForwardMovement(e);
              } else {
                a = this._handleBackwardMovement(e);
              }
              if (a === true) {
                t.stop();
              }
            },
            { context: "$text", priority: "highest" }
          );
          this._isNextGravityRestorationSkipped = false;
          this.listenTo(i, "change:range", (t, e) => {
            if (this._isNextGravityRestorationSkipped) {
              this._isNextGravityRestorationSkipped = false;
              return;
            }
            if (!this._isGravityOverridden) {
              return;
            }
            if (!e.directChange && dT(i.getFirstPosition(), this.attributes)) {
              return;
            }
            this._restoreGravity();
          });
        }
        registerAttribute(t) {
          this.attributes.add(t);
        }
        _handleForwardMovement(t) {
          const e = this.attributes;
          const n = this.editor.model;
          const o = n.document.selection;
          const i = o.getFirstPosition();
          if (this._isGravityOverridden) {
            return false;
          }
          if (i.isAtStart && sT(o, e)) {
            return false;
          }
          if (dT(i, e)) {
            cT(t);
            this._overrideGravity();
            return true;
          }
          return false;
        }
        _handleBackwardMovement(t) {
          const e = this.attributes;
          const n = this.editor.model;
          const o = n.document.selection;
          const i = o.getFirstPosition();
          if (this._isGravityOverridden) {
            cT(t);
            this._restoreGravity();
            aT(n, e, i);
            return true;
          } else {
            if (i.isAtStart) {
              if (sT(o, e)) {
                cT(t);
                aT(n, e, i);
                return true;
              }
              return false;
            }
            if (lT(i, e)) {
              if (i.isAtEnd && !sT(o, e) && dT(i, e)) {
                cT(t);
                aT(n, e, i);
                return true;
              }
              this._isNextGravityRestorationSkipped = true;
              this._overrideGravity();
              return false;
            }
          }
          return false;
        }
        get _isGravityOverridden() {
          return !!this._overrideUid;
        }
        _overrideGravity() {
          this._overrideUid = this.editor.model.change((t) => t.overrideSelectionGravity());
        }
        _restoreGravity() {
          this.editor.model.change((t) => {
            t.restoreSelectionGravity(this._overrideUid);
            this._overrideUid = null;
          });
        }
      }
      function sT(t, e) {
        for (const n of e) {
          if (t.hasAttribute(n)) {
            return true;
          }
        }
        return false;
      }
      function aT(t, e, n) {
        const o = n.nodeBefore;
        t.change((n) => {
          if (o) {
            const e = [];
            const i = t.schema.isObject(o) && t.schema.isInline(o);
            for (const [n, r] of o.getAttributes()) {
              if (
                t.schema.checkAttribute("$text", n) &&
                (!i || t.schema.getAttributeProperties(n).copyFromObject !== false)
              ) {
                e.push([n, r]);
              }
            }
            n.setSelectionAttribute(e);
          } else {
            n.removeSelectionAttribute(e);
          }
        });
      }
      function cT(t) {
        t.preventDefault();
      }
      function lT(t, e) {
        const n = t.getShiftedBy(-1);
        return dT(n, e);
      }
      function dT(t, e) {
        const { nodeBefore: n, nodeAfter: o } = t;
        for (const t of e) {
          const e = n ? n.getAttribute(t) : undefined;
          const i = o ? o.getAttribute(t) : undefined;
          if (i !== e) {
            return true;
          }
        }
        return false;
      }
      const hT = {
        copyright: { from: "(c)", to: "©" },
        registeredTrademark: { from: "(r)", to: "®" },
        trademark: { from: "(tm)", to: "™" },
        oneHalf: { from: /(^|[^/a-z0-9])(1\/2)([^/a-z0-9])$/i, to: [null, "½", null] },
        oneThird: { from: /(^|[^/a-z0-9])(1\/3)([^/a-z0-9])$/i, to: [null, "⅓", null] },
        twoThirds: { from: /(^|[^/a-z0-9])(2\/3)([^/a-z0-9])$/i, to: [null, "⅔", null] },
        oneForth: { from: /(^|[^/a-z0-9])(1\/4)([^/a-z0-9])$/i, to: [null, "¼", null] },
        threeQuarters: { from: /(^|[^/a-z0-9])(3\/4)([^/a-z0-9])$/i, to: [null, "¾", null] },
        lessThanOrEqual: { from: "<=", to: "≤" },
        greaterThanOrEqual: { from: ">=", to: "≥" },
        notEqual: { from: "!=", to: "≠" },
        arrowLeft: { from: "<-", to: "←" },
        arrowRight: { from: "->", to: "→" },
        horizontalEllipsis: { from: "...", to: "…" },
        enDash: { from: /(^| )(--)( )$/, to: [null, "–", null] },
        emDash: { from: /(^| )(---)( )$/, to: [null, "—", null] },
        quotesPrimary: { from: bT('"'), to: [null, "“", null, "”"] },
        quotesSecondary: { from: bT("'"), to: [null, "‘", null, "’"] },
        quotesPrimaryEnGb: { from: bT("'"), to: [null, "‘", null, "’"] },
        quotesSecondaryEnGb: { from: bT('"'), to: [null, "“", null, "”"] },
        quotesPrimaryPl: { from: bT('"'), to: [null, "„", null, "”"] },
        quotesSecondaryPl: { from: bT("'"), to: [null, "‚", null, "’"] },
      };
      const uT = {
        symbols: ["copyright", "registeredTrademark", "trademark"],
        mathematical: [
          "oneHalf",
          "oneThird",
          "twoThirds",
          "oneForth",
          "threeQuarters",
          "lessThanOrEqual",
          "greaterThanOrEqual",
          "notEqual",
          "arrowLeft",
          "arrowRight",
        ],
        typography: ["horizontalEllipsis", "enDash", "emDash"],
        quotes: ["quotesPrimary", "quotesSecondary"],
      };
      const fT = ["symbols", "mathematical", "typography", "quotes"];
      class pT extends nu {
        static get requires() {
          return ["Delete", "Input"];
        }
        static get pluginName() {
          return "TextTransformation";
        }
        constructor(t) {
          super(t);
          t.config.define("typing", { transformations: { include: fT } });
        }
        init() {
          const t = this.editor.model;
          const e = t.document.selection;
          e.on("change:range", () => {
            this.isEnabled = !e.anchor.parent.is("element", "codeBlock");
          });
          this._enableTransformationWatchers();
        }
        _enableTransformationWatchers() {
          const t = this.editor;
          const e = t.model;
          const n = t.plugins.get("Delete");
          const o = wT(t.config.get("typing.transformations"));
          const i = (t) => {
            for (const e of o) {
              const n = e.from;
              const o = n.test(t);
              if (o) {
                return { normalizedTransformation: e };
              }
            }
          };
          const r = new iT(t.model, i);
          r.on("matched:data", (t, o) => {
            if (!o.batch.isTyping) {
              return;
            }
            const { from: i, to: r } = o.normalizedTransformation;
            const s = i.exec(o.text);
            const a = r(s.slice(1));
            const c = o.range;
            let l = s.index;
            e.enqueueChange((t) => {
              for (let n = 1; n < s.length; n++) {
                const o = s[n];
                const i = a[n - 1];
                if (i == null) {
                  l += o.length;
                  continue;
                }
                const r = c.start.getShiftedBy(l);
                const d = e.createRange(r, r.getShiftedBy(o.length));
                const h = kT(r);
                e.insertContent(t.createText(i, h), d);
                l += i.length;
              }
              e.enqueueChange(() => {
                n.requestUndoOnBackspace();
              });
            });
          });
          r.bind("isEnabled").to(this);
        }
      }
      function gT(t) {
        if (typeof t == "string") {
          return new RegExp(`(${BD(t)})$`);
        }
        return t;
      }
      function mT(t) {
        if (typeof t == "string") {
          return () => [t];
        } else if (t instanceof Array) {
          return () => t;
        }
        return t;
      }
      function kT(t) {
        const e = t.textNode ? t.textNode : t.nodeAfter;
        return e.getAttributes();
      }
      function bT(t) {
        return new RegExp(`(^|\\s)(${t})([^${t}]*)(${t})$`);
      }
      function wT(t) {
        const e = t.extra || [];
        const n = t.remove || [];
        const o = (t) => !n.includes(t);
        const i = t.include.concat(e).filter(o);
        return _T(i)
          .filter(o)
          .map((t) => (typeof t == "string" && hT[t] ? hT[t] : t))
          .filter((t) => typeof t === "object")
          .map((t) => ({ from: gT(t.from), to: mT(t.to) }));
      }
      function _T(t) {
        const e = new Set();
        for (const n of t) {
          if (typeof n == "string" && uT[n]) {
            for (const t of uT[n]) {
              e.add(t);
            }
          } else {
            e.add(n);
          }
        }
        return Array.from(e);
      }
      const vT = "code";
      const AT = "ck-code_selected";
      class CT extends (null && Plugin) {
        static get pluginName() {
          return "CodeEditing";
        }
        static get requires() {
          return [TwoStepCaretMovement];
        }
        init() {
          const t = this.editor;
          t.model.schema.extend("$text", { allowAttributes: vT });
          t.model.schema.setAttributeProperties(vT, { isFormatting: true, copyOnEnter: false });
          t.conversion.attributeToElement({
            model: vT,
            view: "code",
            upcastAlso: { styles: { "word-wrap": "break-word" } },
          });
          t.commands.add(vT, new AttributeCommand(t, vT));
          t.plugins.get(TwoStepCaretMovement).registerAttribute(vT);
          inlineHighlight(t, vT, "code", AT);
        }
      }
      var yT = n(363);
      var xT = { injectType: "singletonStyleTag", attributes: { "data-cke": true } };
      xT.insert = "head";
      xT.singleton = true;
      var ET = Pl()(yT.Z, xT);
      const DT = yT.Z.locals || {};
      const ST = "code";
      class TT extends (null && Plugin) {
        static get pluginName() {
          return "CodeUI";
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.ui.componentFactory.add(ST, (n) => {
            const o = t.commands.get(ST);
            const i = new ButtonView(n);
            i.set({ label: e("Code"), icon: codeIcon, tooltip: true, isToggleable: true });
            i.bind("isOn", "isEnabled").to(o, "value", "isEnabled");
            this.listenTo(i, "execute", () => {
              t.execute(ST);
              t.editing.view.focus();
            });
            return i;
          });
        }
      }
      class PT extends (null && Plugin) {
        static get requires() {
          return [CodeEditing, CodeUI];
        }
        static get pluginName() {
          return "Code";
        }
      }
      const BT = "italic";
      class OT extends nu {
        static get pluginName() {
          return "ItalicEditing";
        }
        init() {
          const t = this.editor;
          t.model.schema.extend("$text", { allowAttributes: BT });
          t.model.schema.setAttributeProperties(BT, { isFormatting: true, copyOnEnter: true });
          t.conversion.attributeToElement({
            model: BT,
            view: "i",
            upcastAlso: ["em", { styles: { "font-style": "italic" } }],
          });
          t.commands.add(BT, new OS(t, BT));
          t.keystrokes.set("CTRL+I", BT);
        }
      }
      const RT =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.586 14.633.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 0 0-.281-.823 1.12 1.12 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z"/></svg>';
      const IT = "italic";
      class zT extends nu {
        static get pluginName() {
          return "ItalicUI";
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.ui.componentFactory.add(IT, (n) => {
            const o = t.commands.get(IT);
            const i = new vd(n);
            i.set({
              label: e("Italic"),
              icon: RT,
              keystroke: "CTRL+I",
              tooltip: true,
              isToggleable: true,
            });
            i.bind("isOn", "isEnabled").to(o, "value", "isEnabled");
            this.listenTo(i, "execute", () => {
              t.execute(IT);
              t.editing.view.focus();
            });
            return i;
          });
        }
      }
      class FT extends nu {
        static get requires() {
          return [OT, zT];
        }
        static get pluginName() {
          return "Italic";
        }
      }
      const MT = "strikethrough";
      class NT extends (null && Plugin) {
        static get pluginName() {
          return "StrikethroughEditing";
        }
        init() {
          const t = this.editor;
          t.model.schema.extend("$text", { allowAttributes: MT });
          t.model.schema.setAttributeProperties(MT, { isFormatting: true, copyOnEnter: true });
          t.conversion.attributeToElement({
            model: MT,
            view: "s",
            upcastAlso: ["del", "strike", { styles: { "text-decoration": "line-through" } }],
          });
          t.commands.add(MT, new AttributeCommand(t, MT));
          t.keystrokes.set("CTRL+SHIFT+X", "strikethrough");
        }
      }
      const VT = "strikethrough";
      class LT extends (null && Plugin) {
        static get pluginName() {
          return "StrikethroughUI";
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.ui.componentFactory.add(VT, (n) => {
            const o = t.commands.get(VT);
            const i = new ButtonView(n);
            i.set({
              label: e("Strikethrough"),
              icon: strikethroughIcon,
              keystroke: "CTRL+SHIFT+X",
              tooltip: true,
              isToggleable: true,
            });
            i.bind("isOn", "isEnabled").to(o, "value", "isEnabled");
            this.listenTo(i, "execute", () => {
              t.execute(VT);
              t.editing.view.focus();
            });
            return i;
          });
        }
      }
      class HT extends (null && Plugin) {
        static get requires() {
          return [StrikethroughEditing, StrikethroughUI];
        }
        static get pluginName() {
          return "Strikethrough";
        }
      }
      const jT = "subscript";
      class qT extends (null && Plugin) {
        static get pluginName() {
          return "SubscriptEditing";
        }
        init() {
          const t = this.editor;
          t.model.schema.extend("$text", { allowAttributes: jT });
          t.model.schema.setAttributeProperties(jT, { isFormatting: true, copyOnEnter: true });
          t.conversion.attributeToElement({
            model: jT,
            view: "sub",
            upcastAlso: [{ styles: { "vertical-align": "sub" } }],
          });
          t.commands.add(jT, new AttributeCommand(t, jT));
        }
      }
      const $T = "subscript";
      class WT extends (null && Plugin) {
        static get pluginName() {
          return "SubscriptUI";
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.ui.componentFactory.add($T, (n) => {
            const o = t.commands.get($T);
            const i = new ButtonView(n);
            i.set({
              label: e("Subscript"),
              icon: subscriptIcon,
              tooltip: true,
              isToggleable: true,
            });
            i.bind("isOn", "isEnabled").to(o, "value", "isEnabled");
            this.listenTo(i, "execute", () => {
              t.execute($T);
              t.editing.view.focus();
            });
            return i;
          });
        }
      }
      class GT extends (null && Plugin) {
        static get requires() {
          return [SubscriptEditing, SubscriptUI];
        }
        static get pluginName() {
          return "Subscript";
        }
      }
      const KT = "superscript";
      class UT extends (null && Plugin) {
        static get pluginName() {
          return "SuperscriptEditing";
        }
        init() {
          const t = this.editor;
          t.model.schema.extend("$text", { allowAttributes: KT });
          t.model.schema.setAttributeProperties(KT, { isFormatting: true, copyOnEnter: true });
          t.conversion.attributeToElement({
            model: KT,
            view: "sup",
            upcastAlso: [{ styles: { "vertical-align": "super" } }],
          });
          t.commands.add(KT, new AttributeCommand(t, KT));
        }
      }
      const ZT = "superscript";
      class JT extends (null && Plugin) {
        static get pluginName() {
          return "SuperscriptUI";
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.ui.componentFactory.add(ZT, (n) => {
            const o = t.commands.get(ZT);
            const i = new ButtonView(n);
            i.set({
              label: e("Superscript"),
              icon: superscriptIcon,
              tooltip: true,
              isToggleable: true,
            });
            i.bind("isOn", "isEnabled").to(o, "value", "isEnabled");
            this.listenTo(i, "execute", () => {
              t.execute(ZT);
              t.editing.view.focus();
            });
            return i;
          });
        }
      }
      class YT extends (null && Plugin) {
        static get requires() {
          return [SuperscriptEditing, SuperscriptUI];
        }
        static get pluginName() {
          return "Superscript";
        }
      }
      const QT = "underline";
      class XT extends nu {
        static get pluginName() {
          return "UnderlineEditing";
        }
        init() {
          const t = this.editor;
          t.model.schema.extend("$text", { allowAttributes: QT });
          t.model.schema.setAttributeProperties(QT, { isFormatting: true, copyOnEnter: true });
          t.conversion.attributeToElement({
            model: QT,
            view: "u",
            upcastAlso: { styles: { "text-decoration": "underline" } },
          });
          t.commands.add(QT, new OS(t, QT));
          t.keystrokes.set("CTRL+U", "underline");
        }
      }
      const tP =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 18v-1.5h14V18zm2.2-8V3.6c0-.4.4-.6.8-.6.3 0 .7.2.7.6v6.2c0 2 1.3 2.8 3.2 2.8 1.9 0 3.4-.9 3.4-2.9V3.6c0-.3.4-.5.8-.5.3 0 .7.2.7.5V10c0 2.7-2.2 4-4.9 4-2.6 0-4.7-1.2-4.7-4z"/></svg>';
      const eP = "underline";
      class nP extends nu {
        static get pluginName() {
          return "UnderlineUI";
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.ui.componentFactory.add(eP, (n) => {
            const o = t.commands.get(eP);
            const i = new vd(n);
            i.set({
              label: e("Underline"),
              icon: tP,
              keystroke: "CTRL+U",
              tooltip: true,
              isToggleable: true,
            });
            i.bind("isOn", "isEnabled").to(o, "value", "isEnabled");
            this.listenTo(i, "execute", () => {
              t.execute(eP);
              t.editing.view.focus();
            });
            return i;
          });
        }
      }
      class oP extends nu {
        static get requires() {
          return [XT, nP];
        }
        static get pluginName() {
          return "Underline";
        }
      }
      class iP extends dm {
        constructor(t) {
          super(t);
          this.domEventType = [
            "paste",
            "copy",
            "cut",
            "drop",
            "dragover",
            "dragstart",
            "dragend",
            "dragenter",
            "dragleave",
          ];
          const e = this.document;
          this.listenTo(e, "paste", n("clipboardInput"), { priority: "low" });
          this.listenTo(e, "drop", n("clipboardInput"), { priority: "low" });
          this.listenTo(e, "dragover", n("dragging"), { priority: "low" });
          function n(t) {
            return (n, o) => {
              o.preventDefault();
              const i = o.dropRange ? [o.dropRange] : null;
              const r = new C(e, t);
              e.fire(r, {
                dataTransfer: o.dataTransfer,
                method: n.name,
                targetRanges: i,
                target: o.target,
                domEvent: o.domEvent,
              });
              if (r.stop.called) {
                o.stopPropagation();
              }
            };
          }
        }
        onDomEvent(t) {
          const e = "clipboardData" in t ? t.clipboardData : t.dataTransfer;
          const n = t.type == "drop" || t.type == "paste";
          const o = { dataTransfer: new kk(e, { cacheFiles: n }) };
          if (t.type == "drop" || t.type == "dragover") {
            o.dropRange = rP(this.view, t);
          }
          this.fire(t.type, t, o);
        }
      }
      function rP(t, e) {
        const n = e.target.ownerDocument;
        const o = e.clientX;
        const i = e.clientY;
        let r;
        if (n.caretRangeFromPoint && n.caretRangeFromPoint(o, i)) {
          r = n.caretRangeFromPoint(o, i);
        } else if (e.rangeParent) {
          r = n.createRange();
          r.setStart(e.rangeParent, e.rangeOffset);
          r.collapse(true);
        }
        if (r) {
          return t.domConverter.domRangeToView(r);
        }
        return null;
      }
      function sP(t) {
        t = t
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/\r?\n\r?\n/g, "</p><p>")
          .replace(/\r?\n/g, "<br>")
          .replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;")
          .replace(/^\s/, "&nbsp;")
          .replace(/\s$/, "&nbsp;")
          .replace(/\s\s/g, " &nbsp;");
        if (t.includes("</p><p>") || t.includes("<br>")) {
          t = `<p>${t}</p>`;
        }
        return t;
      }
      function aP(t) {
        return t
          .replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (t, e) => {
            if (e.length == 1) {
              return " ";
            }
            return e;
          })
          .replace(/<!--[\s\S]*?-->/g, "");
      }
      const cP = ["figcaption", "li"];
      function lP(t) {
        let e = "";
        if (t.is("$text") || t.is("$textProxy")) {
          e = t.data;
        } else if (t.is("element", "img") && t.hasAttribute("alt")) {
          e = t.getAttribute("alt");
        } else if (t.is("element", "br")) {
          e = "\n";
        } else {
          let n = null;
          for (const o of t.getChildren()) {
            const t = lP(o);
            if (n && (n.is("containerElement") || o.is("containerElement"))) {
              if (cP.includes(n.name) || cP.includes(o.name)) {
                e += "\n";
              } else {
                e += "\n\n";
              }
            }
            e += t;
            n = o;
          }
        }
        return e;
      }
      class dP extends nu {
        static get pluginName() {
          return "ClipboardPipeline";
        }
        init() {
          const t = this.editor;
          const e = t.editing.view;
          e.addObserver(iP);
          this._setupPasteDrop();
          this._setupCopyCut();
        }
        _fireOutputTransformationEvent(t, e, n) {
          const o = this.editor.model.getSelectedContent(e);
          this.fire("outputTransformation", { dataTransfer: t, content: o, method: n });
        }
        _setupPasteDrop() {
          const t = this.editor;
          const e = t.model;
          const n = t.editing.view;
          const o = n.document;
          this.listenTo(
            o,
            "clipboardInput",
            (e, n) => {
              if (n.method == "paste" && !t.model.canEditAt(t.model.document.selection)) {
                e.stop();
              }
            },
            { priority: "highest" }
          );
          this.listenTo(
            o,
            "clipboardInput",
            (t, e) => {
              const o = e.dataTransfer;
              let i;
              if (e.content) {
                i = e.content;
              } else {
                let t = "";
                if (o.getData("text/html")) {
                  t = aP(o.getData("text/html"));
                } else if (o.getData("text/plain")) {
                  t = sP(o.getData("text/plain"));
                }
                i = this.editor.data.htmlProcessor.toView(t);
              }
              const r = new C(this, "inputTransformation");
              this.fire(r, {
                content: i,
                dataTransfer: o,
                targetRanges: e.targetRanges,
                method: e.method,
              });
              if (r.stop.called) {
                t.stop();
              }
              n.scrollToTheSelection();
            },
            { priority: "low" }
          );
          this.listenTo(
            this,
            "inputTransformation",
            (t, n) => {
              if (n.content.isEmpty) {
                return;
              }
              const o = this.editor.data;
              const i = o.toModel(n.content, "$clipboardHolder");
              if (i.childCount == 0) {
                return;
              }
              t.stop();
              e.change(() => {
                this.fire("contentInsertion", {
                  content: i,
                  method: n.method,
                  dataTransfer: n.dataTransfer,
                  targetRanges: n.targetRanges,
                });
              });
            },
            { priority: "low" }
          );
          this.listenTo(
            this,
            "contentInsertion",
            (t, n) => {
              n.resultRange = e.insertContent(n.content);
            },
            { priority: "low" }
          );
        }
        _setupCopyCut() {
          const t = this.editor;
          const e = t.model.document;
          const n = t.editing.view;
          const o = n.document;
          const i = (t, n) => {
            const o = n.dataTransfer;
            n.preventDefault();
            this._fireOutputTransformationEvent(o, e.selection, t.name);
          };
          this.listenTo(o, "copy", i, { priority: "low" });
          this.listenTo(
            o,
            "cut",
            (e, n) => {
              if (!t.model.canEditAt(t.model.document.selection)) {
                n.preventDefault();
              } else {
                i(e, n);
              }
            },
            { priority: "low" }
          );
          this.listenTo(
            this,
            "outputTransformation",
            (e, n) => {
              const i = t.data.toView(n.content);
              o.fire("clipboardOutput", {
                dataTransfer: n.dataTransfer,
                content: i,
                method: n.method,
              });
            },
            { priority: "low" }
          );
          this.listenTo(
            o,
            "clipboardOutput",
            (n, o) => {
              if (!o.content.isEmpty) {
                o.dataTransfer.setData(
                  "text/html",
                  this.editor.data.htmlProcessor.toData(o.content)
                );
                o.dataTransfer.setData("text/plain", lP(o.content));
              }
              if (o.method == "cut") {
                t.model.deleteContent(e.selection);
              }
            },
            { priority: "low" }
          );
        }
      }
      function* hP(t, e) {
        for (const n of e) {
          if (n && t.getAttributeProperties(n[0]).copyOnEnter) {
            yield n;
          }
        }
      }
      class uP extends iu {
        execute() {
          this.editor.model.change((t) => {
            this.enterBlock(t);
            this.fire("afterExecute", { writer: t });
          });
        }
        enterBlock(t) {
          const e = this.editor.model;
          const n = e.document.selection;
          const o = e.schema;
          const i = n.isCollapsed;
          const r = n.getFirstRange();
          const s = r.start.parent;
          const a = r.end.parent;
          if (o.isLimit(s) || o.isLimit(a)) {
            if (!i && s == a) {
              e.deleteContent(n);
            }
            return false;
          }
          if (i) {
            const e = hP(t.model.schema, n.getAttributes());
            fP(t, r.start);
            t.setSelectionAttribute(e);
            return true;
          } else {
            const o = !(r.start.isAtStart && r.end.isAtEnd);
            const i = s == a;
            e.deleteContent(n, { leaveUnmerged: o });
            if (o) {
              if (i) {
                fP(t, n.focus);
                return true;
              } else {
                t.setSelection(a, 0);
              }
            }
          }
          return false;
        }
      }
      function fP(t, e) {
        t.split(e);
        t.setSelection(e.parent.nextSibling, 0);
      }
      const pP = { insertParagraph: { isSoft: false }, insertLineBreak: { isSoft: true } };
      class gP extends sm {
        constructor(t) {
          super(t);
          const e = this.document;
          let n = false;
          e.on("keydown", (t, e) => {
            n = e.shiftKey;
          });
          e.on("beforeinput", (o, i) => {
            if (!this.isEnabled) {
              return;
            }
            let s = i.inputType;
            if (r.isSafari && n && s == "insertParagraph") {
              s = "insertLineBreak";
            }
            const a = i.domEvent;
            const c = pP[s];
            if (!c) {
              return;
            }
            const l = new qp(e, "enter", i.targetRanges[0]);
            e.fire(l, new lm(t, a, { isSoft: c.isSoft }));
            if (l.stop.called) {
              o.stop();
            }
          });
        }
        observe() {}
        stopObserving() {}
      }
      class mP extends nu {
        static get pluginName() {
          return "Enter";
        }
        init() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document;
          e.addObserver(gP);
          t.commands.add("enter", new uP(t));
          this.listenTo(
            n,
            "enter",
            (o, i) => {
              if (!n.isComposing) {
                i.preventDefault();
              }
              if (i.isSoft) {
                return;
              }
              t.execute("enter");
              e.scrollToTheSelection();
            },
            { priority: "low" }
          );
        }
      }
      class kP extends iu {
        execute() {
          const t = this.editor.model;
          const e = t.document;
          t.change((n) => {
            wP(t, n, e.selection);
            this.fire("afterExecute", { writer: n });
          });
        }
        refresh() {
          const t = this.editor.model;
          const e = t.document;
          this.isEnabled = bP(t.schema, e.selection);
        }
      }
      function bP(t, e) {
        if (e.rangeCount > 1) {
          return false;
        }
        const n = e.anchor;
        if (!n || !t.checkChild(n, "softBreak")) {
          return false;
        }
        const o = e.getFirstRange();
        const i = o.start.parent;
        const r = o.end.parent;
        if ((vP(i, t) || vP(r, t)) && i !== r) {
          return false;
        }
        return true;
      }
      function wP(t, e, n) {
        const o = n.isCollapsed;
        const i = n.getFirstRange();
        const r = i.start.parent;
        const s = i.end.parent;
        const a = r == s;
        if (o) {
          const o = hP(t.schema, n.getAttributes());
          _P(t, e, i.end);
          e.removeSelectionAttribute(n.getAttributeKeys());
          e.setSelectionAttribute(o);
        } else {
          const o = !(i.start.isAtStart && i.end.isAtEnd);
          t.deleteContent(n, { leaveUnmerged: o });
          if (a) {
            _P(t, e, n.focus);
          } else {
            if (o) {
              e.setSelection(s, 0);
            }
          }
        }
      }
      function _P(t, e, n) {
        const o = e.createElement("softBreak");
        t.insertContent(o, n);
        e.setSelection(o, "after");
      }
      function vP(t, e) {
        if (t.is("rootElement")) {
          return false;
        }
        return e.isLimit(t) || vP(t.parent, e);
      }
      class AP extends nu {
        static get pluginName() {
          return "ShiftEnter";
        }
        init() {
          const t = this.editor;
          const e = t.model.schema;
          const n = t.conversion;
          const o = t.editing.view;
          const i = o.document;
          e.register("softBreak", { allowWhere: "$text", isInline: true });
          n.for("upcast").elementToElement({ model: "softBreak", view: "br" });
          n.for("downcast").elementToElement({
            model: "softBreak",
            view: (t, { writer: e }) => e.createEmptyElement("br"),
          });
          o.addObserver(gP);
          t.commands.add("shiftEnter", new kP(t));
          this.listenTo(
            i,
            "enter",
            (e, n) => {
              if (!i.isComposing) {
                n.preventDefault();
              }
              if (!n.isSoft) {
                return;
              }
              t.execute("shiftEnter");
              o.scrollToTheSelection();
            },
            { priority: "low" }
          );
        }
      }
      class CP extends q() {
        constructor() {
          super(...arguments);
          this._stack = [];
        }
        add(t, e) {
          const n = this._stack;
          const o = n[0];
          this._insertDescriptor(t);
          const i = n[0];
          if (o !== i && !yP(o, i)) {
            this.fire("change:top", { oldDescriptor: o, newDescriptor: i, writer: e });
          }
        }
        remove(t, e) {
          const n = this._stack;
          const o = n[0];
          this._removeDescriptor(t);
          const i = n[0];
          if (o !== i && !yP(o, i)) {
            this.fire("change:top", { oldDescriptor: o, newDescriptor: i, writer: e });
          }
        }
        _insertDescriptor(t) {
          const e = this._stack;
          const n = e.findIndex((e) => e.id === t.id);
          if (yP(t, e[n])) {
            return;
          }
          if (n > -1) {
            e.splice(n, 1);
          }
          let o = 0;
          while (e[o] && xP(e[o], t)) {
            o++;
          }
          e.splice(o, 0, t);
        }
        _removeDescriptor(t) {
          const e = this._stack;
          const n = e.findIndex((e) => e.id === t);
          if (n > -1) {
            e.splice(n, 1);
          }
        }
      }
      function yP(t, e) {
        return t && e && t.priority == e.priority && EP(t.classes) == EP(e.classes);
      }
      function xP(t, e) {
        if (t.priority > e.priority) {
          return true;
        } else if (t.priority < e.priority) {
          return false;
        }
        return EP(t.classes) > EP(e.classes);
      }
      function EP(t) {
        return Array.isArray(t) ? t.sort().join(",") : t;
      }
      const DP = "ck-widget";
      const SP = "ck-widget_selected";
      function TP(t) {
        if (!t.is("element")) {
          return false;
        }
        return !!t.getCustomProperty("widget");
      }
      function PP(t, e, n = {}) {
        if (!t.is("containerElement")) {
          throw new CKEditorError("widget-to-widget-wrong-element-type", null, { element: t });
        }
        e.setAttribute("contenteditable", "false", t);
        e.addClass(DP, t);
        e.setCustomProperty("widget", true, t);
        t.getFillerOffset = VP;
        e.setCustomProperty("widgetLabel", [], t);
        if (n.label) {
          IP(t, n.label);
        }
        if (n.hasSelectionHandle) {
          LP(t, e);
        }
        RP(t, e);
        return t;
      }
      function BP(t, e, n) {
        if (e.classes) {
          n.addClass(toArray(e.classes), t);
        }
        if (e.attributes) {
          for (const o in e.attributes) {
            n.setAttribute(o, e.attributes[o], t);
          }
        }
      }
      function OP(t, e, n) {
        if (e.classes) {
          n.removeClass(toArray(e.classes), t);
        }
        if (e.attributes) {
          for (const o in e.attributes) {
            n.removeAttribute(o, t);
          }
        }
      }
      function RP(t, e, n = BP, o = OP) {
        const i = new HighlightStack();
        i.on("change:top", (e, i) => {
          if (i.oldDescriptor) {
            o(t, i.oldDescriptor, i.writer);
          }
          if (i.newDescriptor) {
            n(t, i.newDescriptor, i.writer);
          }
        });
        const r = (t, e, n) => i.add(e, n);
        const s = (t, e, n) => i.remove(e, n);
        e.setCustomProperty("addHighlight", r, t);
        e.setCustomProperty("removeHighlight", s, t);
      }
      function IP(t, e) {
        const n = t.getCustomProperty("widgetLabel");
        n.push(e);
      }
      function zP(t) {
        const e = t.getCustomProperty("widgetLabel");
        return e.reduce((t, e) => {
          if (typeof e === "function") {
            return t ? t + ". " + e() : e();
          } else {
            return t ? t + ". " + e : e;
          }
        }, "");
      }
      function FP(t, e, n = {}) {
        e.addClass(["ck-editor__editable", "ck-editor__nested-editable"], t);
        e.setAttribute("role", "textbox", t);
        if (n.label) {
          e.setAttribute("aria-label", n.label, t);
        }
        e.setAttribute("contenteditable", t.isReadOnly ? "false" : "true", t);
        t.on("change:isReadOnly", (n, o, i) => {
          e.setAttribute("contenteditable", i ? "false" : "true", t);
        });
        t.on("change:isFocused", (n, o, i) => {
          if (i) {
            e.addClass("ck-editor__nested-editable_focused", t);
          } else {
            e.removeClass("ck-editor__nested-editable_focused", t);
          }
        });
        RP(t, e);
        return t;
      }
      function MP(t, e) {
        const n = t.getSelectedElement();
        if (n) {
          const o = getTypeAroundFakeCaretPosition(t);
          if (o) {
            return e.createRange(e.createPositionAt(n, o));
          }
        }
        return engineFindOptimalInsertionRange(t, e);
      }
      function NP(t, e) {
        return (n, o) => {
          const { mapper: i, viewPosition: r } = o;
          const s = i.findMappedViewAncestor(r);
          if (!e(s)) {
            return;
          }
          const a = i.toModelElement(s);
          o.modelPosition = t.createPositionAt(a, r.isAtStart ? "before" : "after");
        };
      }
      function VP() {
        return null;
      }
      function LP(t, e) {
        const n = e.createUIElement(
          "div",
          { class: "ck ck-widget__selection-handle" },
          function (t) {
            const e = this.toDomElement(t);
            const n = new IconView();
            n.set("content", dragHandleIcon);
            n.render();
            e.appendChild(n.element);
            return e;
          }
        );
        e.insert(e.createPositionAt(t, 0), n);
        e.addClass(["ck-widget_with-selection-handle"], t);
      }
      const HP = "widget-type-around";
      function jP(t, e, n) {
        return !!t && TP(t) && !n.isInline(e);
      }
      function qP(t) {
        return t.closest(".ck-widget__type-around__button");
      }
      function $P(t) {
        return t.classList.contains("ck-widget__type-around__button_before") ? "before" : "after";
      }
      function WP(t, e) {
        const n = t.closest(".ck-widget");
        return e.mapDomToView(n);
      }
      function GP(t) {
        return t.getAttribute(HP);
      }
      const KP =
        '<svg viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><path d="M9.055.263v3.972h-6.77M1 4.216l2-2.038m-2 2 2 2.038"/></svg>';
      var UP = n(347);
      var ZP = { injectType: "singletonStyleTag", attributes: { "data-cke": true } };
      ZP.insert = "head";
      ZP.singleton = true;
      var JP = Pl()(UP.Z, ZP);
      const YP = UP.Z.locals || {};
      const QP = ["before", "after"];
      const XP = new DOMParser().parseFromString(KP, "image/svg+xml").firstChild;
      const tB = "ck-widget__type-around_disabled";
      class eB extends nu {
        constructor() {
          super(...arguments);
          this._currentFakeCaretModelElement = null;
        }
        static get pluginName() {
          return "WidgetTypeAround";
        }
        static get requires() {
          return [mP, eT];
        }
        init() {
          const t = this.editor;
          const e = t.editing.view;
          this.on("change:isEnabled", (n, o, i) => {
            e.change((t) => {
              for (const n of e.document.roots) {
                if (i) {
                  t.removeClass(tB, n);
                } else {
                  t.addClass(tB, n);
                }
              }
            });
            if (!i) {
              t.model.change((t) => {
                t.removeSelectionAttribute(HP);
              });
            }
          });
          this._enableTypeAroundUIInjection();
          this._enableInsertingParagraphsOnButtonClick();
          this._enableInsertingParagraphsOnEnterKeypress();
          this._enableInsertingParagraphsOnTypingKeystroke();
          this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows();
          this._enableDeleteIntegration();
          this._enableInsertContentIntegration();
          this._enableInsertObjectIntegration();
          this._enableDeleteContentIntegration();
        }
        destroy() {
          super.destroy();
          this._currentFakeCaretModelElement = null;
        }
        _insertParagraph(t, e) {
          const n = this.editor;
          const o = n.editing.view;
          const i = n.model.schema.getAttributesWithProperty(t, "copyOnReplace", true);
          n.execute("insertParagraph", { position: n.model.createPositionAt(t, e), attributes: i });
          o.focus();
          o.scrollToTheSelection();
        }
        _listenToIfEnabled(t, e, n, o) {
          this.listenTo(
            t,
            e,
            (...t) => {
              if (this.isEnabled) {
                n(...t);
              }
            },
            o
          );
        }
        _insertParagraphAccordingToFakeCaretPosition() {
          const t = this.editor;
          const e = t.model;
          const n = e.document.selection;
          const o = GP(n);
          if (!o) {
            return false;
          }
          const i = n.getSelectedElement();
          this._insertParagraph(i, o);
          return true;
        }
        _enableTypeAroundUIInjection() {
          const t = this.editor;
          const e = t.model.schema;
          const n = t.locale.t;
          const o = {
            before: n("Insert paragraph before block"),
            after: n("Insert paragraph after block"),
          };
          t.editing.downcastDispatcher.on(
            "insert",
            (t, i, r) => {
              const s = r.mapper.toViewElement(i.item);
              if (!s) {
                return;
              }
              if (jP(s, i.item, e)) {
                nB(r.writer, o, s);
                const t = s.getCustomProperty("widgetLabel");
                t.push(() =>
                  this.isEnabled
                    ? n(
                        "Press Enter to type after or press Shift + Enter to type before the widget"
                      )
                    : ""
                );
              }
            },
            { priority: "low" }
          );
        }
        _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {
          const t = this.editor;
          const e = t.model;
          const n = e.document.selection;
          const o = e.schema;
          const i = t.editing.view;
          this._listenToIfEnabled(
            i.document,
            "arrowKey",
            (t, e) => {
              this._handleArrowKeyPress(t, e);
            },
            { context: [TP, "$text"], priority: "high" }
          );
          this._listenToIfEnabled(n, "change:range", (e, n) => {
            if (!n.directChange) {
              return;
            }
            t.model.change((t) => {
              t.removeSelectionAttribute(HP);
            });
          });
          this._listenToIfEnabled(e.document, "change:data", () => {
            const e = n.getSelectedElement();
            if (e) {
              const n = t.editing.mapper.toViewElement(e);
              if (jP(n, e, o)) {
                return;
              }
            }
            t.model.change((t) => {
              t.removeSelectionAttribute(HP);
            });
          });
          this._listenToIfEnabled(t.editing.downcastDispatcher, "selection", (t, e, n) => {
            const i = n.writer;
            if (this._currentFakeCaretModelElement) {
              const t = n.mapper.toViewElement(this._currentFakeCaretModelElement);
              if (t) {
                i.removeClass(QP.map(r), t);
                this._currentFakeCaretModelElement = null;
              }
            }
            const s = e.selection.getSelectedElement();
            if (!s) {
              return;
            }
            const a = n.mapper.toViewElement(s);
            if (!jP(a, s, o)) {
              return;
            }
            const c = GP(e.selection);
            if (!c) {
              return;
            }
            i.addClass(r(c), a);
            this._currentFakeCaretModelElement = s;
          });
          this._listenToIfEnabled(t.ui.focusTracker, "change:isFocused", (e, n, o) => {
            if (!o) {
              t.model.change((t) => {
                t.removeSelectionAttribute(HP);
              });
            }
          });
          function r(t) {
            return `ck-widget_type-around_show-fake-caret_${t}`;
          }
        }
        _handleArrowKeyPress(t, e) {
          const n = this.editor;
          const o = n.model;
          const i = o.document.selection;
          const r = o.schema;
          const s = n.editing.view;
          const a = e.keyCode;
          const c = Jc(a, n.locale.contentLanguageDirection);
          const l = s.document.selection.getSelectedElement();
          const d = n.editing.mapper.toModelElement(l);
          let h;
          if (jP(l, d, r)) {
            h = this._handleArrowKeyPressOnSelectedWidget(c);
          } else if (i.isCollapsed) {
            h = this._handleArrowKeyPressWhenSelectionNextToAWidget(c);
          } else if (!e.shiftKey) {
            h = this._handleArrowKeyPressWhenNonCollapsedSelection(c);
          }
          if (h) {
            e.preventDefault();
            t.stop();
          }
        }
        _handleArrowKeyPressOnSelectedWidget(t) {
          const e = this.editor;
          const n = e.model;
          const o = n.document.selection;
          const i = GP(o);
          return n.change((e) => {
            if (i) {
              const n = i === (t ? "after" : "before");
              if (!n) {
                e.removeSelectionAttribute(HP);
                return true;
              }
            } else {
              e.setSelectionAttribute(HP, t ? "after" : "before");
              return true;
            }
            return false;
          });
        }
        _handleArrowKeyPressWhenSelectionNextToAWidget(t) {
          const e = this.editor;
          const n = e.model;
          const o = n.schema;
          const i = e.plugins.get("Widget");
          const r = i._getObjectElementNextToSelection(t);
          const s = e.editing.mapper.toViewElement(r);
          if (jP(s, r, o)) {
            n.change((e) => {
              i._setSelectionOverElement(r);
              e.setSelectionAttribute(HP, t ? "before" : "after");
            });
            return true;
          }
          return false;
        }
        _handleArrowKeyPressWhenNonCollapsedSelection(t) {
          const e = this.editor;
          const n = e.model;
          const o = n.schema;
          const i = e.editing.mapper;
          const r = n.document.selection;
          const s = t ? r.getLastPosition().nodeBefore : r.getFirstPosition().nodeAfter;
          const a = i.toViewElement(s);
          if (jP(a, s, o)) {
            n.change((e) => {
              e.setSelection(s, "on");
              e.setSelectionAttribute(HP, t ? "after" : "before");
            });
            return true;
          }
          return false;
        }
        _enableInsertingParagraphsOnButtonClick() {
          const t = this.editor;
          const e = t.editing.view;
          this._listenToIfEnabled(e.document, "mousedown", (n, o) => {
            const i = qP(o.domTarget);
            if (!i) {
              return;
            }
            const r = $P(i);
            const s = WP(i, e.domConverter);
            const a = t.editing.mapper.toModelElement(s);
            this._insertParagraph(a, r);
            o.preventDefault();
            n.stop();
          });
        }
        _enableInsertingParagraphsOnEnterKeypress() {
          const t = this.editor;
          const e = t.model.document.selection;
          const n = t.editing.view;
          this._listenToIfEnabled(
            n.document,
            "enter",
            (n, o) => {
              if (n.eventPhase != "atTarget") {
                return;
              }
              const i = e.getSelectedElement();
              const r = t.editing.mapper.toViewElement(i);
              const s = t.model.schema;
              let a;
              if (this._insertParagraphAccordingToFakeCaretPosition()) {
                a = true;
              } else if (jP(r, i, s)) {
                this._insertParagraph(i, o.isSoft ? "before" : "after");
                a = true;
              }
              if (a) {
                o.preventDefault();
                n.stop();
              }
            },
            { context: TP }
          );
        }
        _enableInsertingParagraphsOnTypingKeystroke() {
          const t = this.editor;
          const e = t.editing.view.document;
          this._listenToIfEnabled(
            e,
            "insertText",
            (t, n) => {
              if (this._insertParagraphAccordingToFakeCaretPosition()) {
                n.selection = e.selection;
              }
            },
            { priority: "high" }
          );
          if (r.isAndroid) {
            this._listenToIfEnabled(e, "keydown", (t, e) => {
              if (e.keyCode == 229) {
                this._insertParagraphAccordingToFakeCaretPosition();
              }
            });
          } else {
            this._listenToIfEnabled(
              e,
              "compositionstart",
              () => {
                this._insertParagraphAccordingToFakeCaretPosition();
              },
              { priority: "high" }
            );
          }
        }
        _enableDeleteIntegration() {
          const t = this.editor;
          const e = t.editing.view;
          const n = t.model;
          const o = n.schema;
          this._listenToIfEnabled(
            e.document,
            "delete",
            (e, i) => {
              if (e.eventPhase != "atTarget") {
                return;
              }
              const r = GP(n.document.selection);
              if (!r) {
                return;
              }
              const s = i.direction;
              const a = n.document.selection.getSelectedElement();
              const c = r === "before";
              const l = s == "forward";
              const d = c === l;
              if (d) {
                t.execute("delete", { selection: n.createSelection(a, "on") });
              } else {
                const e = o.getNearestSelectionRange(n.createPositionAt(a, r), s);
                if (e) {
                  if (!e.isCollapsed) {
                    n.change((n) => {
                      n.setSelection(e);
                      t.execute(l ? "deleteForward" : "delete");
                    });
                  } else {
                    const i = n.createSelection(e.start);
                    n.modifySelection(i, { direction: s });
                    if (!i.focus.isEqual(e.start)) {
                      n.change((n) => {
                        n.setSelection(e);
                        t.execute(l ? "deleteForward" : "delete");
                      });
                    } else {
                      const t = rB(o, e.start.parent);
                      n.deleteContent(n.createSelection(t, "on"), { doNotAutoparagraph: true });
                    }
                  }
                }
              }
              i.preventDefault();
              e.stop();
            },
            { context: TP }
          );
        }
        _enableInsertContentIntegration() {
          const t = this.editor;
          const e = this.editor.model;
          const n = e.document.selection;
          this._listenToIfEnabled(
            t.model,
            "insertContent",
            (t, [o, i]) => {
              if (i && !i.is("documentSelection")) {
                return;
              }
              const r = GP(n);
              if (!r) {
                return;
              }
              t.stop();
              return e.change((t) => {
                const i = n.getSelectedElement();
                const s = e.createPositionAt(i, r);
                const a = t.createSelection(s);
                const c = e.insertContent(o, a);
                t.setSelection(a);
                return c;
              });
            },
            { priority: "high" }
          );
        }
        _enableInsertObjectIntegration() {
          const t = this.editor;
          const e = this.editor.model;
          const n = e.document.selection;
          this._listenToIfEnabled(
            t.model,
            "insertObject",
            (t, e) => {
              const [, o, i = {}] = e;
              if (o && !o.is("documentSelection")) {
                return;
              }
              const r = GP(n);
              if (!r) {
                return;
              }
              i.findOptimalPosition = r;
              e[3] = i;
            },
            { priority: "high" }
          );
        }
        _enableDeleteContentIntegration() {
          const t = this.editor;
          const e = this.editor.model;
          const n = e.document.selection;
          this._listenToIfEnabled(
            t.model,
            "deleteContent",
            (t, [e]) => {
              if (e && !e.is("documentSelection")) {
                return;
              }
              const o = GP(n);
              if (o) {
                t.stop();
              }
            },
            { priority: "high" }
          );
        }
      }
      function nB(t, e, n) {
        const o = t.createUIElement(
          "div",
          { class: "ck ck-reset_all ck-widget__type-around" },
          function (t) {
            const n = this.toDomElement(t);
            oB(n, e);
            iB(n);
            return n;
          }
        );
        t.insert(t.createPositionAt(n, "end"), o);
      }
      function oB(t, e) {
        for (const n of QP) {
          const o = new Ml({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-widget__type-around__button",
                `ck-widget__type-around__button_${n}`,
              ],
              title: e[n],
              "aria-hidden": "true",
            },
            children: [t.ownerDocument.importNode(XP, true)],
          });
          t.appendChild(o.render());
        }
      }
      function iB(t) {
        const e = new Ml({
          tag: "div",
          attributes: { class: ["ck", "ck-widget__type-around__fake-caret"] },
        });
        t.appendChild(e.render());
      }
      function rB(t, e) {
        let n = e;
        for (const o of e.getAncestors({ parentFirst: true })) {
          if (o.childCount > 1 || t.isLimit(o)) {
            break;
          }
          n = o;
        }
        return n;
      }
      function sB(t) {
        const e = t.model;
        return (n, o) => {
          const i = o.keyCode == jc.arrowup;
          const r = o.keyCode == jc.arrowdown;
          const s = o.shiftKey;
          const a = e.document.selection;
          if (!i && !r) {
            return;
          }
          const c = r;
          if (s && hB(a, c)) {
            return;
          }
          const l = aB(t, a, c);
          if (!l) {
            return;
          }
          if (l.isCollapsed) {
            if (a.isCollapsed) {
              return;
            } else if (s) {
              return;
            }
          }
          if (l.isCollapsed || dB(t, l, c)) {
            e.change((t) => {
              const n = c ? l.end : l.start;
              if (s) {
                const o = e.createSelection(a.anchor);
                o.setFocus(n);
                t.setSelection(o);
              } else {
                t.setSelection(n);
              }
            });
            n.stop();
            o.preventDefault();
            o.stopPropagation();
          }
        };
      }
      function aB(t, e, n) {
        const o = t.model;
        if (n) {
          const t = e.isCollapsed ? e.focus : e.getLastPosition();
          const n = cB(o, t, "forward");
          if (!n) {
            return null;
          }
          const i = o.createRange(t, n);
          const r = lB(o.schema, i, "backward");
          if (r) {
            return o.createRange(t, r);
          }
          return null;
        } else {
          const t = e.isCollapsed ? e.focus : e.getFirstPosition();
          const n = cB(o, t, "backward");
          if (!n) {
            return null;
          }
          const i = o.createRange(n, t);
          const r = lB(o.schema, i, "forward");
          if (r) {
            return o.createRange(r, t);
          }
          return null;
        }
      }
      function cB(t, e, n) {
        const o = t.schema;
        const i = t.createRangeIn(e.root);
        const r = n == "forward" ? "elementStart" : "elementEnd";
        for (const { previousPosition: t, item: s, type: a } of i.getWalker({
          startPosition: e,
          direction: n,
        })) {
          if (o.isLimit(s) && !o.isInline(s)) {
            return t;
          }
          if (a == r && o.isBlock(s)) {
            return null;
          }
        }
        return null;
      }
      function lB(t, e, n) {
        const o = n == "backward" ? e.end : e.start;
        if (t.checkChild(o, "$text")) {
          return o;
        }
        for (const { nextPosition: o } of e.getWalker({ direction: n })) {
          if (t.checkChild(o, "$text")) {
            return o;
          }
        }
        return null;
      }
      function dB(t, e, n) {
        const o = t.model;
        const i = t.view.domConverter;
        if (n) {
          const t = o.createSelection(e.start);
          o.modifySelection(t);
          if (!t.focus.isAtEnd && !e.start.isEqual(t.focus)) {
            e = o.createRange(t.focus, e.end);
          }
        }
        const r = t.mapper.toViewRange(e);
        const s = i.viewRangeToDom(r);
        const a = ac.getDomRangeRects(s);
        let c;
        for (const t of a) {
          if (c === undefined) {
            c = Math.round(t.bottom);
            continue;
          }
          if (Math.round(t.top) >= c) {
            return false;
          }
          c = Math.max(c, Math.round(t.bottom));
        }
        return true;
      }
      function hB(t, e) {
        return !t.isCollapsed && t.isBackward == e;
      }
      var uB = n(153);
      var fB = { injectType: "singletonStyleTag", attributes: { "data-cke": true } };
      fB.insert = "head";
      fB.singleton = true;
      var pB = Pl()(uB.Z, fB);
      const gB = uB.Z.locals || {};
      class mB extends nu {
        constructor() {
          super(...arguments);
          this._previouslySelected = new Set();
        }
        static get pluginName() {
          return "Widget";
        }
        static get requires() {
          return [eB, eT];
        }
        init() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document;
          this.editor.editing.downcastDispatcher.on("selection", (e, n, o) => {
            const i = o.writer;
            const r = n.selection;
            if (r.isCollapsed) {
              return;
            }
            const s = r.getSelectedElement();
            if (!s) {
              return;
            }
            const a = t.editing.mapper.toViewElement(s);
            if (!TP(a)) {
              return;
            }
            if (!o.consumable.consume(r, "selection")) {
              return;
            }
            i.setSelection(i.createRangeOn(a), { fake: true, label: zP(a) });
          });
          this.editor.editing.downcastDispatcher.on(
            "selection",
            (t, e, n) => {
              this._clearPreviouslySelectedWidgets(n.writer);
              const o = n.writer;
              const i = o.document.selection;
              let r = null;
              for (const t of i.getRanges()) {
                for (const e of t) {
                  const t = e.item;
                  if (TP(t) && !bB(t, r)) {
                    o.addClass(SP, t);
                    this._previouslySelected.add(t);
                    r = t;
                  }
                }
              }
            },
            { priority: "low" }
          );
          e.addObserver(oA);
          this.listenTo(n, "mousedown", (...t) => this._onMousedown(...t));
          this.listenTo(
            n,
            "arrowKey",
            (...t) => {
              this._handleSelectionChangeOnArrowKeyPress(...t);
            },
            { context: [TP, "$text"] }
          );
          this.listenTo(
            n,
            "arrowKey",
            (...t) => {
              this._preventDefaultOnArrowKeyPress(...t);
            },
            { context: "$root" }
          );
          this.listenTo(n, "arrowKey", sB(this.editor.editing), { context: "$text" });
          this.listenTo(
            n,
            "delete",
            (t, e) => {
              if (this._handleDelete(e.direction == "forward")) {
                e.preventDefault();
                t.stop();
              }
            },
            { context: "$root" }
          );
        }
        _onMousedown(t, e) {
          const n = this.editor;
          const o = n.editing.view;
          const i = o.document;
          let s = e.target;
          if (kB(s)) {
            if ((r.isSafari || r.isGecko) && e.domEvent.detail >= 3) {
              const t = n.editing.mapper;
              const o = s.is("attributeElement")
                ? s.findAncestor((t) => !t.is("attributeElement"))
                : s;
              const i = t.toModelElement(o);
              e.preventDefault();
              this.editor.model.change((t) => {
                t.setSelection(i, "in");
              });
            }
            return;
          }
          if (!TP(s)) {
            s = s.findAncestor(TP);
            if (!s) {
              return;
            }
          }
          if (r.isAndroid) {
            e.preventDefault();
          }
          if (!i.isFocused) {
            o.focus();
          }
          const a = n.editing.mapper.toModelElement(s);
          this._setSelectionOverElement(a);
        }
        _handleSelectionChangeOnArrowKeyPress(t, e) {
          const n = e.keyCode;
          const o = this.editor.model;
          const i = o.schema;
          const r = o.document.selection;
          const s = r.getSelectedElement();
          const a = Uc(n, this.editor.locale.contentLanguageDirection);
          const c = a == "down" || a == "right";
          const l = a == "up" || a == "down";
          if (s && i.isObject(s)) {
            const n = c ? r.getLastPosition() : r.getFirstPosition();
            const s = i.getNearestSelectionRange(n, c ? "forward" : "backward");
            if (s) {
              o.change((t) => {
                t.setSelection(s);
              });
              e.preventDefault();
              t.stop();
            }
            return;
          }
          if (!r.isCollapsed && !e.shiftKey) {
            const n = r.getFirstPosition();
            const s = r.getLastPosition();
            const a = n.nodeAfter;
            const l = s.nodeBefore;
            if ((a && i.isObject(a)) || (l && i.isObject(l))) {
              o.change((t) => {
                t.setSelection(c ? s : n);
              });
              e.preventDefault();
              t.stop();
            }
            return;
          }
          if (!r.isCollapsed) {
            return;
          }
          const d = this._getObjectElementNextToSelection(c);
          if (d && i.isObject(d)) {
            if (i.isInline(d) && l) {
              return;
            }
            this._setSelectionOverElement(d);
            e.preventDefault();
            t.stop();
          }
        }
        _preventDefaultOnArrowKeyPress(t, e) {
          const n = this.editor.model;
          const o = n.schema;
          const i = n.document.selection.getSelectedElement();
          if (i && o.isObject(i)) {
            e.preventDefault();
            t.stop();
          }
        }
        _handleDelete(t) {
          const e = this.editor.model.document;
          const n = e.selection;
          if (!this.editor.model.canEditAt(n)) {
            return;
          }
          if (!n.isCollapsed) {
            return;
          }
          const o = this._getObjectElementNextToSelection(t);
          if (o) {
            this.editor.model.change((t) => {
              let e = n.anchor.parent;
              while (e.isEmpty) {
                const n = e;
                e = n.parent;
                t.remove(n);
              }
              this._setSelectionOverElement(o);
            });
            return true;
          }
        }
        _setSelectionOverElement(t) {
          this.editor.model.change((e) => {
            e.setSelection(e.createRangeOn(t));
          });
        }
        _getObjectElementNextToSelection(t) {
          const e = this.editor.model;
          const n = e.schema;
          const o = e.document.selection;
          const i = e.createSelection(o);
          e.modifySelection(i, { direction: t ? "forward" : "backward" });
          if (i.isEqual(o)) {
            return null;
          }
          const r = t ? i.focus.nodeBefore : i.focus.nodeAfter;
          if (!!r && n.isObject(r)) {
            return r;
          }
          return null;
        }
        _clearPreviouslySelectedWidgets(t) {
          for (const e of this._previouslySelected) {
            t.removeClass(SP, e);
          }
          this._previouslySelected.clear();
        }
      }
      function kB(t) {
        let e = t;
        while (e) {
          if (e.is("editableElement") && !e.is("rootElement")) {
            return true;
          }
          if (TP(e)) {
            return false;
          }
          e = e.parent;
        }
        return false;
      }
      function bB(t, e) {
        if (!e) {
          return false;
        }
        return Array.from(t.getAncestors()).includes(e);
      }
      class wB extends (null && Plugin) {
        constructor() {
          super(...arguments);
          this._toolbarDefinitions = new Map();
        }
        static get requires() {
          return [ContextualBalloon];
        }
        static get pluginName() {
          return "WidgetToolbarRepository";
        }
        init() {
          const t = this.editor;
          if (t.plugins.has("BalloonToolbar")) {
            const e = t.plugins.get("BalloonToolbar");
            this.listenTo(
              e,
              "show",
              (e) => {
                if (AB(t.editing.view.document.selection)) {
                  e.stop();
                }
              },
              { priority: "high" }
            );
          }
          this._balloon = this.editor.plugins.get("ContextualBalloon");
          this.on("change:isEnabled", () => {
            this._updateToolbarsVisibility();
          });
          this.listenTo(t.ui, "update", () => {
            this._updateToolbarsVisibility();
          });
          this.listenTo(
            t.ui.focusTracker,
            "change:isFocused",
            () => {
              this._updateToolbarsVisibility();
            },
            { priority: "low" }
          );
        }
        destroy() {
          super.destroy();
          for (const t of this._toolbarDefinitions.values()) {
            t.view.destroy();
          }
        }
        register(
          t,
          {
            ariaLabel: e,
            items: n,
            getRelatedElement: o,
            balloonClassName: i = "ck-toolbar-container",
          }
        ) {
          if (!n.length) {
            logWarning("widget-toolbar-no-items", { toolbarId: t });
            return;
          }
          const r = this.editor;
          const s = r.t;
          const a = new ToolbarView(r.locale);
          a.ariaLabel = e || s("Widget toolbar");
          if (this._toolbarDefinitions.has(t)) {
            throw new CKEditorError("widget-toolbar-duplicated", this, { toolbarId: t });
          }
          const c = {
            view: a,
            getRelatedElement: o,
            balloonClassName: i,
            itemsConfig: n,
            initialized: false,
          };
          r.ui.addToolbar(a, {
            isContextual: true,
            beforeFocus: () => {
              const t = o(r.editing.view.document.selection);
              if (t) {
                this._showToolbar(c, t);
              }
            },
            afterBlur: () => {
              this._hideToolbar(c);
            },
          });
          this._toolbarDefinitions.set(t, c);
        }
        _updateToolbarsVisibility() {
          let t = 0;
          let e = null;
          let n = null;
          for (const o of this._toolbarDefinitions.values()) {
            const i = o.getRelatedElement(this.editor.editing.view.document.selection);
            if (!this.isEnabled || !i) {
              if (this._isToolbarInBalloon(o)) {
                this._hideToolbar(o);
              }
            } else if (!this.editor.ui.focusTracker.isFocused) {
              if (this._isToolbarVisible(o)) {
                this._hideToolbar(o);
              }
            } else {
              const r = i.getAncestors().length;
              if (r > t) {
                t = r;
                e = i;
                n = o;
              }
            }
          }
          if (n) {
            this._showToolbar(n, e);
          }
        }
        _hideToolbar(t) {
          this._balloon.remove(t.view);
          this.stopListening(this._balloon, "change:visibleView");
        }
        _showToolbar(t, e) {
          if (this._isToolbarVisible(t)) {
            _B(this.editor, e);
          } else if (!this._isToolbarInBalloon(t)) {
            if (!t.initialized) {
              t.initialized = true;
              t.view.fillFromConfig(t.itemsConfig, this.editor.ui.componentFactory);
            }
            this._balloon.add({
              view: t.view,
              position: vB(this.editor, e),
              balloonClassName: t.balloonClassName,
            });
            this.listenTo(this._balloon, "change:visibleView", () => {
              for (const t of this._toolbarDefinitions.values()) {
                if (this._isToolbarVisible(t)) {
                  const e = t.getRelatedElement(this.editor.editing.view.document.selection);
                  _B(this.editor, e);
                }
              }
            });
          }
        }
        _isToolbarVisible(t) {
          return this._balloon.visibleView === t.view;
        }
        _isToolbarInBalloon(t) {
          return this._balloon.hasView(t.view);
        }
      }
      function _B(t, e) {
        const n = t.plugins.get("ContextualBalloon");
        const o = vB(t, e);
        n.updatePosition(o);
      }
      function vB(t, e) {
        const n = t.editing.view;
        const o = BalloonPanelView.defaultPositions;
        return {
          target: n.domConverter.mapViewToDom(e),
          positions: [
            o.northArrowSouth,
            o.northArrowSouthWest,
            o.northArrowSouthEast,
            o.southArrowNorth,
            o.southArrowNorthWest,
            o.southArrowNorthEast,
            o.viewportStickyNorth,
          ],
        };
      }
      function AB(t) {
        const e = t.getSelectedElement();
        return !!(e && isWidget(e));
      }
      class CB extends lt() {
        constructor(t) {
          super();
          this.set("activeHandlePosition", null);
          this.set("proposedWidthPercents", null);
          this.set("proposedWidth", null);
          this.set("proposedHeight", null);
          this.set("proposedHandleHostWidth", null);
          this.set("proposedHandleHostHeight", null);
          this._options = t;
          this._referenceCoordinates = null;
        }
        get originalWidth() {
          return this._originalWidth;
        }
        get originalHeight() {
          return this._originalHeight;
        }
        get originalWidthPercents() {
          return this._originalWidthPercents;
        }
        get aspectRatio() {
          return this._aspectRatio;
        }
        begin(t, e, n) {
          const o = new ac(e);
          this.activeHandlePosition = DB(t);
          this._referenceCoordinates = xB(e, SB(this.activeHandlePosition));
          this._originalWidth = o.width;
          this._originalHeight = o.height;
          this._aspectRatio = o.width / o.height;
          const i = n.style.width;
          if (i && i.match(/^\d+(\.\d*)?%$/)) {
            this._originalWidthPercents = parseFloat(i);
          } else {
            this._originalWidthPercents = yB(n, o);
          }
        }
        update(t) {
          this.proposedWidth = t.width;
          this.proposedHeight = t.height;
          this.proposedWidthPercents = t.widthPercents;
          this.proposedHandleHostWidth = t.handleHostWidth;
          this.proposedHandleHostHeight = t.handleHostHeight;
        }
      }
      function yB(t, e) {
        const n = t.parentElement;
        let o = parseFloat(n.ownerDocument.defaultView.getComputedStyle(n).width);
        const i = 5;
        let r = 0;
        let s = n;
        while (isNaN(o)) {
          s = s.parentElement;
          if (++r > i) {
            return 0;
          }
          o = parseFloat(n.ownerDocument.defaultView.getComputedStyle(s).width);
        }
        return (e.width / o) * 100;
      }
      function xB(t, e) {
        const n = new ac(t);
        const o = e.split("-");
        const i = { x: o[1] == "right" ? n.right : n.left, y: o[0] == "bottom" ? n.bottom : n.top };
        i.x += t.ownerDocument.defaultView.scrollX;
        i.y += t.ownerDocument.defaultView.scrollY;
        return i;
      }
      function EB(t) {
        return `ck-widget__resizer__handle-${t}`;
      }
      function DB(t) {
        const e = ["top-left", "top-right", "bottom-right", "bottom-left"];
        for (const n of e) {
          if (t.classList.contains(EB(n))) {
            return n;
          }
        }
      }
      function SB(t) {
        const e = t.split("-");
        const n = { top: "bottom", bottom: "top", left: "right", right: "left" };
        return `${n[e[0]]}-${n[e[1]]}`;
      }
      class TB extends zl {
        constructor() {
          super();
          const t = this.bindTemplate;
          this.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-size-view",
                t.to("_viewPosition", (t) => (t ? `ck-orientation-${t}` : "")),
              ],
              style: { display: t.if("_isVisible", "none", (t) => !t) },
            },
            children: [{ text: t.to("_label") }],
          });
        }
        _bindToState(t, e) {
          this.bind("_isVisible").to(
            e,
            "proposedWidth",
            e,
            "proposedHeight",
            (t, e) => t !== null && e !== null
          );
          this.bind("_label").to(
            e,
            "proposedHandleHostWidth",
            e,
            "proposedHandleHostHeight",
            e,
            "proposedWidthPercents",
            (e, n, o) => {
              if (t.unit === "px") {
                return `${e}×${n}`;
              } else {
                return `${o}%`;
              }
            }
          );
          this.bind("_viewPosition").to(
            e,
            "activeHandlePosition",
            e,
            "proposedHandleHostWidth",
            e,
            "proposedHandleHostHeight",
            (t, e, n) => (e < 50 || n < 50 ? "above-center" : t)
          );
        }
        _dismiss() {
          this.unbind();
          this._isVisible = false;
        }
      }
      class PB extends lt() {
        constructor(t) {
          super();
          this._viewResizerWrapper = null;
          this._options = t;
          this.set("isEnabled", true);
          this.set("isSelected", false);
          this.bind("isVisible").to(this, "isEnabled", this, "isSelected", (t, e) => t && e);
          this.decorate("begin");
          this.decorate("cancel");
          this.decorate("commit");
          this.decorate("updateSize");
          this.on(
            "commit",
            (t) => {
              if (!this.state.proposedWidth && !this.state.proposedWidthPercents) {
                this._cleanup();
                t.stop();
              }
            },
            { priority: "high" }
          );
        }
        get state() {
          return this._state;
        }
        show() {
          const t = this._options.editor.editing.view;
          t.change((t) => {
            t.removeClass("ck-hidden", this._viewResizerWrapper);
          });
        }
        hide() {
          const t = this._options.editor.editing.view;
          t.change((t) => {
            t.addClass("ck-hidden", this._viewResizerWrapper);
          });
        }
        attach() {
          const t = this;
          const e = this._options.viewElement;
          const n = this._options.editor.editing.view;
          n.change((n) => {
            const o = n.createUIElement(
              "div",
              { class: "ck ck-reset_all ck-widget__resizer" },
              function (e) {
                const n = this.toDomElement(e);
                t._appendHandles(n);
                t._appendSizeUI(n);
                return n;
              }
            );
            n.insert(n.createPositionAt(e, "end"), o);
            n.addClass("ck-widget_with-resizer", e);
            this._viewResizerWrapper = o;
            if (!this.isVisible) {
              this.hide();
            }
          });
          this.on("change:isVisible", () => {
            if (this.isVisible) {
              this.show();
              this.redraw();
            } else {
              this.hide();
            }
          });
        }
        begin(t) {
          this._state = new CB(this._options);
          this._sizeView._bindToState(this._options, this.state);
          this._initialViewWidth = this._options.viewElement.getStyle("width");
          this.state.begin(t, this._getHandleHost(), this._getResizeHost());
        }
        updateSize(t) {
          const e = this._proposeNewSize(t);
          const n = this._options.editor.editing.view;
          n.change((t) => {
            const n = this._options.unit || "%";
            const o = (n === "%" ? e.widthPercents : e.width) + n;
            t.setStyle("width", o, this._options.viewElement);
          });
          const o = this._getHandleHost();
          const i = new ac(o);
          const r = Math.round(i.width);
          const s = Math.round(i.height);
          const a = new ac(o);
          e.width = Math.round(a.width);
          e.height = Math.round(a.height);
          this.redraw(i);
          this.state.update({ ...e, handleHostWidth: r, handleHostHeight: s });
        }
        commit() {
          const t = this._options.unit || "%";
          const e = (t === "%" ? this.state.proposedWidthPercents : this.state.proposedWidth) + t;
          this._options.editor.editing.view.change(() => {
            this._cleanup();
            this._options.onCommit(e);
          });
        }
        cancel() {
          this._cleanup();
        }
        destroy() {
          this.cancel();
        }
        redraw(t) {
          const e = this._domResizerWrapper;
          if (!RB(e)) {
            return;
          }
          const n = e.parentElement;
          const o = this._getHandleHost();
          const i = this._viewResizerWrapper;
          const r = [
            i.getStyle("width"),
            i.getStyle("height"),
            i.getStyle("left"),
            i.getStyle("top"),
          ];
          let s;
          if (n.isSameNode(o)) {
            const e = t || new ac(o);
            s = [e.width + "px", e.height + "px", undefined, undefined];
          } else {
            s = [
              o.offsetWidth + "px",
              o.offsetHeight + "px",
              o.offsetLeft + "px",
              o.offsetTop + "px",
            ];
          }
          if (At(r, s) !== "same") {
            this._options.editor.editing.view.change((t) => {
              t.setStyle({ width: s[0], height: s[1], left: s[2], top: s[3] }, i);
            });
          }
        }
        containsHandle(t) {
          return this._domResizerWrapper.contains(t);
        }
        static isResizeHandle(t) {
          return t.classList.contains("ck-widget__resizer__handle");
        }
        _cleanup() {
          this._sizeView._dismiss();
          const t = this._options.editor.editing.view;
          t.change((t) => {
            t.setStyle("width", this._initialViewWidth, this._options.viewElement);
          });
        }
        _proposeNewSize(t) {
          const e = this.state;
          const n = OB(t);
          const o = this._options.isCentered ? this._options.isCentered(this) : true;
          const i = {
            x: e._referenceCoordinates.x - (n.x + e.originalWidth),
            y: n.y - e.originalHeight - e._referenceCoordinates.y,
          };
          if (o && e.activeHandlePosition.endsWith("-right")) {
            i.x = n.x - (e._referenceCoordinates.x + e.originalWidth);
          }
          if (o) {
            i.x *= 2;
          }
          let r = Math.abs(e.originalWidth + i.x);
          let s = Math.abs(e.originalHeight + i.y);
          const a = r / e.aspectRatio > s ? "width" : "height";
          if (a == "width") {
            s = r / e.aspectRatio;
          } else {
            r = s * e.aspectRatio;
          }
          return {
            width: Math.round(r),
            height: Math.round(s),
            widthPercents: Math.min(
              Math.round((e.originalWidthPercents / e.originalWidth) * r * 100) / 100,
              100
            ),
          };
        }
        _getResizeHost() {
          const t = this._domResizerWrapper.parentElement;
          return this._options.getResizeHost(t);
        }
        _getHandleHost() {
          const t = this._domResizerWrapper.parentElement;
          return this._options.getHandleHost(t);
        }
        get _domResizerWrapper() {
          return this._options.editor.editing.view.domConverter.mapViewToDom(
            this._viewResizerWrapper
          );
        }
        _appendHandles(t) {
          const e = ["top-left", "top-right", "bottom-right", "bottom-left"];
          for (const n of e) {
            t.appendChild(
              new Ml({
                tag: "div",
                attributes: { class: `ck-widget__resizer__handle ${BB(n)}` },
              }).render()
            );
          }
        }
        _appendSizeUI(t) {
          this._sizeView = new TB();
          this._sizeView.render();
          t.appendChild(this._sizeView.element);
        }
      }
      function BB(t) {
        return `ck-widget__resizer__handle-${t}`;
      }
      function OB(t) {
        return { x: t.pageX, y: t.pageY };
      }
      function RB(t) {
        return t && t.ownerDocument && t.ownerDocument.contains(t);
      }
      var IB = n(875);
      var zB = { injectType: "singletonStyleTag", attributes: { "data-cke": true } };
      zB.insert = "head";
      zB.singleton = true;
      var FB = Pl()(IB.Z, zB);
      const MB = IB.Z.locals || {};
      class NB extends (null && Plugin) {
        constructor() {
          super(...arguments);
          this._resizers = new Map();
        }
        static get pluginName() {
          return "WidgetResize";
        }
        init() {
          const t = this.editor.editing;
          const e = global.window.document;
          this.set("selectedResizer", null);
          this.set("_activeResizer", null);
          t.view.addObserver(MouseObserver);
          this._observer = new (DomEmitterMixin())();
          this.listenTo(t.view.document, "mousedown", this._mouseDownListener.bind(this), {
            priority: "high",
          });
          this._observer.listenTo(e, "mousemove", this._mouseMoveListener.bind(this));
          this._observer.listenTo(e, "mouseup", this._mouseUpListener.bind(this));
          this._redrawSelectedResizerThrottled = throttle(() => this.redrawSelectedResizer(), 200);
          this.editor.ui.on("update", this._redrawSelectedResizerThrottled);
          this.editor.model.document.on(
            "change",
            () => {
              for (const [t, e] of this._resizers) {
                if (!t.isAttached()) {
                  this._resizers.delete(t);
                  e.destroy();
                }
              }
            },
            { priority: "lowest" }
          );
          this._observer.listenTo(global.window, "resize", this._redrawSelectedResizerThrottled);
          const n = this.editor.editing.view.document.selection;
          n.on("change", () => {
            const t = n.getSelectedElement();
            const e = this.getResizerByViewElement(t) || null;
            if (e) {
              this.select(e);
            } else {
              this.deselect();
            }
          });
        }
        redrawSelectedResizer() {
          if (this.selectedResizer && this.selectedResizer.isVisible) {
            this.selectedResizer.redraw();
          }
        }
        destroy() {
          super.destroy();
          this._observer.stopListening();
          for (const t of this._resizers.values()) {
            t.destroy();
          }
          this._redrawSelectedResizerThrottled.cancel();
        }
        select(t) {
          this.deselect();
          this.selectedResizer = t;
          this.selectedResizer.isSelected = true;
        }
        deselect() {
          if (this.selectedResizer) {
            this.selectedResizer.isSelected = false;
          }
          this.selectedResizer = null;
        }
        attachTo(t) {
          const e = new Resizer(t);
          const n = this.editor.plugins;
          e.attach();
          if (n.has("WidgetToolbarRepository")) {
            const t = n.get("WidgetToolbarRepository");
            e.on(
              "begin",
              () => {
                t.forceDisabled("resize");
              },
              { priority: "lowest" }
            );
            e.on(
              "cancel",
              () => {
                t.clearForceDisabled("resize");
              },
              { priority: "highest" }
            );
            e.on(
              "commit",
              () => {
                t.clearForceDisabled("resize");
              },
              { priority: "highest" }
            );
          }
          this._resizers.set(t.viewElement, e);
          const o = this.editor.editing.view.document.selection;
          const i = o.getSelectedElement();
          if (this.getResizerByViewElement(i) == e) {
            this.select(e);
          }
          return e;
        }
        getResizerByViewElement(t) {
          return this._resizers.get(t);
        }
        _getResizerByHandle(t) {
          for (const e of this._resizers.values()) {
            if (e.containsHandle(t)) {
              return e;
            }
          }
        }
        _mouseDownListener(t, e) {
          const n = e.domTarget;
          if (!Resizer.isResizeHandle(n)) {
            return;
          }
          this._activeResizer = this._getResizerByHandle(n) || null;
          if (this._activeResizer) {
            this._activeResizer.begin(n);
            t.stop();
            e.preventDefault();
          }
        }
        _mouseMoveListener(t, e) {
          if (this._activeResizer) {
            this._activeResizer.updateSize(e);
          }
        }
        _mouseUpListener() {
          if (this._activeResizer) {
            this._activeResizer.commit();
            this._activeResizer = null;
          }
        }
      }
      const VB = mc("px");
      class LB extends zl {
        constructor() {
          super();
          const t = this.bindTemplate;
          this.set({ isVisible: false, left: null, top: null, width: null });
          this.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-clipboard-drop-target-line",
                t.if("isVisible", "ck-hidden", (t) => !t),
              ],
              style: {
                left: t.to("left", (t) => VB(t)),
                top: t.to("top", (t) => VB(t)),
                width: t.to("width", (t) => VB(t)),
              },
            },
          });
        }
      }
      class HB extends nu {
        constructor() {
          super(...arguments);
          this.removeDropMarkerDelayed = kl(() => this.removeDropMarker(), 40);
          this._updateDropMarkerThrottled = TE((t) => this._updateDropMarker(t), 40);
          this._reconvertMarkerThrottled = TE(() => {
            if (this.editor.model.markers.has("drop-target")) {
              this.editor.editing.reconvertMarker("drop-target");
            }
          }, 0);
          this._dropTargetLineView = new LB();
          this._domEmitter = new (Ka())();
          this._scrollables = new Map();
        }
        static get pluginName() {
          return "DragDropTarget";
        }
        init() {
          this._setupDropMarker();
        }
        destroy() {
          this._domEmitter.stopListening();
          for (const { resizeObserver: t } of this._scrollables.values()) {
            t.destroy();
          }
          this._updateDropMarkerThrottled.cancel();
          this.removeDropMarkerDelayed.cancel();
          this._reconvertMarkerThrottled.cancel();
          return super.destroy();
        }
        updateDropMarker(t, e, n, o, i) {
          this.removeDropMarkerDelayed.cancel();
          const r = jB(this.editor, t, e, n, o, i);
          if (r) {
            this._updateDropMarkerThrottled(r);
          }
        }
        getFinalDropRange(t, e, n, o, i) {
          const r = jB(this.editor, t, e, n, o, i);
          this.removeDropMarker();
          return r;
        }
        removeDropMarker() {
          const t = this.editor.model;
          this.removeDropMarkerDelayed.cancel();
          this._updateDropMarkerThrottled.cancel();
          this._dropTargetLineView.isVisible = false;
          if (t.markers.has("drop-target")) {
            t.change((t) => {
              t.removeMarker("drop-target");
            });
          }
        }
        _setupDropMarker() {
          const t = this.editor;
          t.ui.view.body.add(this._dropTargetLineView);
          t.conversion
            .for("editingDowncast")
            .markerToHighlight({
              model: "drop-target",
              view: { classes: ["ck-clipboard-drop-target-range"] },
            });
          t.conversion.for("editingDowncast").markerToElement({
            model: "drop-target",
            view: (e, { writer: n }) => {
              if (t.model.schema.checkChild(e.markerRange.start, "$text")) {
                this._dropTargetLineView.isVisible = false;
                return this._createDropTargetPosition(n);
              } else {
                if (e.markerRange.isCollapsed) {
                  this._updateDropTargetLine(e.markerRange);
                } else {
                  this._dropTargetLineView.isVisible = false;
                }
              }
            },
          });
        }
        _updateDropMarker(t) {
          const e = this.editor;
          const n = e.model.markers;
          e.model.change((e) => {
            if (n.has("drop-target")) {
              if (!n.get("drop-target").getRange().isEqual(t)) {
                e.updateMarker("drop-target", { range: t });
              }
            } else {
              e.addMarker("drop-target", { range: t, usingOperation: false, affectsData: false });
            }
          });
        }
        _createDropTargetPosition(t) {
          return t.createUIElement(
            "span",
            { class: "ck ck-clipboard-drop-target-position" },
            function (t) {
              const e = this.toDomElement(t);
              e.append("⁠", t.createElement("span"), "⁠");
              return e;
            }
          );
        }
        _updateDropTargetLine(t) {
          const e = this.editor.editing;
          const n = t.start.nodeBefore;
          const o = t.start.nodeAfter;
          const i = t.start.parent;
          const r = n ? e.mapper.toViewElement(n) : null;
          const s = r ? e.view.domConverter.mapViewToDom(r) : null;
          const a = o ? e.mapper.toViewElement(o) : null;
          const c = a ? e.view.domConverter.mapViewToDom(a) : null;
          const l = e.mapper.toViewElement(i);
          const d = e.view.domConverter.mapViewToDom(l);
          const h = this._getScrollableRect(l);
          const { scrollX: u, scrollY: f } = Qa.window;
          const p = s ? new ac(s) : null;
          const g = c ? new ac(c) : null;
          const m = new ac(d).excludeScrollbarsAndBorders();
          const k = p ? p.bottom : m.top;
          const b = g ? g.top : m.bottom;
          const w = Qa.window.getComputedStyle(d);
          const _ = k <= b ? (k + b) / 2 : b;
          if (h.top < _ && _ < h.bottom) {
            const t = m.left + parseFloat(w.paddingLeft);
            const e = m.right - parseFloat(w.paddingRight);
            const n = Math.max(t + u, h.left);
            const o = Math.min(e + u, h.right);
            this._dropTargetLineView.set({ isVisible: true, left: n, top: _ + f, width: o - n });
          } else {
            this._dropTargetLineView.isVisible = false;
          }
        }
        _getScrollableRect(t) {
          const e = t.root.rootName;
          let n;
          if (this._scrollables.has(e)) {
            n = this._scrollables.get(e).domElement;
          } else {
            const o = this.editor.editing.view.domConverter.mapViewToDom(t);
            n = KB(o);
            this._domEmitter.listenTo(n, "scroll", this._reconvertMarkerThrottled, {
              usePassive: true,
            });
            const i = new pc(n, this._reconvertMarkerThrottled);
            this._scrollables.set(e, { domElement: n, resizeObserver: i });
          }
          return new ac(n).excludeScrollbarsAndBorders();
        }
      }
      function jB(t, e, n, o, i, r) {
        const s = t.model;
        const a = t.editing.mapper;
        const c = GB(t, e);
        let l = c;
        while (l) {
          if (!r) {
            if (s.schema.checkChild(l, "$text")) {
              const e = n ? n[0].start : null;
              const r = e ? a.toModelPosition(e) : null;
              if (r) {
                if (s.schema.checkChild(r, "$text")) {
                  return s.createRange(r);
                } else if (e) {
                  return $B(t, GB(t, e.parent), o, i);
                }
              }
            } else if (s.schema.isInline(l)) {
              return $B(t, l, o, i);
            }
          }
          if (s.schema.isBlock(l)) {
            return $B(t, l, o, i);
          } else if (s.schema.checkChild(l, "$block")) {
            const e = Array.from(l.getChildren()).filter((e) => e.is("element") && !qB(t, e));
            let n = 0;
            let r = e.length;
            if (r == 0) {
              return s.createRange(s.createPositionAt(l, "end"));
            }
            while (n < r - 1) {
              const s = Math.floor((n + r) / 2);
              const a = WB(t, e[s], o, i);
              if (a == "before") {
                r = s;
              } else {
                n = s;
              }
            }
            return $B(t, e[n], o, i);
          }
          l = l.parent;
        }
        return null;
      }
      function qB(t, e) {
        const n = t.editing.mapper;
        const o = t.editing.view.domConverter;
        const i = n.toViewElement(e);
        const r = o.mapViewToDom(i);
        return Qa.window.getComputedStyle(r).float != "none";
      }
      function $B(t, e, n, o) {
        const i = t.model;
        return i.createRange(i.createPositionAt(e, WB(t, e, n, o)));
      }
      function WB(t, e, n, o) {
        const i = t.editing.mapper;
        const r = t.editing.view.domConverter;
        const s = i.toViewElement(e);
        const a = r.mapViewToDom(s);
        const c = new ac(a);
        if (t.model.schema.isInline(e)) {
          return n < (c.left + c.right) / 2 ? "before" : "after";
        } else {
          return o < (c.top + c.bottom) / 2 ? "before" : "after";
        }
      }
      function GB(t, e) {
        const n = t.editing.mapper;
        const o = t.editing.view;
        const i = n.toModelElement(e);
        if (i) {
          return i;
        }
        const r = o.createPositionBefore(e);
        const s = n.findMappedViewAncestor(r);
        return n.toModelElement(s);
      }
      function KB(t) {
        let e = t;
        do {
          e = e.parentElement;
          const t = Qa.window.getComputedStyle(e).overflowY;
          if (t == "auto" || t == "scroll") {
            break;
          }
        } while (e.tagName != "BODY");
        return e;
      }
      class UB extends nu {
        constructor() {
          super(...arguments);
          this._isBlockDragging = false;
          this._domEmitter = new (Ka())();
        }
        static get pluginName() {
          return "DragDropBlockToolbar";
        }
        init() {
          const t = this.editor;
          this.listenTo(t, "change:isReadOnly", (t, e, n) => {
            if (n) {
              this.forceDisabled("readOnlyMode");
              this._isBlockDragging = false;
            } else {
              this.clearForceDisabled("readOnlyMode");
            }
          });
          if (r.isAndroid) {
            this.forceDisabled("noAndroidSupport");
          }
          if (t.plugins.has("BlockToolbar")) {
            const e = t.plugins.get("BlockToolbar");
            const n = e.buttonView.element;
            this._domEmitter.listenTo(n, "dragstart", (t, e) => this._handleBlockDragStart(e));
            this._domEmitter.listenTo(Qa.document, "dragover", (t, e) =>
              this._handleBlockDragging(e)
            );
            this._domEmitter.listenTo(Qa.document, "drop", (t, e) => this._handleBlockDragging(e));
            this._domEmitter.listenTo(Qa.document, "dragend", () => this._handleBlockDragEnd(), {
              useCapture: true,
            });
            if (this.isEnabled) {
              n.setAttribute("draggable", "true");
            }
            this.on("change:isEnabled", (t, e, o) => {
              n.setAttribute("draggable", o ? "true" : "false");
            });
          }
        }
        destroy() {
          this._domEmitter.stopListening();
          return super.destroy();
        }
        _handleBlockDragStart(t) {
          if (!this.isEnabled) {
            return;
          }
          const e = this.editor.model;
          const n = e.document.selection;
          const o = this.editor.editing.view;
          const i = Array.from(n.getSelectedBlocks());
          const r = e.createRange(
            e.createPositionBefore(i[0]),
            e.createPositionAfter(i[i.length - 1])
          );
          e.change((t) => t.setSelection(r));
          this._isBlockDragging = true;
          o.focus();
          o.getObserver(iP).onDomEvent(t);
        }
        _handleBlockDragging(t) {
          if (!this.isEnabled || !this._isBlockDragging) {
            return;
          }
          const e = t.clientX + (this.editor.locale.contentLanguageDirection == "ltr" ? 100 : -100);
          const n = t.clientY;
          const o = document.elementFromPoint(e, n);
          const i = this.editor.editing.view;
          if (!o || !o.closest(".ck-editor__editable")) {
            return;
          }
          i.getObserver(iP).onDomEvent({
            ...t,
            type: t.type,
            dataTransfer: t.dataTransfer,
            target: o,
            clientX: e,
            clientY: n,
            preventDefault: () => t.preventDefault(),
            stopPropagation: () => t.stopPropagation(),
          });
        }
        _handleBlockDragEnd() {
          this._isBlockDragging = false;
        }
      }
      var ZB = n(799);
      var JB = { injectType: "singletonStyleTag", attributes: { "data-cke": true } };
      JB.insert = "head";
      JB.singleton = true;
      var YB = Pl()(ZB.Z, JB);
      const QB = ZB.Z.locals || {};
      class XB extends nu {
        constructor() {
          super(...arguments);
          this._clearDraggableAttributesDelayed = kl(() => this._clearDraggableAttributes(), 40);
          this._blockMode = false;
          this._domEmitter = new (Ka())();
        }
        static get pluginName() {
          return "DragDrop";
        }
        static get requires() {
          return [dP, mB, HB, UB];
        }
        init() {
          const t = this.editor;
          const e = t.editing.view;
          this._draggedRange = null;
          this._draggingUid = "";
          this._draggableElement = null;
          e.addObserver(iP);
          e.addObserver(oA);
          this._setupDragging();
          this._setupContentInsertionIntegration();
          this._setupClipboardInputIntegration();
          this._setupDraggableAttributeHandling();
          this.listenTo(t, "change:isReadOnly", (t, e, n) => {
            if (n) {
              this.forceDisabled("readOnlyMode");
            } else {
              this.clearForceDisabled("readOnlyMode");
            }
          });
          this.on("change:isEnabled", (t, e, n) => {
            if (!n) {
              this._finalizeDragging(false);
            }
          });
          if (r.isAndroid) {
            this.forceDisabled("noAndroidSupport");
          }
        }
        destroy() {
          if (this._draggedRange) {
            this._draggedRange.detach();
            this._draggedRange = null;
          }
          if (this._previewContainer) {
            this._previewContainer.remove();
          }
          this._domEmitter.stopListening();
          this._clearDraggableAttributesDelayed.cancel();
          return super.destroy();
        }
        _setupDragging() {
          const t = this.editor;
          const e = t.model;
          const n = t.editing.view;
          const o = n.document;
          const i = t.plugins.get(HB);
          this.listenTo(
            o,
            "dragstart",
            (t, n) => {
              if (n.target && n.target.is("editableElement")) {
                n.preventDefault();
                return;
              }
              this._prepareDraggedRange(n.target);
              if (!this._draggedRange) {
                n.preventDefault();
                return;
              }
              this._draggingUid = x();
              n.dataTransfer.effectAllowed = this.isEnabled ? "copyMove" : "copy";
              n.dataTransfer.setData("application/ckeditor5-dragging-uid", this._draggingUid);
              const o = e.createSelection(this._draggedRange.toRange());
              const i = this.editor.plugins.get("ClipboardPipeline");
              i._fireOutputTransformationEvent(n.dataTransfer, o, "dragstart");
              const { dataTransfer: r, domTarget: s, domEvent: a } = n;
              const { clientX: c } = a;
              this._updatePreview({ dataTransfer: r, domTarget: s, clientX: c });
              n.stopPropagation();
              if (!this.isEnabled) {
                this._draggedRange.detach();
                this._draggedRange = null;
                this._draggingUid = "";
              }
            },
            { priority: "low" }
          );
          this.listenTo(
            o,
            "dragend",
            (t, e) => {
              this._finalizeDragging(
                !e.dataTransfer.isCanceled && e.dataTransfer.dropEffect == "move"
              );
            },
            { priority: "low" }
          );
          this._domEmitter.listenTo(
            Qa.document,
            "dragend",
            () => {
              this._blockMode = false;
            },
            { useCapture: true }
          );
          this.listenTo(o, "dragenter", () => {
            if (!this.isEnabled) {
              return;
            }
            n.focus();
          });
          this.listenTo(o, "dragleave", () => {
            i.removeDropMarkerDelayed();
          });
          this.listenTo(
            o,
            "dragging",
            (t, e) => {
              if (!this.isEnabled) {
                e.dataTransfer.dropEffect = "none";
                return;
              }
              const { clientX: n, clientY: o } = e.domEvent;
              i.updateDropMarker(e.target, e.targetRanges, n, o, this._blockMode);
              if (!this._draggedRange) {
                e.dataTransfer.dropEffect = "copy";
              }
              if (!r.isGecko) {
                if (e.dataTransfer.effectAllowed == "copy") {
                  e.dataTransfer.dropEffect = "copy";
                } else if (["all", "copyMove"].includes(e.dataTransfer.effectAllowed)) {
                  e.dataTransfer.dropEffect = "move";
                }
              }
              t.stop();
            },
            { priority: "low" }
          );
        }
        _setupClipboardInputIntegration() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document;
          const o = t.plugins.get(HB);
          this.listenTo(
            n,
            "clipboardInput",
            (e, n) => {
              if (n.method != "drop") {
                return;
              }
              const { clientX: i, clientY: r } = n.domEvent;
              const s = o.getFinalDropRange(n.target, n.targetRanges, i, r, this._blockMode);
              if (!s) {
                this._finalizeDragging(false);
                e.stop();
                return;
              }
              if (
                this._draggedRange &&
                this._draggingUid != n.dataTransfer.getData("application/ckeditor5-dragging-uid")
              ) {
                this._draggedRange.detach();
                this._draggedRange = null;
                this._draggingUid = "";
              }
              const a = tO(n.dataTransfer) == "move";
              if (a && this._draggedRange && this._draggedRange.containsRange(s, true)) {
                this._finalizeDragging(false);
                e.stop();
                return;
              }
              n.targetRanges = [t.editing.mapper.toViewRange(s)];
            },
            { priority: "high" }
          );
        }
        _setupContentInsertionIntegration() {
          const t = this.editor.plugins.get(dP);
          t.on(
            "contentInsertion",
            (t, e) => {
              if (!this.isEnabled || e.method !== "drop") {
                return;
              }
              const n = e.targetRanges.map((t) => this.editor.editing.mapper.toModelRange(t));
              this.editor.model.change((t) => t.setSelection(n));
            },
            { priority: "high" }
          );
          t.on(
            "contentInsertion",
            (t, e) => {
              if (!this.isEnabled || e.method !== "drop") {
                return;
              }
              const n = tO(e.dataTransfer) == "move";
              const o = !e.resultRange || !e.resultRange.isCollapsed;
              this._finalizeDragging(o && n);
            },
            { priority: "lowest" }
          );
        }
        _setupDraggableAttributeHandling() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document;
          this.listenTo(n, "mousedown", (o, i) => {
            if (r.isAndroid || !i) {
              return;
            }
            this._clearDraggableAttributesDelayed.cancel();
            let s = eO(i.target);
            if (r.isBlink && !t.isReadOnly && !s && !n.selection.isCollapsed) {
              const t = n.selection.getSelectedElement();
              if (!t || !TP(t)) {
                s = n.selection.editableElement;
              }
            }
            if (s) {
              e.change((t) => {
                t.setAttribute("draggable", "true", s);
              });
              this._draggableElement = t.editing.mapper.toModelElement(s);
            }
          });
          this.listenTo(n, "mouseup", () => {
            if (!r.isAndroid) {
              this._clearDraggableAttributesDelayed();
            }
          });
        }
        _clearDraggableAttributes() {
          const t = this.editor.editing;
          t.view.change((e) => {
            if (this._draggableElement && this._draggableElement.root.rootName != "$graveyard") {
              e.removeAttribute("draggable", t.mapper.toViewElement(this._draggableElement));
            }
            this._draggableElement = null;
          });
        }
        _finalizeDragging(t) {
          const e = this.editor;
          const n = e.model;
          const o = e.plugins.get(HB);
          o.removeDropMarker();
          this._clearDraggableAttributes();
          if (e.plugins.has("WidgetToolbarRepository")) {
            const t = e.plugins.get("WidgetToolbarRepository");
            t.clearForceDisabled("dragDrop");
          }
          this._draggingUid = "";
          if (this._previewContainer) {
            this._previewContainer.remove();
            this._previewContainer = undefined;
          }
          if (!this._draggedRange) {
            return;
          }
          if (t && this.isEnabled) {
            n.change((t) => {
              const e = n.createSelection(this._draggedRange);
              n.deleteContent(e, { doNotAutoparagraph: true });
              const o = e.getFirstPosition().parent;
              if (
                o.isEmpty &&
                !n.schema.checkChild(o, "$text") &&
                n.schema.checkChild(o, "paragraph")
              ) {
                t.insertElement("paragraph", o, 0);
              }
            });
          }
          this._draggedRange.detach();
          this._draggedRange = null;
        }
        _prepareDraggedRange(t) {
          const e = this.editor;
          const n = e.model;
          const o = n.document.selection;
          const i = t ? eO(t) : null;
          if (i) {
            const t = e.editing.mapper.toModelElement(i);
            this._draggedRange = rb.fromRange(n.createRangeOn(t));
            this._blockMode = n.schema.isBlock(t);
            if (e.plugins.has("WidgetToolbarRepository")) {
              const t = e.plugins.get("WidgetToolbarRepository");
              t.forceDisabled("dragDrop");
            }
            return;
          }
          if (o.isCollapsed && !o.getFirstPosition().parent.isEmpty) {
            return;
          }
          const r = Array.from(o.getSelectedBlocks());
          const s = o.getFirstRange();
          if (r.length == 0) {
            this._draggedRange = rb.fromRange(s);
            return;
          }
          const a = nO(n, r);
          if (r.length > 1) {
            this._draggedRange = rb.fromRange(a);
            this._blockMode = true;
          } else if (r.length == 1) {
            const t = s.start.isTouching(a.start) && s.end.isTouching(a.end);
            this._draggedRange = rb.fromRange(t ? a : s);
            this._blockMode = t;
          }
          n.change((t) => t.setSelection(this._draggedRange.toRange()));
        }
        _updatePreview({ dataTransfer: t, domTarget: e, clientX: n }) {
          const o = this.editor.editing.view;
          const i = o.document.selection.editableElement;
          const s = o.domConverter.mapViewToDom(i);
          const a = Qa.window.getComputedStyle(s);
          if (!this._previewContainer) {
            this._previewContainer = Xt(Qa.document, "div", {
              style: "position: fixed; left: -999999px;",
            });
            Qa.document.body.appendChild(this._previewContainer);
          } else if (this._previewContainer.firstElementChild) {
            this._previewContainer.removeChild(this._previewContainer.firstElementChild);
          }
          const c = new ac(s);
          if (s.contains(e)) {
            return;
          }
          const l = parseFloat(a.paddingLeft);
          const d = Xt(Qa.document, "div");
          d.className = "ck ck-content";
          d.style.width = a.width;
          d.style.paddingLeft = `${c.left - n + l}px`;
          if (r.isiOS) {
            d.style.backgroundColor = "white";
          }
          d.innerHTML = t.getData("text/html");
          t.setDragImage(d, 0, 0);
          this._previewContainer.appendChild(d);
        }
      }
      function tO(t) {
        if (r.isGecko) {
          return t.dropEffect;
        }
        return ["all", "copyMove"].includes(t.effectAllowed) ? "move" : "copy";
      }
      function eO(t) {
        if (t.is("editableElement")) {
          return null;
        }
        if (t.hasClass("ck-widget__selection-handle")) {
          return t.findAncestor(TP);
        }
        if (TP(t)) {
          return t;
        }
        const e = t.findAncestor((t) => TP(t) || t.is("editableElement"));
        if (TP(e)) {
          return e;
        }
        return null;
      }
      function nO(t, e) {
        const n = e[0];
        const o = e[e.length - 1];
        const i = n.getCommonAncestor(o);
        const r = t.createPositionBefore(n);
        const s = t.createPositionAfter(o);
        if (i && i.is("element") && !t.schema.isLimit(i)) {
          const e = t.createRangeOn(i);
          const n = r.isTouching(e.start);
          const o = s.isTouching(e.end);
          if (n && o) {
            return nO(t, [i]);
          }
        }
        return t.createRange(r, s);
      }
      class oO extends nu {
        static get pluginName() {
          return "PastePlainText";
        }
        static get requires() {
          return [dP];
        }
        init() {
          const t = this.editor;
          const e = t.model;
          const n = t.editing.view;
          const o = n.document;
          const i = e.document.selection;
          let r = false;
          n.addObserver(iP);
          this.listenTo(o, "keydown", (t, e) => {
            r = e.shiftKey;
          });
          t.plugins.get(dP).on("contentInsertion", (t, n) => {
            if (!r && !iO(n.content, e.schema)) {
              return;
            }
            e.change((t) => {
              const o = Array.from(i.getAttributes()).filter(
                ([t]) => e.schema.getAttributeProperties(t).isFormatting
              );
              if (!i.isCollapsed) {
                e.deleteContent(i, { doNotAutoparagraph: true });
              }
              o.push(...i.getAttributes());
              const r = t.createRangeIn(n.content);
              for (const e of r.getItems()) {
                if (e.is("$textProxy")) {
                  t.setAttributes(o, e);
                }
              }
            });
          });
        }
      }
      function iO(t, e) {
        if (t.childCount > 1) {
          return false;
        }
        const n = t.getChild(0);
        if (e.isObject(n)) {
          return false;
        }
        return Array.from(n.getAttributeKeys()).length == 0;
      }
      class rO extends nu {
        static get pluginName() {
          return "Clipboard";
        }
        static get requires() {
          return [dP, XB, oO];
        }
      }
      class sO extends iu {
        constructor(t) {
          super(t);
          this.affectsData = false;
        }
        execute() {
          const t = this.editor.model;
          const e = t.document.selection;
          let n = t.schema.getLimitElement(e);
          if (e.containsEntireContent(n) || !aO(t.schema, n)) {
            do {
              n = n.parent;
              if (!n) {
                return;
              }
            } while (!aO(t.schema, n));
          }
          t.change((t) => {
            t.setSelection(n, "in");
          });
        }
      }
      function aO(t, e) {
        return t.isLimit(e) && (t.checkChild(e, "$text") || t.checkChild(e, "paragraph"));
      }
      const cO = Wc("Ctrl+A");
      class lO extends nu {
        static get pluginName() {
          return "SelectAllEditing";
        }
        init() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document;
          t.commands.add("selectAll", new sO(t));
          this.listenTo(n, "keydown", (e, n) => {
            if ($c(n) === cO) {
              t.execute("selectAll");
              n.preventDefault();
            }
          });
        }
      }
      const dO =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z"/></svg>';
      class hO extends nu {
        static get pluginName() {
          return "SelectAllUI";
        }
        init() {
          const t = this.editor;
          t.ui.componentFactory.add("selectAll", (e) => {
            const n = t.commands.get("selectAll");
            const o = new vd(e);
            const i = e.t;
            o.set({ label: i("Select all"), icon: dO, keystroke: "Ctrl+A", tooltip: true });
            o.bind("isEnabled").to(n, "isEnabled");
            this.listenTo(o, "execute", () => {
              t.execute("selectAll");
              t.editing.view.focus();
            });
            return o;
          });
        }
      }
      class uO extends nu {
        static get requires() {
          return [lO, hO];
        }
        static get pluginName() {
          return "SelectAll";
        }
      }
      class fO extends iu {
        constructor(t) {
          super(t);
          this._stack = [];
          this._createdBatches = new WeakSet();
          this.refresh();
          this._isEnabledBasedOnSelection = false;
          this.listenTo(
            t.data,
            "set",
            (t, e) => {
              e[1] = { ...e[1] };
              const n = e[1];
              if (!n.batchType) {
                n.batchType = { isUndoable: false };
              }
            },
            { priority: "high" }
          );
          this.listenTo(t.data, "set", (t, e) => {
            const n = e[1];
            if (!n.batchType.isUndoable) {
              this.clearStack();
            }
          });
        }
        refresh() {
          this.isEnabled = this._stack.length > 0;
        }
        get createdBatches() {
          return this._createdBatches;
        }
        addBatch(t) {
          const e = this.editor.model.document.selection;
          const n = {
            ranges: e.hasOwnRange ? Array.from(e.getRanges()) : [],
            isBackward: e.isBackward,
          };
          this._stack.push({ batch: t, selection: n });
          this.refresh();
        }
        clearStack() {
          this._stack = [];
          this.refresh();
        }
        _restoreSelection(t, e, n) {
          const o = this.editor.model;
          const i = o.document;
          const r = [];
          const s = t.map((t) => t.getTransformedByOperations(n));
          const a = s.flat();
          for (const t of s) {
            const e = t.filter((t) => t.root != i.graveyard).filter((t) => !gO(t, a));
            if (!e.length) {
              continue;
            }
            pO(e);
            r.push(e[0]);
          }
          if (r.length) {
            o.change((t) => {
              t.setSelection(r, { backward: e });
            });
          }
        }
        _undo(t, e) {
          const n = this.editor.model;
          const o = n.document;
          this._createdBatches.add(e);
          const i = t.operations.slice().filter((t) => t.isDocumentOperation);
          i.reverse();
          for (const t of i) {
            const i = t.baseVersion + 1;
            const r = Array.from(o.history.getOperations(i));
            const s = G_([t.getReversed()], r, {
              useRelations: true,
              document: this.editor.model.document,
              padWithNoOps: false,
              forceWeakRemove: true,
            });
            const a = s.operationsA;
            for (let i of a) {
              const r = i.affectedSelectable;
              if (r && !n.canEditAt(r)) {
                i = new z_(i.baseVersion);
              }
              e.addOperation(i);
              n.applyOperation(i);
              o.history.setOperationAsUndone(t, i);
            }
          }
        }
      }
      function pO(t) {
        t.sort((t, e) => (t.start.isBefore(e.start) ? -1 : 1));
        for (let e = 1; e < t.length; e++) {
          const n = t[e - 1];
          const o = n.getJoined(t[e], true);
          if (o) {
            e--;
            t.splice(e, 2, o);
          }
        }
      }
      function gO(t, e) {
        return e.some((e) => e !== t && e.containsRange(t, true));
      }
      class mO extends fO {
        execute(t = null) {
          const e = t ? this._stack.findIndex((e) => e.batch == t) : this._stack.length - 1;
          const n = this._stack.splice(e, 1)[0];
          const o = this.editor.model.createBatch({ isUndo: true });
          this.editor.model.enqueueChange(o, () => {
            this._undo(n.batch, o);
            const t = this.editor.model.document.history.getOperations(n.batch.baseVersion);
            this._restoreSelection(n.selection.ranges, n.selection.isBackward, t);
          });
          this.fire("revert", n.batch, o);
          this.refresh();
        }
      }
      class kO extends fO {
        execute() {
          const t = this._stack.pop();
          const e = this.editor.model.createBatch({ isUndo: true });
          this.editor.model.enqueueChange(e, () => {
            const n = t.batch.operations[t.batch.operations.length - 1];
            const o = n.baseVersion + 1;
            const i = this.editor.model.document.history.getOperations(o);
            this._restoreSelection(t.selection.ranges, t.selection.isBackward, i);
            this._undo(t.batch, e);
          });
          this.refresh();
        }
      }
      class bO extends nu {
        constructor() {
          super(...arguments);
          this._batchRegistry = new WeakSet();
        }
        static get pluginName() {
          return "UndoEditing";
        }
        init() {
          const t = this.editor;
          this._undoCommand = new mO(t);
          this._redoCommand = new kO(t);
          t.commands.add("undo", this._undoCommand);
          t.commands.add("redo", this._redoCommand);
          this.listenTo(
            t.model,
            "applyOperation",
            (t, e) => {
              const n = e[0];
              if (!n.isDocumentOperation) {
                return;
              }
              const o = n.batch;
              const i = this._redoCommand.createdBatches.has(o);
              const r = this._undoCommand.createdBatches.has(o);
              const s = this._batchRegistry.has(o);
              if (s) {
                return;
              }
              this._batchRegistry.add(o);
              if (!o.isUndoable) {
                return;
              }
              if (i) {
                this._undoCommand.addBatch(o);
              } else if (!r) {
                this._undoCommand.addBatch(o);
                this._redoCommand.clearStack();
              }
            },
            { priority: "highest" }
          );
          this.listenTo(this._undoCommand, "revert", (t, e, n) => {
            this._redoCommand.addBatch(n);
          });
          t.keystrokes.set("CTRL+Z", "undo");
          t.keystrokes.set("CTRL+Y", "redo");
          t.keystrokes.set("CTRL+SHIFT+Z", "redo");
        }
      }
      const wO =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m5.042 9.367 2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z"/></svg>';
      const _O =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m14.958 9.367-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z"/></svg>';
      class vO extends nu {
        static get pluginName() {
          return "UndoUI";
        }
        init() {
          const t = this.editor;
          const e = t.locale;
          const n = t.t;
          const o = e.uiLanguageDirection == "ltr" ? wO : _O;
          const i = e.uiLanguageDirection == "ltr" ? _O : wO;
          this._addButton("undo", n("Undo"), "CTRL+Z", o);
          this._addButton("redo", n("Redo"), "CTRL+Y", i);
        }
        _addButton(t, e, n, o) {
          const i = this.editor;
          i.ui.componentFactory.add(t, (r) => {
            const s = i.commands.get(t);
            const a = new vd(r);
            a.set({ label: e, icon: o, keystroke: n, tooltip: true });
            a.bind("isEnabled").to(s, "isEnabled");
            this.listenTo(a, "execute", () => {
              i.execute(t);
              i.editing.view.focus();
            });
            return a;
          });
        }
      }
      class AO extends nu {
        static get requires() {
          return [bO, vO];
        }
        static get pluginName() {
          return "Undo";
        }
      }
      class CO extends nu {
        static get requires() {
          return [rO, mP, uO, AP, nT, AO];
        }
        static get pluginName() {
          return "Essentials";
        }
      }
      class yO extends iu {
        constructor(t, e) {
          super(t);
          this.attributeKey = e;
        }
        refresh() {
          const t = this.editor.model;
          const e = t.document;
          this.value = e.selection.getAttribute(this.attributeKey);
          this.isEnabled = t.schema.checkAttributeInSelection(e.selection, this.attributeKey);
        }
        execute(t = {}) {
          const e = this.editor.model;
          const n = e.document;
          const o = n.selection;
          const i = t.value;
          const r = t.batch;
          const s = (t) => {
            if (o.isCollapsed) {
              if (i) {
                t.setSelectionAttribute(this.attributeKey, i);
              } else {
                t.removeSelectionAttribute(this.attributeKey);
              }
            } else {
              const n = e.schema.getValidRanges(o.getRanges(), this.attributeKey);
              for (const e of n) {
                if (i) {
                  t.setAttribute(this.attributeKey, i, e);
                } else {
                  t.removeAttribute(this.attributeKey, e);
                }
              }
            }
          };
          if (r) {
            e.enqueueChange(r, (t) => {
              s(t);
            });
          } else {
            e.change((t) => {
              s(t);
            });
          }
        }
      }
      const xO = "fontSize";
      const EO = "fontFamily";
      const DO = "fontColor";
      const SO = "fontBackgroundColor";
      function TO(t, e) {
        const n = { model: { key: t, values: [] }, view: {}, upcastAlso: {} };
        for (const t of e) {
          n.model.values.push(t.model);
          n.view[t.model] = t.view;
          if (t.upcastAlso) {
            n.upcastAlso[t.model] = t.upcastAlso;
          }
        }
        return n;
      }
      function PO(t) {
        return (e) => RO(e.getStyle(t));
      }
      function BO(t) {
        return (e, { writer: n }) =>
          n.createAttributeElement("span", { style: `${t}:${e}` }, { priority: 7 });
      }
      function OO({
        dropdownView: t,
        colors: e,
        columns: n,
        removeButtonLabel: o,
        colorPickerLabel: i,
        documentColorsLabel: r,
        documentColorsCount: s,
        colorPickerViewConfig: a,
      }) {
        const c = t.locale;
        const l = new sE(c, {
          colors: e,
          columns: n,
          removeButtonLabel: o,
          colorPickerLabel: i,
          documentColorsLabel: r,
          documentColorsCount: s,
          colorPickerViewConfig: a,
        });
        t.colorSelectorView = l;
        t.panelView.children.add(l);
        return l;
      }
      function RO(t) {
        return t.replace(/\s/g, "");
      }
      class IO extends yO {
        constructor(t) {
          super(t, EO);
        }
      }
      function zO(t) {
        return t.map(FO).filter((t) => t !== undefined);
      }
      function FO(t) {
        if (typeof t === "object") {
          return t;
        }
        if (t === "default") {
          return { title: "Default", model: undefined };
        }
        if (typeof t !== "string") {
          return undefined;
        }
        return MO(t);
      }
      function MO(t) {
        const e = t.replace(/"|'/g, "").split(",");
        const n = e[0];
        const o = e.map(NO).join(", ");
        return {
          title: n,
          model: o,
          view: { name: "span", styles: { "font-family": o }, priority: 7 },
        };
      }
      function NO(t) {
        t = t.trim();
        if (t.indexOf(" ") > 0) {
          t = `'${t}'`;
        }
        return t;
      }
      class VO extends nu {
        static get pluginName() {
          return "FontFamilyEditing";
        }
        constructor(t) {
          super(t);
          t.config.define(EO, {
            options: [
              "default",
              "Arial, Helvetica, sans-serif",
              "Courier New, Courier, monospace",
              "Georgia, serif",
              "Lucida Sans Unicode, Lucida Grande, sans-serif",
              "Tahoma, Geneva, sans-serif",
              "Times New Roman, Times, serif",
              "Trebuchet MS, Helvetica, sans-serif",
              "Verdana, Geneva, sans-serif",
            ],
            supportAllValues: false,
          });
        }
        init() {
          const t = this.editor;
          t.model.schema.extend("$text", { allowAttributes: EO });
          t.model.schema.setAttributeProperties(EO, { isFormatting: true, copyOnEnter: true });
          const e = zO(t.config.get("fontFamily.options")).filter((t) => t.model);
          const n = TO(EO, e);
          if (t.config.get("fontFamily.supportAllValues")) {
            this._prepareAnyValueConverters();
            this._prepareCompatibilityConverter();
          } else {
            t.conversion.attributeToElement(n);
          }
          t.commands.add(EO, new IO(t));
        }
        _prepareAnyValueConverters() {
          const t = this.editor;
          t.conversion
            .for("downcast")
            .attributeToElement({
              model: EO,
              view: (t, { writer: e }) =>
                e.createAttributeElement("span", { style: "font-family:" + t }, { priority: 7 }),
            });
          t.conversion
            .for("upcast")
            .elementToAttribute({
              model: { key: EO, value: (t) => t.getStyle("font-family") },
              view: { name: "span", styles: { "font-family": /.*/ } },
            });
        }
        _prepareCompatibilityConverter() {
          const t = this.editor;
          t.conversion
            .for("upcast")
            .elementToAttribute({
              view: { name: "font", attributes: { face: /.*/ } },
              model: { key: EO, value: (t) => t.getAttribute("face") },
            });
        }
      }
      const LO =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.03 3h6.149a.75.75 0 1 1 0 1.5h-5.514L11.03 3zm1.27 3h4.879a.75.75 0 1 1 0 1.5h-4.244L12.3 6zm1.27 3h3.609a.75.75 0 1 1 0 1.5h-2.973L13.57 9zm-2.754 2.5L8.038 4.785 5.261 11.5h5.555zm.62 1.5H4.641l-1.666 4.028H1.312l5.789-14h1.875l5.789 14h-1.663L11.436 13z"/></svg>';
      class HO extends nu {
        static get pluginName() {
          return "FontFamilyUI";
        }
        init() {
          const t = this.editor;
          const e = t.t;
          const n = this._getLocalizedOptions();
          const o = t.commands.get(EO);
          const i = e("Font Family");
          t.ui.componentFactory.add(EO, (e) => {
            const r = vy(e);
            yy(r, () => jO(n, o), { role: "menu", ariaLabel: i });
            r.buttonView.set({ label: i, icon: LO, tooltip: true });
            r.extendTemplate({ attributes: { class: "ck-font-family-dropdown" } });
            r.bind("isEnabled").to(o);
            this.listenTo(r, "execute", (e) => {
              t.execute(e.source.commandName, { value: e.source.commandParam });
              t.editing.view.focus();
            });
            return r;
          });
        }
        _getLocalizedOptions() {
          const t = this.editor;
          const e = t.t;
          const n = zO(t.config.get(EO).options);
          return n.map((t) => {
            if (t.title === "Default") {
              t.title = e("Default");
            }
            return t;
          });
        }
      }
      function jO(t, e) {
        const n = new ll();
        for (const o of t) {
          const t = {
            type: "button",
            model: new sD({
              commandName: EO,
              commandParam: o.model,
              label: o.title,
              role: "menuitemradio",
              withText: true,
            }),
          };
          t.model.bind("isOn").to(e, "value", (t) => {
            if (t === o.model) {
              return true;
            }
            if (!t || !o.model) {
              return false;
            }
            return t.split(",")[0].replace(/'/g, "").toLowerCase() === o.model.toLowerCase();
          });
          if (o.view && typeof o.view !== "string" && o.view.styles) {
            t.model.set("labelStyle", `font-family: ${o.view.styles["font-family"]}`);
          }
          n.add(t);
        }
        return n;
      }
      class qO extends nu {
        static get requires() {
          return [VO, HO];
        }
        static get pluginName() {
          return "FontFamily";
        }
      }
      class $O extends yO {
        constructor(t) {
          super(t, xO);
        }
      }
      function WO(t) {
        return t.map((t) => KO(t)).filter((t) => t !== undefined);
      }
      const GO = {
        get tiny() {
          return {
            title: "Tiny",
            model: "tiny",
            view: { name: "span", classes: "text-tiny", priority: 7 },
          };
        },
        get small() {
          return {
            title: "Small",
            model: "small",
            view: { name: "span", classes: "text-small", priority: 7 },
          };
        },
        get big() {
          return {
            title: "Big",
            model: "big",
            view: { name: "span", classes: "text-big", priority: 7 },
          };
        },
        get huge() {
          return {
            title: "Huge",
            model: "huge",
            view: { name: "span", classes: "text-huge", priority: 7 },
          };
        },
      };
      function KO(t) {
        if (typeof t === "number") {
          t = String(t);
        }
        if (typeof t === "object" && YO(t)) {
          return ZO(t);
        }
        const e = JO(t);
        if (e) {
          return ZO(e);
        }
        if (t === "default") {
          return { model: undefined, title: "Default" };
        }
        if (QO(t)) {
          return undefined;
        }
        return UO(t);
      }
      function UO(t) {
        if (typeof t === "string") {
          t = { title: t, model: `${parseFloat(t)}px` };
        }
        t.view = { name: "span", styles: { "font-size": t.model } };
        return ZO(t);
      }
      function ZO(t) {
        if (t.view && typeof t.view !== "string" && !t.view.priority) {
          t.view.priority = 7;
        }
        return t;
      }
      function JO(t) {
        return typeof t === "string" ? GO[t] : GO[t.model];
      }
      function YO(t) {
        return t.title && t.model && t.view;
      }
      function QO(t) {
        let e;
        if (typeof t === "object") {
          if (!t.model) {
            throw new P("font-size-invalid-definition", null, t);
          } else {
            e = parseFloat(t.model);
          }
        } else {
          e = parseFloat(t);
        }
        return isNaN(e);
      }
      const XO = [
        "x-small",
        "x-small",
        "small",
        "medium",
        "large",
        "x-large",
        "xx-large",
        "xxx-large",
      ];
      class tR extends nu {
        static get pluginName() {
          return "FontSizeEditing";
        }
        constructor(t) {
          super(t);
          t.config.define(xO, {
            options: ["tiny", "small", "default", "big", "huge"],
            supportAllValues: false,
          });
        }
        init() {
          const t = this.editor;
          t.model.schema.extend("$text", { allowAttributes: xO });
          t.model.schema.setAttributeProperties(xO, { isFormatting: true, copyOnEnter: true });
          const e = t.config.get("fontSize.supportAllValues");
          const n = WO(this.editor.config.get("fontSize.options")).filter((t) => t.model);
          const o = TO(xO, n);
          if (e) {
            this._prepareAnyValueConverters(o);
            this._prepareCompatibilityConverter();
          } else {
            t.conversion.attributeToElement(o);
          }
          t.commands.add(xO, new $O(t));
        }
        _prepareAnyValueConverters(t) {
          const e = this.editor;
          const n = t.model.values.filter((t) => !mA(String(t)) && !bA(String(t)));
          if (n.length) {
            throw new P("font-size-invalid-use-of-named-presets", null, { presets: n });
          }
          e.conversion.for("downcast").attributeToElement({
            model: xO,
            view: (t, { writer: e }) => {
              if (!t) {
                return;
              }
              return e.createAttributeElement("span", { style: "font-size:" + t }, { priority: 7 });
            },
          });
          e.conversion
            .for("upcast")
            .elementToAttribute({
              model: { key: xO, value: (t) => t.getStyle("font-size") },
              view: { name: "span", styles: { "font-size": /.*/ } },
            });
        }
        _prepareCompatibilityConverter() {
          const t = this.editor;
          t.conversion.for("upcast").elementToAttribute({
            view: { name: "font", attributes: { size: /^[+-]?\d{1,3}$/ } },
            model: {
              key: xO,
              value: (t) => {
                const e = t.getAttribute("size");
                const n = e[0] === "-" || e[0] === "+";
                let o = parseInt(e, 10);
                if (n) {
                  o = 3 + o;
                }
                const i = XO.length - 1;
                const r = Math.min(Math.max(o, 0), i);
                return XO[r];
              },
            },
          });
        }
      }
      var eR = n(991);
      var nR = { injectType: "singletonStyleTag", attributes: { "data-cke": true } };
      nR.insert = "head";
      nR.singleton = true;
      var oR = Pl()(eR.Z, nR);
      const iR = eR.Z.locals || {};
      const rR =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13zm7.55 2.279.779-.779.707.707-2.265 2.265-2.193-2.265.707-.707.765.765V4.825c0-.042 0-.083.002-.123l-.77.77-.707-.707L17.207 2.5l2.265 2.265-.707.707-.782-.782c.002.043.003.089.003.135v10.454z"/></svg>';
      class sR extends nu {
        static get pluginName() {
          return "FontSizeUI";
        }
        init() {
          const t = this.editor;
          const e = t.t;
          const n = this._getLocalizedOptions();
          const o = t.commands.get(xO);
          const i = e("Font Size");
          t.ui.componentFactory.add(xO, (e) => {
            const r = vy(e);
            yy(r, () => aR(n, o), { role: "menu", ariaLabel: i });
            r.buttonView.set({ label: i, icon: rR, tooltip: true });
            r.extendTemplate({ attributes: { class: ["ck-font-size-dropdown"] } });
            r.bind("isEnabled").to(o);
            this.listenTo(r, "execute", (e) => {
              t.execute(e.source.commandName, { value: e.source.commandParam });
              t.editing.view.focus();
            });
            return r;
          });
        }
        _getLocalizedOptions() {
          const t = this.editor;
          const e = t.t;
          const n = {
            Default: e("Default"),
            Tiny: e("Tiny"),
            Small: e("Small"),
            Big: e("Big"),
            Huge: e("Huge"),
          };
          const o = WO(t.config.get(xO).options);
          return o.map((t) => {
            const e = n[t.title];
            if (e && e != t.title) {
              t = Object.assign({}, t, { title: e });
            }
            return t;
          });
        }
      }
      function aR(t, e) {
        const n = new ll();
        for (const o of t) {
          const t = {
            type: "button",
            model: new sD({
              commandName: xO,
              commandParam: o.model,
              label: o.title,
              class: "ck-fontsize-option",
              role: "menuitemradio",
              withText: true,
            }),
          };
          if (o.view && typeof o.view !== "string") {
            if (o.view.styles) {
              t.model.set("labelStyle", `font-size:${o.view.styles["font-size"]}`);
            }
            if (o.view.classes) {
              t.model.set("class", `${t.model.class} ${o.view.classes}`);
            }
          }
          t.model.bind("isOn").to(e, "value", (t) => t === o.model);
          n.add(t);
        }
        return n;
      }
      class cR extends nu {
        static get requires() {
          return [tR, sR];
        }
        static get pluginName() {
          return "FontSize";
        }
        normalizeSizeOptions(t) {
          return WO(t);
        }
      }
      class lR extends yO {
        constructor(t) {
          super(t, DO);
        }
      }
      class dR extends nu {
        static get pluginName() {
          return "FontColorEditing";
        }
        constructor(t) {
          super(t);
          t.config.define(DO, {
            colors: [
              { color: "hsl(0, 0%, 0%)", label: "Black" },
              { color: "hsl(0, 0%, 30%)", label: "Dim grey" },
              { color: "hsl(0, 0%, 60%)", label: "Grey" },
              { color: "hsl(0, 0%, 90%)", label: "Light grey" },
              { color: "hsl(0, 0%, 100%)", label: "White", hasBorder: true },
              { color: "hsl(0, 75%, 60%)", label: "Red" },
              { color: "hsl(30, 75%, 60%)", label: "Orange" },
              { color: "hsl(60, 75%, 60%)", label: "Yellow" },
              { color: "hsl(90, 75%, 60%)", label: "Light green" },
              { color: "hsl(120, 75%, 60%)", label: "Green" },
              { color: "hsl(150, 75%, 60%)", label: "Aquamarine" },
              { color: "hsl(180, 75%, 60%)", label: "Turquoise" },
              { color: "hsl(210, 75%, 60%)", label: "Light blue" },
              { color: "hsl(240, 75%, 60%)", label: "Blue" },
              { color: "hsl(270, 75%, 60%)", label: "Purple" },
            ],
            columns: 5,
          });
          t.conversion
            .for("upcast")
            .elementToAttribute({
              view: { name: "span", styles: { color: /[\s\S]+/ } },
              model: { key: DO, value: PO("color") },
            });
          t.conversion
            .for("upcast")
            .elementToAttribute({
              view: { name: "font", attributes: { color: /^#?\w+$/ } },
              model: { key: DO, value: (t) => t.getAttribute("color") },
            });
          t.conversion.for("downcast").attributeToElement({ model: DO, view: BO("color") });
          t.commands.add(DO, new lR(t));
          t.model.schema.extend("$text", { allowAttributes: DO });
          t.model.schema.setAttributeProperties(DO, { isFormatting: true, copyOnEnter: true });
        }
      }
      class hR extends nu {
        constructor(t, { commandName: e, componentName: n, icon: o, dropdownLabel: i }) {
          super(t);
          this.commandName = e;
          this.componentName = n;
          this.icon = o;
          this.dropdownLabel = i;
          this.columns = t.config.get(`${this.componentName}.columns`);
          this.colorSelectorView = undefined;
        }
        init() {
          const t = this.editor;
          const e = t.locale;
          const n = e.t;
          const o = t.commands.get(this.commandName);
          const i = t.config.get(this.componentName);
          const r = Sd(i.colors);
          const s = Dd(e, r);
          const a = i.documentColors;
          const c = i.colorPicker !== false;
          t.ui.componentFactory.add(this.componentName, (e) => {
            const r = vy(e);
            let l = false;
            this.colorSelectorView = OO({
              dropdownView: r,
              colors: s.map((t) => ({
                label: t.label,
                color: t.model,
                options: { hasBorder: t.hasBorder },
              })),
              columns: this.columns,
              removeButtonLabel: n("Remove color"),
              colorPickerLabel: n("Color picker"),
              documentColorsLabel: a !== 0 ? n("Document colors") : "",
              documentColorsCount: a === undefined ? this.columns : a,
              colorPickerViewConfig: c ? i.colorPicker || {} : false,
            });
            this.colorSelectorView.bind("selectedColor").to(o, "value");
            r.buttonView.set({ label: this.dropdownLabel, icon: this.icon, tooltip: true });
            r.extendTemplate({ attributes: { class: "ck-color-ui-dropdown" } });
            r.bind("isEnabled").to(o);
            this.colorSelectorView.on("execute", (e, n) => {
              if (r.isOpen) {
                t.execute(this.commandName, { value: n.value, batch: this._undoStepBatch });
              }
              if (n.source !== "colorPicker") {
                t.editing.view.focus();
              }
              if (n.source === "colorPickerSaveButton") {
                r.isOpen = false;
              }
            });
            this.colorSelectorView.on("colorPicker:show", () => {
              this._undoStepBatch = t.model.createBatch();
            });
            this.colorSelectorView.on("colorPicker:cancel", () => {
              if (this._undoStepBatch.operations.length) {
                r.isOpen = false;
                t.execute("undo", this._undoStepBatch);
              }
              t.editing.view.focus();
            });
            r.on("change:isOpen", (e, n, o) => {
              if (!l) {
                l = true;
                r.colorSelectorView.appendUI();
              }
              if (o) {
                if (a !== 0) {
                  this.colorSelectorView.updateDocumentColors(t.model, this.componentName);
                }
                this.colorSelectorView.updateSelectedColors();
                this.colorSelectorView.showColorGridsFragment();
              }
            });
            Ey(r, () =>
              r.colorSelectorView.colorGridsFragmentView.staticColorsGrid.items.find((t) => t.isOn)
            );
            return r;
          });
        }
      }
      const uR =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.4 10.3 10 4.5l-2.4 5.8h4.8zm.5 1.2H7.1L5.7 15H4.2l5-12h1.6l5 12h-1.5L13 11.5zm3.1 7H4a1 1 0 0 1 0-2h12a1 1 0 0 1 0 2z"/></svg>';
      class fR extends hR {
        constructor(t) {
          const e = t.locale.t;
          super(t, {
            commandName: DO,
            componentName: DO,
            icon: uR,
            dropdownLabel: e("Font Color"),
          });
        }
        static get pluginName() {
          return "FontColorUI";
        }
      }
      class pR extends nu {
        static get requires() {
          return [dR, fR];
        }
        static get pluginName() {
          return "FontColor";
        }
      }
      class gR extends (null && FontCommand) {
        constructor(t) {
          super(t, FONT_BACKGROUND_COLOR);
        }
      }
      class mR extends (null && Plugin) {
        static get pluginName() {
          return "FontBackgroundColorEditing";
        }
        constructor(t) {
          super(t);
          t.config.define(FONT_BACKGROUND_COLOR, {
            colors: [
              { color: "hsl(0, 0%, 0%)", label: "Black" },
              { color: "hsl(0, 0%, 30%)", label: "Dim grey" },
              { color: "hsl(0, 0%, 60%)", label: "Grey" },
              { color: "hsl(0, 0%, 90%)", label: "Light grey" },
              { color: "hsl(0, 0%, 100%)", label: "White", hasBorder: true },
              { color: "hsl(0, 75%, 60%)", label: "Red" },
              { color: "hsl(30, 75%, 60%)", label: "Orange" },
              { color: "hsl(60, 75%, 60%)", label: "Yellow" },
              { color: "hsl(90, 75%, 60%)", label: "Light green" },
              { color: "hsl(120, 75%, 60%)", label: "Green" },
              { color: "hsl(150, 75%, 60%)", label: "Aquamarine" },
              { color: "hsl(180, 75%, 60%)", label: "Turquoise" },
              { color: "hsl(210, 75%, 60%)", label: "Light blue" },
              { color: "hsl(240, 75%, 60%)", label: "Blue" },
              { color: "hsl(270, 75%, 60%)", label: "Purple" },
            ],
            columns: 5,
          });
          t.data.addStyleProcessorRules(addBackgroundRules);
          t.conversion
            .for("upcast")
            .elementToAttribute({
              view: { name: "span", styles: { "background-color": /[\s\S]+/ } },
              model: {
                key: FONT_BACKGROUND_COLOR,
                value: renderUpcastAttribute("background-color"),
              },
            });
          t.conversion
            .for("downcast")
            .attributeToElement({
              model: FONT_BACKGROUND_COLOR,
              view: renderDowncastElement("background-color"),
            });
          t.commands.add(FONT_BACKGROUND_COLOR, new FontBackgroundColorCommand(t));
          t.model.schema.extend("$text", { allowAttributes: FONT_BACKGROUND_COLOR });
          t.model.schema.setAttributeProperties(FONT_BACKGROUND_COLOR, {
            isFormatting: true,
            copyOnEnter: true,
          });
        }
      }
      class kR extends (null && ColorUI) {
        constructor(t) {
          const e = t.locale.t;
          super(t, {
            commandName: FONT_BACKGROUND_COLOR,
            componentName: FONT_BACKGROUND_COLOR,
            icon: fontBackgroundColorIcon,
            dropdownLabel: e("Font Background Color"),
          });
        }
        static get pluginName() {
          return "FontBackgroundColorUI";
        }
      }
      class bR extends (null && Plugin) {
        static get requires() {
          return [FontBackgroundColorEditing, FontBackgroundColorUI];
        }
        static get pluginName() {
          return "FontBackgroundColor";
        }
      }
      class wR extends (null && Plugin) {
        static get requires() {
          return [FontFamily, FontSize, FontColor, FontBackgroundColor];
        }
        static get pluginName() {
          return "Font";
        }
      }
      class _R extends iu {
        constructor(t) {
          super(t);
          this._isEnabledBasedOnSelection = false;
        }
        refresh() {
          const t = this.editor.model;
          const e = t.document;
          const n = dl(e.selection.getSelectedBlocks());
          this.value = !!n && n.is("element", "paragraph");
          this.isEnabled = !!n && vR(n, t.schema);
        }
        execute(t = {}) {
          const e = this.editor.model;
          const n = e.document;
          const o = t.selection || n.selection;
          if (!e.canEditAt(o)) {
            return;
          }
          e.change((t) => {
            const n = o.getSelectedBlocks();
            for (const o of n) {
              if (!o.is("element", "paragraph") && vR(o, e.schema)) {
                t.rename(o, "paragraph");
              }
            }
          });
        }
      }
      function vR(t, e) {
        return e.checkChild(t.parent, "paragraph") && !e.isObject(t);
      }
      class AR extends iu {
        constructor(t) {
          super(t);
          this._isEnabledBasedOnSelection = false;
        }
        execute(t) {
          const e = this.editor.model;
          const n = t.attributes;
          let o = t.position;
          if (!e.canEditAt(o)) {
            return;
          }
          e.change((t) => {
            o = this._findPositionToInsertParagraph(o, t);
            if (!o) {
              return;
            }
            const i = t.createElement("paragraph");
            if (n) {
              e.schema.setAllowedAttributes(i, n, t);
            }
            e.insertContent(i, o);
            t.setSelection(i, "in");
          });
        }
        _findPositionToInsertParagraph(t, e) {
          const n = this.editor.model;
          if (n.schema.checkChild(t, "paragraph")) {
            return t;
          }
          const o = n.schema.findAllowedParent(t, "paragraph");
          if (!o) {
            return null;
          }
          const i = t.parent;
          const r = n.schema.checkChild(i, "$text");
          if (i.isEmpty || (r && t.isAtEnd)) {
            return n.createPositionAfter(i);
          }
          if (!i.isEmpty && r && t.isAtStart) {
            return n.createPositionBefore(i);
          }
          return e.split(t, o).position;
        }
      }
      class CR extends nu {
        static get pluginName() {
          return "Paragraph";
        }
        init() {
          const t = this.editor;
          const e = t.model;
          t.commands.add("paragraph", new _R(t));
          t.commands.add("insertParagraph", new AR(t));
          e.schema.register("paragraph", { inheritAllFrom: "$block" });
          t.conversion.elementToElement({ model: "paragraph", view: "p" });
          t.conversion.for("upcast").elementToElement({
            model: (t, { writer: e }) => {
              if (!CR.paragraphLikeElements.has(t.name)) {
                return null;
              }
              if (t.isEmpty) {
                return null;
              }
              return e.createElement("paragraph");
            },
            view: /.+/,
            converterPriority: "low",
          });
        }
      }
      CR.paragraphLikeElements = new Set([
        "blockquote",
        "dd",
        "div",
        "dt",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "li",
        "p",
        "td",
        "th",
      ]);
      const yR = jC.paragraph;
      class xR extends (null && Plugin) {
        static get requires() {
          return [Paragraph];
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.ui.componentFactory.add("paragraph", (n) => {
            const o = new ButtonView(n);
            const i = t.commands.get("paragraph");
            o.label = e("Paragraph");
            o.icon = yR;
            o.tooltip = true;
            o.isToggleable = true;
            o.bind("isEnabled").to(i);
            o.bind("isOn").to(i, "value");
            o.on("execute", () => {
              t.execute("paragraph");
            });
            return o;
          });
        }
      }
      class ER extends TS {}
      ER.builtinPlugins = [MS, CO, pR, qO, cR, FT, CR, pT, oP];
      ER.defaultConfig = {
        toolbar: {
          items: ["bold", "italic", "|", "fontFamily", "fontSize", "fontColor", "underline"],
        },
        language: "ko",
      };
      const DR = ER;
    })();
    o = o["default"];
    return o;
  })()
);
//# sourceMappingURL=ckeditor.js.map
